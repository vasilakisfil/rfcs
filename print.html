<!DOCTYPE HTML>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title></title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <base href="">

        <link rel="stylesheet" href="book.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <link rel="shortcut icon" href="favicon.png">

        <!-- Font Awesome -->
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">

        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme -->
        

        

        <!-- Fetch Clipboard.js from CDN but have a local fallback -->
        <script src="https://cdn.jsdelivr.net/clipboard.js/1.6.1/clipboard.min.js"></script>
        <script>
            if (typeof Clipboard == 'undefined') {
                document.write(unescape("%3Cscript src='clipboard.min.js'%3E%3C/script%3E"));
            }
        </script>

        <!-- Fetch JQuery from CDN but have a local fallback -->
        <script src="https://code.jquery.com/jquery-2.1.4.min.js"></script>
        <script>
            if (typeof jQuery == 'undefined') {
                document.write(unescape("%3Cscript src='jquery.js'%3E%3C/script%3E"));
            }
        </script>

        <!-- Fetch store.js from local - TODO add CDN when 2.x.x is available on cdnjs -->
        <script src="store.js"></script>

        <!-- Custom JS script -->
        

    </head>
    <body class="light">
        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme = store.get('mdbook-theme');
            if (theme === null || theme === undefined) { theme = 'light'; }
            $('body').removeClass().addClass(theme);
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var sidebar = store.get('mdbook-sidebar');
            if (sidebar === "hidden") { $("html").addClass("sidebar-hidden") }
            else if (sidebar === "visible") { $("html").addClass("sidebar-visible") }
        </script>

        <div id="sidebar" class="sidebar">
            <ul class="chapter"><li class="affix"><a href="introduction.html">Introduction</a></li><li><a href="0000-deprecate-computed-clobberability.html"><strong>1.</strong> 0000-deprecate-computed-clobberability</a></li><li><a href="0000-deprecate-computed-property-modifier.html"><strong>2.</strong> 0000-deprecate-computed-property-modifier</a></li><li><a href="0001-transform-attribute-meta-parameter.html"><strong>3.</strong> 0001-transform-attribute-meta-parameter</a></li><li><a href="0003-block-params.html"><strong>4.</strong> 0003-block-params</a></li><li><a href="0010-engines.html"><strong>5.</strong> 0010-engines</a></li><li><a href="0011-improved-cp-syntax.html"><strong>6.</strong> 0011-improved-cp-syntax</a></li><li><a href="0015-the-road-to-ember-2-0.html"><strong>7.</strong> 0015-the-road-to-ember-2-0</a></li><li><a href="0024-bound-attributes.html"><strong>8.</strong> 0024-bound-attributes</a></li><li><a href="0045-internet-explorer.html"><strong>9.</strong> 0045-internet-explorer</a></li><li><a href="0046-registry-reform.html"><strong>10.</strong> 0046-registry-reform</a></li><li><a href="0050-improved-actions.html"><strong>11.</strong> 0050-improved-actions</a></li><li><a href="0053-helpers.html"><strong>12.</strong> 0053-helpers</a></li><li><a href="0056-improved-release-cycle.html"><strong>13.</strong> 0056-improved-release-cycle</a></li><li><a href="0057-ember-data-reference-unification.html"><strong>14.</strong> 0057-ember-data-reference-unification</a></li><li><a href="0058-helper-listing.html"><strong>15.</strong> 0058-helper-listing</a></li><li><a href="0061-ember-data-background-fetch.html"><strong>16.</strong> 0061-ember-data-background-fetch</a></li><li><a href="0064-contextual-component-lookup.html"><strong>17.</strong> 0064-contextual-component-lookup</a></li><li><a href="0065-deprecation-warning-handlers.html"><strong>18.</strong> 0065-deprecation-warning-handlers</a></li><li><a href="0091-weakmap.html"><strong>19.</strong> 0091-weakmap</a></li><li><a href="0095-router-service.html"><strong>20.</strong> 0095-router-service</a></li><li><a href="0101-ember-data-friendly-errors.html"><strong>21.</strong> 0101-ember-data-friendly-errors</a></li><li><a href="0120-route-serializers.html"><strong>22.</strong> 0120-route-serializers</a></li><li><a href="0136-contains-to-includes.html"><strong>23.</strong> 0136-contains-to-includes</a></li><li><a href="0139-isHtmlSafe.html"><strong>24.</strong> 0139-isHtmlSafe</a></li><li><a href="0143-module-unification.html"><strong>25.</strong> 0143-module-unification</a></li><li><a href="0150-factory-for.html"><strong>26.</strong> 0150-factory-for</a></li><li><a href="0176-javascript-module-api.html"><strong>27.</strong> 0176-javascript-module-api</a></li><li><a href="0178-deprecate-ember-k.html"><strong>28.</strong> 0178-deprecate-ember-k</a></li><li><a href="0181-deprecate-ember-data-initializers.html"><strong>29.</strong> 0181-deprecate-ember-data-initializers</a></li><li><a href="0186-track-unique-history-location-state.html"><strong>30.</strong> 0186-track-unique-history-location-state</a></li><li><a href="0191-deprecate-component-lifecycle-hook-args.html"><strong>31.</strong> 0191-deprecate-component-lifecycle-hook-args</a></li><li><a href="0194-deprecate-custom-event-manager.html"><strong>32.</strong> 0194-deprecate-custom-event-manager</a></li><li><a href="0213-custom-components.html"><strong>33.</strong> 0213-custom-components</a></li><li><a href="0225-ember-engines-mount-params.html"><strong>34.</strong> 0225-ember-engines-mount-params</a></li><li><a href="0226-named-blocks.html"><strong>35.</strong> 0226-named-blocks</a></li><li><a href="0229-deprecate-testing-restricted-resolver.html"><strong>36.</strong> 0229-deprecate-testing-restricted-resolver</a></li><li><a href="0232-simplify-qunit-testing-api.html"><strong>37.</strong> 0232-simplify-qunit-testing-api</a></li><li><a href="0236-deprecation-ember-string.html"><strong>38.</strong> 0236-deprecation-ember-string</a></li><li><a href="0237-deprecation-ember-map.html"><strong>39.</strong> 0237-deprecation-ember-map</a></li><li><a href="0240-es-classes.html"><strong>40.</strong> 0240-es-classes</a></li><li><a href="0252-browser-support-changes.html"><strong>41.</strong> 0252-browser-support-changes</a></li><li><a href="0268-acceptance-testing-refactor.html"><strong>42.</strong> 0268-acceptance-testing-refactor</a></li><li><a href="0276-named-args.html"><strong>43.</strong> 0276-named-args</a></li><li><a href="0278-template-only-components.html"><strong>44.</strong> 0278-template-only-components</a></li><li><a href="0280-remove-application-wrapper.html"><strong>45.</strong> 0280-remove-application-wrapper</a></li><li><a href="0281-es5-getters.html"><strong>46.</strong> 0281-es5-getters</a></li><li><a href="0286-block-let-template-helper.html"><strong>47.</strong> 0286-block-let-template-helper</a></li><li><a href="0287-promote-in-element-to-public-api.html"><strong>48.</strong> 0287-promote-in-element-to-public-api</a></li><li><a href="0293-record-data.html"><strong>49.</strong> 0293-record-data</a></li><li><a href="0294-optional-jquery.html"><strong>50.</strong> 0294-optional-jquery</a></li><li><a href="0297-deprecate-ember-logger.html"><strong>51.</strong> 0297-deprecate-ember-logger</a></li><li><a href="0308-deprecate-property-lookup-fallback.html"><strong>52.</strong> 0308-deprecate-property-lookup-fallback</a></li><li><a href="0311-angle-bracket-invocation.html"><strong>53.</strong> 0311-angle-bracket-invocation</a></li><li><a href="0318-array-helper.html"><strong>54.</strong> 0318-array-helper</a></li><li><a href="0322-deprecate-copy-copyable.html"><strong>55.</strong> 0322-deprecate-copy-copyable</a></li><li><a href="0324-deprecate-component-isvisible.html"><strong>56.</strong> 0324-deprecate-component-isvisible</a></li><li><a href="0326-ember-data-filter-deprecation.html"><strong>57.</strong> 0326-ember-data-filter-deprecation</a></li><li><a href="0329-deprecated-ember-evented-in-ember-data.html"><strong>58.</strong> 0329-deprecated-ember-evented-in-ember-data</a></li><li><a href="0331-deprecate-globals-resolver.html"><strong>59.</strong> 0331-deprecate-globals-resolver</a></li><li><a href="0332-ember-data-record-links-and-meta.html"><strong>60.</strong> 0332-ember-data-record-links-and-meta</a></li><li><a href="0335-deprecate-send-action.html"><strong>61.</strong> 0335-deprecate-send-action</a></li><li><a href="0337-native-class-constructor-update.html"><strong>62.</strong> 0337-native-class-constructor-update</a></li><li><a href="0340-deprecate-ember-merge.html"><strong>63.</strong> 0340-deprecate-ember-merge</a></li><li><a href="0345-discord.html"><strong>64.</strong> 0345-discord</a></li><li><a href="0370-deprecate-computed-volatile.html"><strong>65.</strong> 0370-deprecate-computed-volatile</a></li><li><a href="0372-ember-data-model-factory-for.html"><strong>66.</strong> 0372-ember-data-model-factory-for</a></li><li><a href="0373-Element-Modifier-Managers.html"><strong>67.</strong> 0373-Element-Modifier-Managers</a></li></ul>
        </div>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page" tabindex="-1">
                <div id="menu-bar" class="menu-bar">
                    <div class="left-buttons">
                        <i id="sidebar-toggle" class="fa fa-bars"></i>
                        <i id="theme-toggle" class="fa fa-paint-brush"></i>
                    </div>

                    <h1 class="menu-title"></h1>

                    <div class="right-buttons">
                        <a href="print.html">
                            <i id="print-button" class="fa fa-print" title="Print this book"></i>
                        </a>
                    </div>
                </div>

                <div id="content" class="content">
                    <a class="header" href="print.html#ember-rfcs" id="ember-rfcs"><h1>Ember RFCs</h1></a>
<p>Many changes, including bug fixes and documentation improvements can be
implemented and reviewed via the normal GitHub pull request workflow.</p>
<p>Some changes though are &quot;substantial&quot;, and we ask that these be put
through a bit of a design process and produce a consensus among the Ember
core team.</p>
<p>The &quot;RFC&quot; (request for comments) process is intended to provide a
consistent and controlled path for new features to enter the framework.</p>
<p><a href="https://github.com/emberjs/rfcs/pulls">Active RFC List</a></p>
<a class="header" href="print.html#when-you-need-to-follow-this-process" id="when-you-need-to-follow-this-process"><h2>When you need to follow this process</h2></a>
<p>You need to follow this process if you intend to make &quot;substantial&quot;
changes to Ember, Ember Data or its documentation. What constitutes a
&quot;substantial&quot; change is evolving based on community norms, but may
include the following.</p>
<ul>
<li>A new feature that creates new API surface area, and would
require a <a href="http://emberjs.com/guides/contributing/adding-new-features/">feature flag</a> if introduced.</li>
<li>The removal of features that already shipped as part of the release
channel.</li>
<li>The introduction of new idiomatic usage or conventions, even if they
do not include code changes to Ember itself.</li>
</ul>
<p>Some changes do not require an RFC:</p>
<ul>
<li>Rephrasing, reorganizing or refactoring</li>
<li>Addition or removal of warnings</li>
<li>Additions that strictly improve objective, numerical quality
criteria (speedup, better browser support)</li>
<li>Additions only likely to be <em>noticed by</em> other implementors-of-Ember,
invisible to users-of-Ember.</li>
</ul>
<p>If you submit a pull request to implement a new feature without going
through the RFC process, it may be closed with a polite request to
submit an RFC first.</p>
<a class="header" href="print.html#gathering-feedback-before-submitting" id="gathering-feedback-before-submitting"><h2>Gathering feedback before submitting</h2></a>
<p>It's often helpful to get feedback on your concept before diving into the
level of API design detail required for an RFC. <strong>You may open an
issue on this repo to start a high-level discussion</strong>, with the goal of
eventually formulating an RFC pull request with the specific implementation
design.</p>
<a class="header" href="print.html#what-the-process-is" id="what-the-process-is"><h2>What the process is</h2></a>
<p>In short, to get a major feature added to Ember, one must first get the
RFC merged into the RFC repo as a markdown file. At that point the RFC
is 'active' and may be implemented with the goal of eventual inclusion
into Ember.</p>
<ul>
<li>Fork the RFC repo http://github.com/emberjs/rfcs</li>
<li>Copy <code>0000-template.md</code> to <code>text/0000-my-feature.md</code> (where
'my-feature' is descriptive. don't assign an RFC number yet).</li>
<li>Fill in the RFC. Put care into the details: <strong>RFCs that do not
present convincing motivation, demonstrate understanding of the
impact of the design, or are disingenuous about the drawbacks or
alternatives tend to be poorly-received</strong>.</li>
<li>Submit a pull request. As a pull request the RFC will receive design
feedback from the larger community, and the author should be prepared
to revise it in response.</li>
<li>Build consensus and integrate feedback. RFCs that have broad support
are much more likely to make progress than those that don't receive any
comments.</li>
<li>Eventually, the <a href="http://emberjs.com/team/">core team</a> will decide whether the RFC is a candidate
for inclusion in Ember.</li>
<li>RFCs that are candidates for inclusion in Ember will enter a &quot;final comment
period&quot; lasting 7 days. The beginning of this period will be signaled with a
comment and tag on the RFC's pull request. Furthermore,
<a href="https://twitter.com/emberjs">Ember's official Twitter account</a> will post a
tweet about the RFC to attract the community's attention.</li>
<li>An RFC can be modified based upon feedback from the <a href="http://emberjs.com/team/">core team</a> and community.
Significant modifications may trigger a new final comment period.</li>
<li>An RFC may be rejected by the <a href="http://emberjs.com/team/">core team</a> after public discussion has settled
and comments have been made summarizing the rationale for rejection. A member of
the <a href="http://emberjs.com/team/">core team</a> should then close the RFC's associated pull request.</li>
<li>An RFC may be accepted at the close of its final comment period. A <a href="http://emberjs.com/team/">core team</a>
member will merge the RFC's associated pull request, at which point the RFC will
become 'active'.</li>
</ul>
<a class="header" href="print.html#the-rfc-life-cycle" id="the-rfc-life-cycle"><h2>The RFC life-cycle</h2></a>
<p>Once an RFC becomes active then authors may implement it and submit the
feature as a pull request to the Ember repo. Becoming 'active' is not a rubber
stamp, and in particular still does not mean the feature will ultimately
be merged; it does mean that the core team has agreed to it in principle
and are amenable to merging it.</p>
<p>Furthermore, the fact that a given RFC has been accepted and is
'active' implies nothing about what priority is assigned to its
implementation, nor whether anybody is currently working on it.</p>
<p>Modifications to active RFC's can be done in followup PR's. We strive
to write each RFC in a manner that it will reflect the final design of
the feature; but the nature of the process means that we cannot expect
every merged RFC to actually reflect what the end result will be at
the time of the next major release; therefore we try to keep each RFC
document somewhat in sync with the language feature as planned,
tracking such changes via followup pull requests to the document.</p>
<a class="header" href="print.html#implementing-an-rfc" id="implementing-an-rfc"><h2>Implementing an RFC</h2></a>
<p>The author of an RFC is not obligated to implement it. Of course, the
RFC author (like any other developer) is welcome to post an
implementation for review after the RFC has been accepted.</p>
<p>If you are interested in working on the implementation for an 'active'
RFC, but cannot determine if someone else is already working on it,
feel free to ask (e.g. by leaving a comment on the associated issue).</p>
<a class="header" href="print.html#reviewing-rfcs" id="reviewing-rfcs"><h2>Reviewing RFC's</h2></a>
<p>Each week the <a href="http://emberjs.com/team/">core team</a> will attempt to review some set of open RFC
pull requests.</p>
<p>We try to make sure that any RFC that we accept is accepted at the
Friday team meeting, and reported in <a href="https://github.com/emberjs/core-notes/tree/master/ember.js">core team notes</a>. Every
accepted feature should have a core team champion, who will represent
the feature and its progress.</p>
<p><strong>Ember's RFC process owes its inspiration to the <a href="https://github.com/rust-lang/rfcs">Rust RFC process</a></strong></p>
<ul>
<li>Start Date: 2018-08-30</li>
<li>RFC PR: (leave this empty)</li>
<li>Ember Issue: (leave this empty)</li>
</ul>
<a class="header" href="print.html#summary" id="summary"><h1>Summary</h1></a>
<p>Deprecate computed overridability and <code>computed().readOnly()</code> in favor of
read-only computeds as the default.</p>
<a class="header" href="print.html#motivation" id="motivation"><h1>Motivation</h1></a>
<p>Computed properties have existed in Ember long before class syntax and native
accessors (getters and setters) were readily available, and as such they have a
few notable behavioral differences. As we move toward adopting native class
syntax and using a decorator-based form of computeds, it makes sense to
reconcile these differences so that users can expect them to work the same as
their native counterparts.</p>
<p>The main and most notable difference this RFC seeks to deprecate is computed
overridability (colloquially known as &quot;clobbering&quot;). There are some other
notable differences, including the caching behavior of the <code>return</code> value of
setter functions, which may be addressed in future RFCs.</p>
<a class="header" href="print.html#overridability" id="overridability"><h2>Overridability</h2></a>
<p>When defining a native getter without a setter, attempting to set the value will
throw a hard error (in strict mode):</p>
<pre><code class="language-js">function makeFoo() {
  'use strict';

  class Foo {
    get bar() {
      return this._value;
    }
  }

  let foo = new Foo();

  foo.bar; // undefined
  foo.bar = 'baz'; // throws an error in strict mode
}
</code></pre>
<p>By constrast, computed properties without setters will be overridden when they
are set, meaning the computed property is removed from the object and replaced
with the set value:</p>
<pre><code class="language-js">const Foo = EmberObject.extend({
  bar: computed('_value', {
    get() {
      return this._value;
    },
  }),
});

let foo = Foo.create();

foo.bar; // undefined
foo.set('bar', 'baz'); // Overwrites the getter
foo.bar; // 'baz'
foo.set('_value', 123);
foo.bar; // 'baz'
</code></pre>
<p>This behavior is confusing to newcomers, and oftentimes unexpected. Common best
practice is to opt-out of it by declaring the property as <code>readOnly</code>, which
prevents this overridability.</p>
<a class="header" href="print.html#transition-path" id="transition-path"><h1>Transition Path</h1></a>
<p>This RFC proposes that <code>readOnly</code> properties become the default, and that in
order to override users must opt in by defining their own setters:</p>
<pre><code class="language-js">class Foo {
  get bar() {
    if (this._bar) {
      return this._bar;
    }

    return this._value
  }

  set bar(value) {
    this._bar = value
  }
}
</code></pre>
<a class="header" href="print.html#macros" id="macros"><h2>Macros</h2></a>
<p>Most computed macros are overridable by default, the exception being <code>readOnly</code>.
This RFC proposes that all computed macros with the exception of <code>reads</code> would
become read only by default. The purpose of <code>reads</code> is to <em>be</em> overridable, so
its behavior would remain the same.</p>
<a class="header" href="print.html#decorator-interop" id="decorator-interop"><h2>Decorator Interop</h2></a>
<p>It may be somewhat cumbersome to write overriding functionality or add proxy
properties when overriding is needed. In an ideal world, computed properties
would modify accessors transparently so that they could be composed with other
decorators, such as an <code>@overridable</code> decorator:</p>
<pre><code class="language-js">class Foo {
  @overridable
  @computed('_value')
  get bar() {
    return this._value;
  }

  @overridable
  @and('baz', 'qux')
  quux;
}
</code></pre>
<p>Currently this is not possible as computed properties store their getter/setter
functions elsewhere and replace them with a proxy getter and the mandatory
setter assertion, respectively. In the long term, making computeds more
transparent in this way would be ideal, but it is out of scope for this RFC.</p>
<a class="header" href="print.html#deprecation-timeline" id="deprecation-timeline"><h2>Deprecation Timeline</h2></a>
<p>This change will be a breaking change, which means we will not be able to change
the behavior of <code>computed</code> until Ember v4.0.0. Additionally, users will likely
want to continue using <code>.readOnly()</code> up until overriding has been fully removed
to ensure they are using properties safely. With that in mind, the ordering of
events should be:</p>
<ol>
<li>Ember v3</li>
</ol>
<ul>
<li>Deprecate the default override-setter behavior immediately. This means that
a deprecation warning will be thrown if a user attempts to set a
non-<code>readOnly</code> property which does not have a setter. User's will still be
able to declare a property is <code>readOnly</code> without a deprecation warning.</li>
<li>Add optional feature to change the deprecation to an assertion after the
deprecation has been released, and to show a deprecation when using
the <code>.readOnly()</code> modifier.</li>
<li>After the deprecation and optional feature have been available for a
reasonable amount of time, enable the optional feature by default in new
apps and addons. The main reason we want to delay this is to give <em>addons</em>
a chance to address deprecations, since enabling this feature will affect
both apps and the addons they consume.</li>
</ul>
<ol start="2">
<li>Ember v4</li>
</ol>
<ul>
<li>Remove the override-setter entirely, making non-overrideable properties the
default.</li>
<li>Make the <code>readOnly</code> modifier a no-op, and show a deprecation warning when it
is used.</li>
</ul>
<p>The warnings should explain the deprecation, and recommend that users do not
rely on setter behavior or opting-in to read only behavior.</p>
<a class="header" href="print.html#how-we-teach-this" id="how-we-teach-this"><h1>How We Teach This</h1></a>
<p>In general, we can teach that computed properties are essentially cached native
getters/setters (with a few more bells and whistles). Once we have official
decorators in the framework, we can make this connection even more solid.</p>
<p>We should add notes on overridability, and we should scrub the guides of any
examples that make use of overriding directly and indirectly via <code>.readOnly()</code>.</p>
<a class="header" href="print.html#drawbacks" id="drawbacks"><h1>Drawbacks</h1></a>
<p>Overriding is not a completely uncommonly used feature, and developers who have
become used to it may feel like it makes their code more complicated, especially
without any easy way to opt back in.</p>
<a class="header" href="print.html#alternatives" id="alternatives"><h1>Alternatives</h1></a>
<p>We could convert <code>.readOnly()</code> into <code>.overridable()</code>, forcing users to opt-in
to overriding. Given the long timeline of this deprecation, it would likely be
better to work on making getters/setters transparent to decoration, and provide
a <code>@overridable</code> decorator either in Ember or as an independent package.</p>
<ul>
<li>Start Date: 2019-09-13</li>
<li>RFC PR: (leave this empty)</li>
<li>Ember Issue: (leave this empty)</li>
</ul>
<a class="header" href="print.html#summary-1" id="summary-1"><h1>Summary</h1></a>
<p>Deprecate the computed <code>.property()</code> modifier which can be used to add dependent
keys to computed properties.</p>
<a class="header" href="print.html#motivation-1" id="motivation-1"><h1>Motivation</h1></a>
<p>Currently, computed properties can use the <code>.property</code> modifier to add dependent
keys to a computed <em>after</em> the computed has been declared:</p>
<pre><code class="language-js">foo: computed('strings', {
  get() {
    return this.strings.filter(s =&gt; s.includes(this.filterText));
  }
}).property('filterText')
</code></pre>
<p>In most cases, this ability is redundant, since the dependent keys can be moved
into the original computed declaration and be equivalent:</p>
<pre><code class="language-js">foo: computed('strings', 'filterText', {
  get() {
    return this.strings.filter(s =&gt; s.includes(this.filterText));
  }
})
</code></pre>
<p>The one exception is in the case of computed <em>macros</em>, specifically macros which
accept a <em>function</em> such as <code>filter()</code> and <code>map()</code>:</p>
<pre><code class="language-js">foo: filter('strings', function(s) {
  return s.includes(this.filterText);
}).property('filterText')
</code></pre>
<p>The issue stems from the fact that the inner function can access the class
instance and use dynamic properties from it, and this access is opaque to the
macro.</p>
<p>This API is confusing since it bears a strong resemblance to the older style
of computed property declarations, and at first glance appears to be invalid.
The few edge-case macros where it does legitimately apply can be rewritten to
accept more dependent keys, making it fully redundant.</p>
<a class="header" href="print.html#transition-path-1" id="transition-path-1"><h1>Transition Path</h1></a>
<p>As mentioned above, macros which receive a callback function as an argument are
the only valid use of <code>.property()</code> in current Ember. Currently, there are two
such macros in Ember core: <code>map</code> and <code>filter</code>.</p>
<p>This RFC proposes that these macros be updated to receive additional dependent
keys via their public API directly via an optional second parameter which is an
array of the keys:</p>
<pre><code class="language-ts">function filter(filteredPropertyKey: string, callback: Function): ComputedProperty;
function filter(
  filteredPropertyKey: string,
  additionalDependentKeys: string[],
  callback: Function
): ComputedProperty;

function map(mappedPropertyKey: string, callback: Function): ComputedProperty;
function map(
  mappedPropertyKey: string,
  additionalDependentKeys: string[],
  callback: Function
): ComputedProperty;
</code></pre>
<a class="header" href="print.html#deprecation-timeline-1" id="deprecation-timeline-1"><h2>Deprecation Timeline</h2></a>
<p>The deprecation should follow these steps:</p>
<ul>
<li>Update <code>filter</code> and <code>map</code> to their new APIs</li>
<li>Add a deprecation warning to uses of <code>.property</code> which add dependent keys to
computed properties.</li>
<li>Add an optional feature to turn the deprecation into an assertion</li>
<li>After enough time has passed for addons and users to update, enable the
optional feature by default in new addons and apps</li>
<li>Fully remove <code>.property()</code> in Ember v4.0.0</li>
</ul>
<a class="header" href="print.html#how-we-teach-this-1" id="how-we-teach-this-1"><h1>How We Teach This</h1></a>
<p>In most cases, we shouldn't have to teach anything. There are already linting
rules prohibiting <code>.property()</code> usage, and the recommended path is to provide
all dependent keys in the original declaration of the computed property. For
users of <code>map</code> and <code>filter</code> we should ensure that they new documentation is
clear on how to add dependent keys to either macro.</p>
<p>For addon authors that have created their own macros which rely on callbacks and
have similar issues, we should demonstrate how they can structure their macro
API to accept additional dependent keys.</p>
<a class="header" href="print.html#drawbacks-1" id="drawbacks-1"><h1>Drawbacks</h1></a>
<p>The new proposed APIs for <code>filter</code> and <code>map</code> may be somewhat confusing, since
only the first argument will be filtered/mapped</p>
<a class="header" href="print.html#alternatives-1" id="alternatives-1"><h1>Alternatives</h1></a>
<p>We could allow additional dependent keys to be passed via an options argument:</p>
<pre><code class="language-ts">filter(dependentKey: string, options: {
  additionalDependentKeys: [],
  callback: Function,
}): ComputedProperty;

map(dependentKey: string, options: {
  additionalDependentKeys: [],
  callback: Function,
}): ComputedProperty;
</code></pre>
<p>This is more verbose, but would be very clear.</p>
<ul>
<li>Start Date: 2014-08-14</li>
<li>RFC PR: https://github.com/emberjs/rfcs/pull/1</li>
<li>Ember Issue: https://github.com/emberjs/data/pull/4086</li>
</ul>
<a class="header" href="print.html#summary-2" id="summary-2"><h1>Summary</h1></a>
<p>For Ember Data. Pass through attribute meta data, which includes <code>parentType</code>, <code>options</code>, <code>name</code>, etc.,
to the transform associated with that attribute. This will allow provide the following function signiture updates to <code>DS.Transform</code>:</p>
<ul>
<li><code>transform.serialize(deserialized, attributeMeta)</code></li>
<li><code>transform.deserialize(serialized, attributeMeta)</code></li>
</ul>
<a class="header" href="print.html#motivation-2" id="motivation-2"><h1>Motivation</h1></a>
<p>The main use case is to be able to configure the transform
on a per-model basis making more DRY code. So the transform can be aware of type and options on <code>DS.attr</code> can
be useful to configure the transform for DRY use.</p>
<a class="header" href="print.html#detailed-design" id="detailed-design"><h1>Detailed design</h1></a>
<a class="header" href="print.html#implementing" id="implementing"><h2>Implementing</h2></a>
<p>The change will most likely start in <a href="https://github.com/emberjs/data/blob/master/packages/ember-data/lib/system/model/attributes.js#L193"><code>eachTransformedAttribute</code></a>, which gets the attributes for that instance via <code>get(this, 'attributes')</code>. In the <code>forEach</code> the <code>name</code> will be used to get the specific attribute, e.g.</p>
<pre><code class="language-js">var attributeMeta = attributes.get(name);
callback.call(binding, name, type, attributeMeta);
</code></pre>
<p>The next change will be in <a href="https://github.com/emberjs/data/blob/master/packages/ember-data/lib/serializers/json_serializer.js#L117"><code>applyTransforms</code></a>, where the <code>attributeMeta</code> parameter is added and passed to <code>transform.deserialize</code> as the second argument.</p>
<p>You also have to handle the serialization part in <a href="https://github.com/emberjs/data/blob/master/packages/ember-data/lib/serializers/json_serializer.js#L528"><code>serializeAttribute</code></a>, where you pass through the <code>attribute</code> parameter to <code>transform.serialize</code>.</p>
<a class="header" href="print.html#using" id="using"><h2>Using</h2></a>
<p>A convoluted example:</p>
<pre><code class="language-js">// Example based on https://github.com/chjj/marked library
App.PostModel = DS.Model.extend({
  title: DS.attr('string'),
  markdown: DS.attr('markdown', {
    markdown: {
      gfm: false,
      sanitize: true
    }
  })
});

App.TechnicalPostModel = DS.Model.extend({
  title: DS.attr('string'),
  gistUrl: DS.attr('string'),
  markdown: DS.attr('markdown', {
    markdown: {
      gfm: true,
      tables: true,
      sanitize: false
    }
  })
});

App.MarkdownTransform = DS.Transform.extend({
  serialize: function (deserialized, attributeMeta) {
    return deserialized.raw;
  },
  
  deserialize: function (serialized, attributeMeta) {
    var options = attributeMeta.options.markdown || {};
    
    return marked(serialized, options);
  }
});
</code></pre>
<a class="header" href="print.html#drawbacks-2" id="drawbacks-2"><h1>Drawbacks</h1></a>
<p>Extra API surface area, although not much. This could also potentially introduce tight coupling between models and transforms if used improperly, e.g. not returning a default value if using type checking.</p>
<a class="header" href="print.html#alternatives-2" id="alternatives-2"><h1>Alternatives</h1></a>
<ol>
<li>Passing the information from the server, which is a poor solution.</li>
<li>Writing a new transform for each model/attribute that needs a variation. Although this might be a good solution sometimes if you extend a base transform.</li>
</ol>
<a class="header" href="print.html#unresolved-questions" id="unresolved-questions"><h1>Unresolved questions</h1></a>
<p>Does the whole meta object need to be passed, or do we selectively pass in only the useful properties? Like
<code>options</code> and <code>parentType</code> and <code>name</code>..</p>
<ul>
<li>Start Date: 2014-08-18</li>
<li>RFC PR: https://github.com/emberjs/rfcs/pull/3</li>
<li>Issues:
<ul>
<li>Ember Stream support: emberjs/ember.js#5522</li>
<li>Handlebars parser support: wycats/handlebars.js#906</li>
<li>HTMLBars compiler support: tildeio/htmlbars#147</li>
</ul>
</li>
</ul>
<a class="header" href="print.html#summary-3" id="summary-3"><h1>Summary</h1></a>
<p>Introduce block parameters to the Handlebars language to standardize context-preserving helpers, for example:</p>
<pre><code class="language-handlebars">{{#each people as |person|}}
  {{person.name}}
{{/each}}
</code></pre>
<a class="header" href="print.html#motivation-3" id="motivation-3"><h1>Motivation</h1></a>
<a class="header" href="print.html#the-problem" id="the-problem"><h3>The Problem</h3></a>
<p>There is no idiomatic way to write a helper that preserves context and yields values to its template. This is particularly painful for components which have strict context-preserving semantics.</p>
<a class="header" href="print.html#current-workarounds" id="current-workarounds"><h3>Current workarounds</h3></a>
<ul>
<li>Don't write components that need to yield a value.
<ul>
<li><em>Problem:</em> This may not be an option.</li>
</ul>
</li>
<li>Invent a non-standard per-helper syntax (like <code>{{#with foo as bar}}</code> or <code>{{#each item in items}}</code>) that hook into the undocumented <code>keywords</code> to inject variables.
<ul>
<li><em>Problems:</em> Custom syntaxes are not in the spirit of the Handlebars language and require the consumer to know the special incantation. Component authors must an non-trivial understanding of how <code>keywords</code> work.</li>
</ul>
</li>
</ul>
<a class="header" href="print.html#new-possibilities" id="new-possibilities"><h3>New possibilities</h3></a>
<pre><code class="language-handlebars">{{#for-each obj as |key val|}}
  {{key}}: {{val}}
{{/for-each}}
</code></pre>
<pre><code class="language-handlebars">{{#form-for post as |f|}}
  {{f.input &quot;title&quot;}}
  {{f.textarea &quot;body&quot;}}
  {{f.submit}}
{{/form-for}}
</code></pre>
<a class="header" href="print.html#detailed-design-1" id="detailed-design-1"><h1>Detailed design</h1></a>
<ul>
<li>Phase 1: Add block params to the Handlebars language</li>
<li>Phase 2: Rewrite Ember's helpers to accept streams</li>
<li>Phase 3: Add block param support to <code>{{each}}</code> and <code>{{with}}</code></li>
</ul>
<a class="header" href="print.html#phase-1-add-block-params-to-the-handlebars-language" id="phase-1-add-block-params-to-the-handlebars-language"><h3>Phase 1: Add block params to the Handlebars language</h3></a>
<p>The proposed syntax is <code>{{#x-foo a b w=x y=z as |param1 param2 ... paramN|}}</code> and is only available for block helpers.</p>
<p>The names of the block parameters are compiled into the inner template, but are not known to the helper (<code>x-foo</code> in the example above). To call a template and populate its block params we use the arguments option:</p>
<pre><code class="language-javascript">var template = compile('{{person.name}}', {
  blockParams: [ 'person' ]
});

template({}, ..., [ personModel ]);
</code></pre>
<p>More commonly, block params will be defined inside of the template.</p>
<pre><code>{{#with currentPost.author as |a|}}
  {{a.name}} &lt;em&gt;{{a.email}}&lt;/em&gt;
{{/with}}
</code></pre>
<pre><code class="language-javascript">registerHelper('with', function(object, options) {
  return options.fn(this, ..., [ object ]);
});
</code></pre>
<p>For compatibility reasons, the <em>number of block params</em> are passed to the helper so that the pre-block-params behaviour of the helper can be preserved. Example:</p>
<pre><code class="language-javascript">function eachHelper(..., options) {
  if (options.blockParamsLength &gt; 0) { /* do new behaviour */ }
  else { /* do old behaviour */ }
}
</code></pre>
<a class="header" href="print.html#phase-2-rewrite-embers-helpers-to-accept-streams" id="phase-2-rewrite-embers-helpers-to-accept-streams"><h3>Phase 2: Rewrite Ember's helpers to accept streams</h3></a>
<p>In the <code>with</code> example above, if the <code>currentPost</code> changes the <code>a</code> block param should update. This means it's not sufficient to pass only the initial value of the author in the arguments. Instead, we pass a stream which emits values whenever the observed property changes.</p>
<p>In Handlebars, a block param can appear anywhere that an identifier can, for example <code>{{log a.name}}</code>. This means that all helpers would need to be modified to understand streams.</p>
<a class="header" href="print.html#phase-3-add-block-param-support-to-each-and-with" id="phase-3-add-block-param-support-to-each-and-with"><h3>Phase 3: Add block param support to <code>{{each}}</code> and <code>{{with}}</code></h3></a>
<p>Deprecate context-changing and ad-hoc keyword flavors of <code>{{each}}</code> and <code>{{with}}</code> in favor of block params.</p>
<a class="header" href="print.html#drawbacks-3" id="drawbacks-3"><h1>Drawbacks</h1></a>
<ul>
<li>Handlebars already has a similar notion of with <code>data</code> which can lead to confusion.</li>
</ul>
<a class="header" href="print.html#alternatives-3" id="alternatives-3"><h1>Alternatives</h1></a>
<p>To my knowledge, no other designs have been considered. Not implementing this feature would mean that components would continue to be difficult to compose.</p>
<a class="header" href="print.html#unresolved-questions-1" id="unresolved-questions-1"><h1>Unresolved questions</h1></a>
<p>The associated HTML syntax for HTMLBars needs to be finalized.</p>
<ul>
<li>Start Date: 2014-10-24</li>
<li>RFC PR: https://github.com/emberjs/rfcs/pull/10</li>
<li>Ember Issue: https://github.com/emberjs/ember.js/pull/12685</li>
</ul>
<a class="header" href="print.html#summary-4" id="summary-4"><h1>Summary</h1></a>
<p>Engines allow multiple logical applications to be composed together into a
single application from the user's perspective.</p>
<a class="header" href="print.html#motivation-4" id="motivation-4"><h1>Motivation</h1></a>
<p>Large companies are increasingly adopting Ember.js to power their entire
product lines. Often this means separate teams (sometimes distributed
around the world) working on the same app. Typically, responsibility is
shared by dividing the application into one or more &quot;sections&quot;. How this
division is actually implemented varies from team to team.</p>
<p>Sometimes, each &quot;section&quot; will be a completely separate Ember app, with
a shared navigation bar allowing users to switch between each app. This
allows teams to work quickly without stepping on each others' toes, but
switching apps feels slow (especially compared to the normally speedy
route transitions in Ember) because the entire page must be thrown out,
then an entirely new set of the same assets downloaded and parsed.
Additionally, code sharing is largely accomplished via copy-and-paste.</p>
<p>Other times, the separation is enforced socially, with each team
claiming a section of the same app in the same repository.
Unfortunately, this approach leads to frequent conflicts around shared
resources, and feedback from tests gets slower and slower as test suites
grow in size.</p>
<p>A more modular approach is to break off elements of a single application into
separate <a href="http://www.ember-cli.com/user-guide/#addons">addons</a>. Addons are
essentially mixins for <a href="http://www.ember-cli.com/">ember-cli</a> applications. In
other words, the elements of an addon are merged with those of the application
that includes them. While addons allow for distributed development, testing, and
packaging, they do not provide the logical run-time separation required for
developing completely independent &quot;sections&quot; of an application. Addons must
function within the namespace, registry, and router of the application in which
they are included.</p>
<p>Engines provide an alternative to these approaches that allows for distributed
development, testing, and packaging, <em>as well as</em> logical run-time separation.
Because engines are derived from applications, they can be just as
full-featured. Each has its own namespace and registry. Even though engines are
isolated from the applications that contain them, the boundaries between them
allow for controlled sharing of resources.</p>
<p>Engines can be either &quot;routable&quot; or &quot;route-less&quot;:</p>
<ul>
<li>
<p>Routable engines provide a routing map which can be integrated with the
routing maps of parent applications or engines. Routing maps are always eager
loaded, which allows for deep linking into an engine's routes regardless of
whether the engine itself has been instantiated.</p>
</li>
<li>
<p>Route-less engines can isolate complex functionality that is not related to
routing (e.g. a chat engine in a sidebar). Route-less engines can be rendered
into outlets ad hoc as routes are loaded.</p>
</li>
</ul>
<p>The potential scope of engines is large enough that this feature merits
development and delivery in multiple phases. A minimum viable version could be
released sooner, which could be augmented with more advanced features later.</p>
<p>An initial release of engines could provide the following benefits:</p>
<ul>
<li>
<p>Distributed development - Engines can be developed and tested in isolation
within their own Ember CLI projects and included by applications or other
engines. Engines can be packaged and released as addons themselves.</p>
</li>
<li>
<p>Integrated routing - Support for mounting routable engines in the routing maps
of applications or other engines.</p>
</li>
<li>
<p>Ad hoc embedding - Support for embedding route-less engines in outlets as
needed.</p>
</li>
<li>
<p>Clean boundaries - An engine can cooperate with its parents through a few
explicit interfaces. Beyond these interfaces, engines and applications are
isolated.</p>
</li>
</ul>
<p>Subsequent releases of engines could allow for the following:</p>
<ul>
<li>
<p>Lazy loading - An engine could allow its parent to boot with only its routing
map loaded. The rest of the engine could be loaded only as required (i.e.
when a route in an engine is visited). This would allow applications to boot
faster and limit their memory consumption.</p>
</li>
<li>
<p>Namespaced access to engine resources from applications - This could open up
the potential for applications to use, and extend, an engine's resources much
like resources in other addons, but without the possibility of namespace
collisions.</p>
</li>
</ul>
<a class="header" href="print.html#detailed-design-2" id="detailed-design-2"><h2>Detailed design</h2></a>
<p>Engines are very similar to regular applications: they can be developed in
isolation in Ember CLI, include addons, and contain all the same elements,
including routes, components, initializers, etc. The primary differences are
that an engine does not boot itself and an engine does not control the router.</p>
<a class="header" href="print.html#engine-internals" id="engine-internals"><h3>Engine internals</h3></a>
<p>New <code>Engine</code> and <code>EngineInstance</code> classes will be introduced.</p>
<p>Applications and engines will share ancestry. It remains TBD whether
applications will subclass engines, or whether a common ancestor will be
introduced.</p>
<p>Engines and applications will share the same pattern for registry / container
ownership and encapsulation. Both will also have initializers and instance
initializers.</p>
<p>Engine instances will have access to their parent instances. An engine's parent
could be either an application or engine.</p>
<a class="header" href="print.html#routable-vs-route-less-engines" id="routable-vs-route-less-engines"><h4>Routable vs. route-less engines</h4></a>
<p>Routable engines will define their routes in a new <code>Ember.Routes</code> class. This
class will encapsulate the functionality provided by <code>Router#map</code>, and will be
used internally by <code>Ember.Router</code> as well (with no public interface changes of
course).</p>
<p>Route-less engines do not define routing maps nor can they contain routes.</p>
<a class="header" href="print.html#developing-engines" id="developing-engines"><h3>Developing engines</h3></a>
<p>Engines can be developed in isolation as Ember CLI addon projects or as part of
a parent application.</p>
<a class="header" href="print.html#engines-as-addons" id="engines-as-addons"><h4>Engines as addons</h4></a>
<p>Engines can be created as separate addon projects with:</p>
<pre><code>ember engine &lt;engine-name&gt;
</code></pre>
<p>This will create a special form of an ember addon. The file structure will match
that of a standard addon, but will have an <code>engine</code> directory instead of an
<code>addon</code> directory.</p>
<p>Engines can be unit tested and can also be integration tested within a dummy
app, just like standard addons.</p>
<a class="header" href="print.html#in-repo-engines" id="in-repo-engines"><h4>In-repo engines</h4></a>
<p>An engine can be created within an existing application's project using a
special <code>in-repo-engine</code> generator (similar to the <code>in-repo-addon</code> generator):</p>
<pre><code>ember g in-repo-engine &lt;engine-name&gt;
</code></pre>
<p>In-repo engines can be unit tested in isolation or integration testing with the
main application (instead of a dummy application).</p>
<blockquote>
<p>Note: In-repo addons currently are created in the <code>/lib</code> directory (e.g.
<code>/lib/my-addon</code>). Unit tests and integration tests are currently co-mingled with
tests for the main application. It's recommended that in-repo engines provide
better test separation than is provided for regular addons, and perhaps the
whole in-repo addon directory structure should be re-examined at the same time
in-repo engines are introduced.</p>
</blockquote>
<a class="header" href="print.html#engine-directory-structure" id="engine-directory-structure"><h4>Engine directory structure</h4></a>
<p>An engine's directory will contain a file structure identical to the <code>app</code>
directory in a standard ember-cli application, with the following exceptions:</p>
<ul>
<li>
<p><code>engine.js</code> instead of <code>app.js</code> - defines the <code>Engine</code> class and
loads its initializers.</p>
</li>
<li>
<p><code>routes.js</code> instead of <code>router.js</code> - defines an engine's routing map in a
<code>Routes</code> class. This file should be deleted entirely for route-less engines.</p>
</li>
</ul>
<a class="header" href="print.html#installing-engines" id="installing-engines"><h3>Installing engines</h3></a>
<p>Engines developed as addons can be installed in an application just like any
other addon:</p>
<pre><code>ember install &lt;engine-name&gt;
</code></pre>
<p>During development, you can use <code>npm link</code> to make your engine available in
another parent engine or application.</p>
<a class="header" href="print.html#mounting-routable-engines" id="mounting-routable-engines"><h3>Mounting routable engines</h3></a>
<p>The new <code>mount()</code> router DSL method is used to mount an engine at a particular
&quot;mount-point&quot; in a route map.</p>
<p>For example, the following route map mounts the <code>discourse</code> engine at the
<code>/forum</code> path:</p>
<pre><code>Router.map(function() {
  this.mount('discourse', {path: '/forum'});
});
</code></pre>
<blockquote>
<p>Note: If unspecified, <code>path</code> will match the name of the engine.</p>
</blockquote>
<p>Calls to <code>mount</code> can be nested within routes. An engine can be mounted at
multiple routes, and each will represent a new instance of the engine to be
created.</p>
<a class="header" href="print.html#mounting-route-less-engines" id="mounting-route-less-engines"><h3>Mounting route-less engines</h3></a>
<p>A <code>mount()</code> DSL will also be added to routes, which will enable embedding of
route-less engines in outlets. This can be called from <code>renderTemplate</code> (or
<code>renderComponents</code> once routable components are introduced).</p>
<p><code>mount</code> has a similar signature to <code>render</code>, although it is obviously
engine-specific instead of template-specific. <code>mount</code> can be used to specify
a target template and outlet as follows:</p>
<pre><code>renderTemplate: function() {
  // Mount the chat engine in the sidebar
  this.mount('chat', {
    into: 'main',
    outlet: 'sidebar'
  });
}
</code></pre>
<p>As a result, the engine's <code>application</code> template will be rendered into the
<code>sidebar</code> outlet in the application's <code>main</code> template.</p>
<a class="header" href="print.html#loading-phases" id="loading-phases"><h3>Loading phases</h3></a>
<p>Engines can exist in several phases:</p>
<ul>
<li>
<p>Booted - an engine that's been installed in a parent application will have
its dependencies loaded and its (non-instance) initializers invoked when the
parent application boots.</p>
</li>
<li>
<p>Mounted - Routable and route-less engines have slightly different concepts of
&quot;mounting&quot;. A routable engine is considered mounted when it has been included
by a router at one or more mount-points. A route-less engine is considered
mounted as soon as a route's <code>mount</code> call resolves.</p>
</li>
<li>
<p>Instantiated - When an engine is instantiated, an <code>EngineInstance</code> is created
and an engine's instance initializers are invoked. A routable engine is
instantiated when a route is visited at or beyond its mount-point. A
route-less engine is instantiated as soon as it is mounted.</p>
</li>
</ul>
<p>Special <code>before</code> and <code>after</code> hooks could be added to application instance
initializers that allow them to be ordered relative to engine instance
initializers.</p>
<a class="header" href="print.html#engine-boundaries" id="engine-boundaries"><h3>Engine boundaries</h3></a>
<p>Besides its routing map, an engine does not share any other resources with its
parent by default. Engines maintain their own registries and containers, which
ensure that they stay isolated. However, some explicit sharing of resources
between engines and parents is allowed.</p>
<a class="header" href="print.html#engine--parent-dependencies" id="engine--parent-dependencies"><h4>Engine / parent dependencies</h4></a>
<p>Dependencies between engines and parents can be defined imperatively or
declaratively.</p>
<p>Imperative dependencies can be defined in an engine's instance initializers.
When an engine is instantiated, the <code>parent</code> property on its <code>EngineInstance</code> is
set to its parent instance (either an <code>ApplicationInstance</code> or
<code>EngineInstance</code>). Since the engine instance is available in the instance
initializer, this <code>parent</code> property can also be accessed. This allows an engine
instance to interrogate its parent, specifically through its <code>RegistryProxy</code> and
<code>ContainerProxy</code> interfaces.</p>
<p>Alternatively, declarative dependencies can be defined on a limited basis. The
initial API will be limited: an engine can define an array of <code>services</code> that it
requires from its parent.</p>
<p>For example, the following engine expects its parent to provide <code>store</code> and
<code>session</code> services:</p>
<pre><code>import Ember from 'ember';

var Engine = Ember.Engine.extend({
  dependencies: {
    services: [
      'store',
      'session'
    ]
  }
});

export default Engine;
</code></pre>
<p>The parent application can provide a re-mapping of services from its namespace
to that of the engine via an <code>engines</code> declaration.</p>
<p>In the following example, the application shares its <code>store</code> service directly
with the <code>checkout</code> engine. It also shares its <code>current-user</code> service as the
<code>session</code> service requested by the engine.</p>
<pre><code>import Ember from 'ember';

var App = Ember.Application.extend({
  engines: {
    checkout: {
      dependencies: {
        services: [
          'store',
          {session: 'current-user'}
        ]
      }
    }
  }
});

export default App;
</code></pre>
<p>When engines are instantiated, the listed dependencies will be looked up on
the parent and made accessible within the engine.</p>
<p>Note that the <code>engines</code> declaration provides further space to define
characteristics about an engine, such as whether it should be eager or
lazy-loaded, URLs for manifest files, etc.</p>
<a class="header" href="print.html#drawbacks-4" id="drawbacks-4"><h1>Drawbacks</h1></a>
<p>This RFC introduces the new concept of engines, which increases the
learning curve of the framework. However, I believe this issue is
mitigated by the fact that engines are an opt-in packaging around
existing concepts.</p>
<p>In the end, I believe that &quot;engines&quot; are just a small API for composing
existing concepts. And they can be introduced at the top of the
conceptual ladder, once users are comfortable with the basics of Ember,
and only for those working on large teams or distributing addons.</p>
<a class="header" href="print.html#alternatives-4" id="alternatives-4"><h1>Alternatives</h1></a>
<p>Several incomplete alternatives are discussed in the Motivations section above.</p>
<p>I know of no alternatives being discussed in the Ember community that meet the
same needs as engines; namely, for development <em>and</em> run-time isolation.</p>
<a class="header" href="print.html#unresolved-questions-2" id="unresolved-questions-2"><h1>Unresolved questions</h1></a>
<a class="header" href="print.html#non-cli-users" id="non-cli-users"><h2>Non-CLI Users</h2></a>
<p>This RFC assumes Ember CLI. I would prefer to prove this out in Ember
CLI before locking down the public APIs/hooks the router exposes for
locating and mounting engines. Once this is done, however, we should
expose and document those hooks so users who cannot use Ember CLI for
whatever reason can still take advantage of composability.</p>
<a class="header" href="print.html#declarative-dependencies" id="declarative-dependencies"><h2>Declarative dependencies</h2></a>
<p>The initial scope of declarative dependency sharing is limited in scope to
services. Should other types of dependencies be declaratively shareable?
Should addons be the recommended path to share all other dependencies?</p>
<a class="header" href="print.html#async-mounting-of-route-less-engines" id="async-mounting-of-route-less-engines"><h2>Async mounting of route-less engines</h2></a>
<p><code>Route#renderTemplate</code> is called synchronously, although <code>Route#mount</code> should
surely be async. How async mounting is represented in the route lifecycle is
TBD. A solution isn't proposed here because the problem is shared by routable
and async components, and a common solution should be reached.</p>
<a class="header" href="print.html#lazy-loading-manifests" id="lazy-loading-manifests"><h2>Lazy loading manifests</h2></a>
<p>In order to facilitate lazy loading of engines, we will need to determine a
structure for manifest files that contain an engine's assets. Furthermore, an
application will need to be configurable with URLs for these manifests.</p>
<p>It's likely that an engine's routing map will always be needed at the time of
application deployment. Allowing lazy loading of routing maps would prevent the
formation of any links from a parent application into an engine's routes.</p>
<p>When developed in isolation as addons, engines will have their own sets of
dependencies. These dependencies will be treated like any other addons when
engines are deployed together with an application. However, in order to support
lazy loading, it would be ideal to dedupe dependencies in order to create a lean
and conflict-free asset manifest.</p>
<p>Reference: deduping strategy discussed by @wycats in
<a href="https://docs.google.com/a/tomdale.net/document/d/12CsR-zli5oP2TDWOef_-D28zjmbVD83hU4q9_VTk-9s/edit">this Google doc</a>.</p>
<a class="header" href="print.html#namespaced-access-to-engine-resources" id="namespaced-access-to-engine-resources"><h2>Namespaced access to engine resources</h2></a>
<p>The concept of namespaced access to engine resources is mentioned above as a
potential goal of a future release of engines. This will require further
discussion to decide how it should work both technically and semantically, and
how it applies to lazy-loaded engines.</p>
<p>If these problems can be resolved, this feature would allow for more flexibility
in parent / engine interactions. Instead of just allowing engines to look up
resources in a parent, the inverse could also be allowed.</p>
<p>For example, if the <code>authentication</code> engine contains
<code>engines/authentication/models/user.js</code>, a parent application could look up this
same model through a namespace. Perhaps as follows:</p>
<pre><code class="language-js">container.lookup('authentication@model:user');
</code></pre>
<p>Other APIs in Ember would need to be extended to support namespaces to
take full advantage of this feature. For example, components that ship
with an engine might be accessed from the primary application like this:</p>
<pre><code class="language-handlebars">{{authentication@login-form obscure-password=true}}
</code></pre>
<ul>
<li>Start Date: 2014-09-30</li>
<li>RFC PR: https://github.com/emberjs/rfcs/pull/11</li>
<li>Ember Issue: https://github.com/emberjs/ember.js/pull/9527</li>
</ul>
<a class="header" href="print.html#summary-5" id="summary-5"><h1>Summary</h1></a>
<p>Improve computed property syntax</p>
<a class="header" href="print.html#motivation-5" id="motivation-5"><h1>Motivation</h1></a>
<p>Today, the setter variant of CP's is both confusing, and looks scary as sin.
(Too many concepts must be taught and it is too easy to screw it up.)</p>
<a class="header" href="print.html#detailed-design-3" id="detailed-design-3"><h1>Detailed design</h1></a>
<a class="header" href="print.html#today" id="today"><h2>today:</h2></a>
<pre><code class="language-js">fullName: Ember.computed('firstName', 'lastName', function(key, value) {
  if (arguments.length &gt; 1) {
    var names = value.split(' ');
    this.setProperties({
      firstName: names[0],
      lastName: names[1]
    });
    return value;
  }

  return this.get('firstName') + ' ' + this.get('lastName');
});
</code></pre>
<a class="header" href="print.html#tomorrow" id="tomorrow"><h2>Tomorrow:</h2></a>
<pre><code class="language-js">fullName: Ember.computed('firstName', 'lastName', {
  get: function(keyName) {
    return this.get('firstName') + ' ' + this.get('lastName');
  },

  set: function(keyName, fullName, oldValue) {
   var names = fullName.split(' ');

   this.setProperties({
     firstName: names[0],
     lastName: names[1]
   });

   return fullName;
  }
});
</code></pre>
<a class="header" href="print.html#notes" id="notes"><h2>Notes:</h2></a>
<ul>
<li>we should keep <code>Ember.computed(fn);</code>  as shorthand for getter only</li>
<li><code>get</code> xor <code>set</code> variants would also be possible.</li>
<li><code>{ get() { } }</code> is es6 syntax for <code>{ get: function() { } )</code></li>
</ul>
<a class="header" href="print.html#migration" id="migration"><h2>Migration</h2></a>
<ul>
<li>1.x support both, detect new behaviour by testing if the last arg is not null and typeof object</li>
<li>1.x+1 deprecate if last arg is a function and its arity is greater than 1</li>
</ul>
<a class="header" href="print.html#drawbacks-5" id="drawbacks-5"><h1>Drawbacks</h1></a>
<p>N/A</p>
<a class="header" href="print.html#alternatives-5" id="alternatives-5"><h1>Alternatives</h1></a>
<p>N/A</p>
<a class="header" href="print.html#unresolved-questions-3" id="unresolved-questions-3"><h1>Unresolved questions</h1></a>
<p>None</p>
<ul>
<li>Start Date: 2014-12-03</li>
<li>RFC PR: https://github.com/emberjs/rfcs/pull/15</li>
<li>Ember Issue: This RFC is implemented over many Ember PRs</li>
</ul>
<a class="header" href="print.html#the-road-to-ember-20" id="the-road-to-ember-20"><h1>The Road to Ember 2.0</h1></a>
<a class="header" href="print.html#intro" id="intro"><h2>Intro</h2></a>
<p>Today, we're announcing our plan for Ember 2.0. While the major version
bump gives us the opportunity to simplify the framework in ways that
require breaking changes, we are designing Ember 2.0 with migration in mind.</p>
<p>This is <strong>not</strong> a big-bang rewrite; we will continue development
on the <code>master</code> branch, and roll out changes incrementally on the 1.x
release train. The 2.0.0 release will simply remove features that have
been deprecated between now and then. Our goal is that you can move
your Ember app to 2.0 incrementally, one sprint at a time.</p>
<p>This RFC captures the results of the last two core team face-to-face
meetings, where we discussed community feedback about the future of the
project. While it explains the high-level goals and tries to paint a
picture of how all the pieces fit together, this document will be
updated over time with links to individual RFCs that contain additional
implementation detail.</p>
<p>We plan to flesh out these more-detailed RFCs in the next few weeks,
as the discussion here progresses, before finalizing this plan.</p>
<p>We are announcing Ember 2.0 through our community RFC process in advance
of a release, both so our proposals can be vetted by the community and
so the community can understand the goals and contribute their own ideas
back.</p>
<a class="header" href="print.html#motivation-6" id="motivation-6"><h2>Motivation</h2></a>
<a class="header" href="print.html#stability-without-stagnation" id="stability-without-stagnation"><h3>Stability without Stagnation</h3></a>
<p>Ember is all about identifying common patterns that emerge from the web
development community and rolling them into a complete front-end stack.
This makes it easy to get started on new projects and jump into existing
ones, knowing that you will get a best-of-breed set of tools that the
community will continue to support and improve for years to come.</p>
<p>In the greater JavaScript community, getting the latest and greatest
often means rewriting parts of your apps once a year, as the community
abandons existing solutions in search of improvements. Progress is
important, but so is ending the constant cycle of writing and rewriting
that plagues so many applications.</p>
<p>The Ember community works hard to introduce new ideas with an eye
towards migration. We call this &quot;stability without stagnation&quot;, and it's
one of the cornerstones of the Ember philosophy.</p>
<p>Below, we introduce some of the major new features coming in Ember
2.0. Each section includes a transition plan, with details on how
we expect existing apps to migrate to the new API.</p>
<p>When breaking changes are absolutely necessary, we try to make those
changes ones you can apply without too much thought. We call these
&quot;mechanical&quot; refactors. Typically, they'll involve a change to
syntax without changing semantics. These are significantly easier to
adopt than those that require fundamental changes to your application
architecture.</p>
<p><strong>To further aid in these transitions, we are planning to add a new tab to the
Ember Inspector that will list all deprecations in your application</strong>,
as well as a list of the locations in the source code where the
deprecated code was triggered. This should serve as a convenient
&quot;punch list&quot; for your transitional work.</p>
<p>Every member of the core team works on up-to-date Ember applications,
and we feel the tension between stability and progress acutely. We want
to deliver cutting-edge products, but need to keep shipping, and many
companies that have adopted Ember for their products tell us the
same thing.</p>
<a class="header" href="print.html#big-bets" id="big-bets"><h3>Big Bets</h3></a>
<p>In 2014, we made big bets in two areas, and they've paid off.</p>
<p>The first bet was on open standards: JavaScript modules, promises and
Web Components. We started the year off with globals-based apps,
callbacks and &quot;views&quot;, and incrementally (and compatibly) built towards
standards-based solutions as those standards solidified.</p>
<p>The second bet was that the community was as tired as we were of
hand-rolling their own build scripts for each project. We've invested
heavily in Ember CLI, giving us a single tool that unifies the community
and provides a venue for disseminating great ideas.</p>
<p><strong>In Ember 2.0, Ember CLI and ES6 modules will become first-class parts
of the Ember experience.</strong> We will update the website, guides, documentation,
etc. to teach new users how to build Ember apps with the CLI tools and
using JavaScript's new module syntax.</p>
<p>While globals-based apps will continue to work in 2.0, we may introduce
new features that rely on either Ember CLI or ES6 modules. <strong>You should
begin moving your app to Ember CLI as soon as possible.</strong></p>
<p>All of the apps maintained by the Ember core team have been migrated to
Ember CLI, and we believe that most teams should be able to make the
transition incrementally.</p>
<a class="header" href="print.html#learning-from-the-community" id="learning-from-the-community"><h3>Learning from the Community</h3></a>
<p>We're well aware that we don't have a monopoly on good ideas, and we're
always analyzing competing frameworks and libraries to discover great
ideas that we can incorporate.</p>
<p>For example, AngularJS taught us the importance of making early on-ramp
easy, how cool directives/components could be, and how dependency
injection improves testing.</p>
<p>We've been analyzing and discussing React's approach to data flow and
rendering for some time now, and in particular how they make use of a
&quot;virtual DOM&quot; to improve performance.</p>
<p>Ember's view layer is one of the oldest parts of Ember, and was designed
for a world where IE7 and IE8 were dominant. We've spent the better part
of 2014 rethinking the view layer to be more DOM-aware, and the new
codebase (codenamed &quot;HTMLBars&quot;) borrows what we think are the
best ideas from React. We cover the specifics below.</p>
<p>React's &quot;virtual DOM&quot; abstraction also allowed them to simplify the
programming model of component-based applications. We really like these
ideas, and the new HTMLBars engine, landing in the next Ember release, lays
the groundwork for adopting the simplified data-flow model.</p>
<p><strong>In Ember 2.0, we will be adopting a &quot;virtual DOM&quot; and data flow model
that embraces the best ideas from React and simplifies communication
between components.</strong></p>
<p>Interestingly, we found that well-written Ember applications are already
written with this clear and direct data flow. This change will mostly
make the best patterns more explicit and easier for developers to find
when starting out.</p>
<a class="header" href="print.html#a-steady-flow-of-improvement" id="a-steady-flow-of-improvement"><h3>A Steady Flow of Improvement</h3></a>
<p>Ember 1.0 shipped over a year ago and we have continued to improve the
framework while maintaining backwards-compatibility. We are proud of the
fact that Ember apps tend to track released versions.</p>
<p>You might expect us to do Ember 2.0 work on a separate &quot;2.0&quot; branch,
accumulating features until we ship. We aren't going to do that.</p>
<p>Instead, <strong>we plan to do the vast majority of new work on <code>master</code> (behind
feature flags), and land new features in 1.x as they become stable.</strong></p>
<p>The <code>2.0.0</code> release <strong>will simply remove the cruft</strong> that naturally
builds up when maintaining compatibility with old releases.</p>
<p>If we add features that change Ember idioms, we will add clear
deprecation warnings with steps to refactor to new patterns.</p>
<p>Our goal is that, as much as possible, people will be able to boot up
their app on the last <code>1.x</code> version, update to the latest set of idioms
by following the deprecation prompts, and have things working on <code>2.0</code>.</p>
<p>Because going from the last version of Ember 1.x to Ember 2.0 will be
just another six-week release, there simply won't be much time for us to
make it an incredibly painful upgrade. ;)</p>
<a class="header" href="print.html#simplifying-ember-concepts" id="simplifying-ember-concepts"><h2>Simplifying Ember Concepts</h2></a>
<p>Ember evolved organically from a view-layer-only framework in 2011 into
the route-driven, complete front-end stack it is today. Along the way,
we've accumulated several concepts that are no longer widely used in idiomatic
Ember apps.</p>
<p>These vestigial concepts make file sizes larger, code more complex, and
make Ember harder to learn.</p>
<p><strong>Ember 2.0 is about simplification</strong>. This lets us reduce file sizes,
reduce code complexity, and generally make Ember apps easier to pick up
and maintain.</p>
<p>The high-level set of improvements that we have planned are:</p>
<ul>
<li>More intuitive attribute bindings</li>
<li>New HTML syntax for components</li>
<li>Block parameters for components</li>
<li>More consistent template scope</li>
<li>One-way data binding by default, with opt-in to mutable, two-way bindings</li>
<li>More explicit communication between components, which means less
implicit communication via two-way bindings</li>
<li>Routes drive components, instead of controller + template</li>
<li>Improved actions that are invoked inside components as simple callbacks</li>
</ul>
<p>In some sections, we provide estimates for when a feature will land.
These are our best-guesses, but because of the rapid-release train model
of Ember, we may be off by a version or two.</p>
<p>However, all features that are slated for &quot;before 2.0&quot; will land before
we cut over to a major new version.</p>
<a class="header" href="print.html#more-intuitive-attribute-bindings" id="more-intuitive-attribute-bindings"><h2>More Intuitive Attribute Bindings</h2></a>
<p>Today's templating engine is the oldest part of Ember.js. Under the
hood, it generates a string of HTML and then inserts it into the page.</p>
<p>One unfortunate consequence of this architecture is that it is not
possible to intuitively bind values to HTML attributes.</p>
<p>You would expect to be able type something like:</p>
<pre><code class="language-handlebars">&lt;a href=&quot;{{url}}&quot;&gt;Click here&lt;/a&gt;
</code></pre>
<p>But instead, in today's Ember, you have to learn about and use the
<code>bind-attr</code> helper:</p>
<pre><code class="language-handlebars">&lt;a {{bind-attr href=url}}&gt;Click here&lt;/a&gt;
</code></pre>
<p>The new HTMLBars template engine makes <code>bind-attr</code> a thing of the past,
allowing you to type what you mean. It also makes it possible to express
many attribute-related concepts simply:</p>
<pre><code class="language-handlebars">&lt;a class=&quot;{{active}} app-link&quot; href=&quot;{{url}}.html&quot;&gt;Click here&lt;/a&gt;
</code></pre>
<a class="header" href="print.html#transition-plan" id="transition-plan"><h3>Transition Plan</h3></a>
<p>The HTMLBars templating engine is being developed on master, and parts
of it have already landed in Ember 1.8. Doing the work this way means
that the new engine continues to support the old syntax: your existing
templates will continue to work.</p>
<p>The improved attribute syntax has not yet landed, but we expect it to
land before Ember 1.10.</p>
<p><strong>We do not plan to remove support for existing templating syntax (or
no-longer-necessary helpers like <code>bind-attr</code>) in Ember 2.0.</strong></p>
<a class="header" href="print.html#more-intuitive-components" id="more-intuitive-components"><h2>More Intuitive Components</h2></a>
<p>In today's Ember, components are represented in your templates as
Handlebars &quot;block helpers&quot;.</p>
<p>The most important problem with this approach is that Handlebars-style
components do not work well with attribute bindings or the <code>action</code>
helper. In short, a helper that is meant to be used inside an HTML tag
cannot be used inside a call to a component.</p>
<p>Beginning in Ember 1.11, we will support an HTML-based syntax for
components. <strong>The new syntax can be used to invoke existing components,
and new components can be called using the old syntax.</strong></p>
<pre><code class="language-handlebars">&lt;my-video src={{movie.url}}&gt;&lt;/my-video&gt;

&lt;!-- equivalent to --&gt;

{{my-video src=movie.url}}
</code></pre>
<a class="header" href="print.html#transition-plan-1" id="transition-plan-1"><h3>Transition Plan</h3></a>
<p>The improved component syntax will (we hope) land in Ember 1.11. You can
transition existing uses of <code>{{component-name}}</code> to the new syntax
at that time. You will likely benefit by eliminating uses of computed
properties that can now be more tersely expressed using the
interpolation syntax.</p>
<p><strong>We have no plans to remove support for the old component syntax in
Ember 2.0.</strong></p>
<a class="header" href="print.html#block-parameters" id="block-parameters"><h2>Block Parameters</h2></a>
<p>In today's templates, there are two special forms of built-in Handlebars
helpers: <code>#each post in posts</code> and <code>#with post as p</code>. These allow the
template inside the helper to retain the parent context, but get a piece
of helper-provided information as a named value (such as <code>post</code> in the previous examples).</p>
<pre><code>{{#with contact.person as p}}
  {{!-- this block of code is still in the parent's scope, but
        the #with helper provided a `p` name with a
        helper-provided value --}}
  &lt;p&gt;{{p.firstName}} {{p.lastName}}&lt;/p&gt;

  {{!-- `title` here refers to the outer scope's title --}}
  &lt;p&gt;{{title}}&lt;/p&gt;
{{/with}}
</code></pre>
<p>Today, this capability is hardcoded into the two special forms,
but it can be useful for other kinds of components. For example,
you may have a calendar component (<code>ui-calendar</code>) that displays a
specified month.</p>
<p>The <code>ui-calendar</code> component may want to allow users to supply a custom
template for each day in the month, but each repetition of the template
will need information about the day it represents (its day of the week,
date number, etc.) in order to render it.</p>
<p>With the new &quot;block parameters&quot; feature, any component will have
access to the same capability as <code>#each</code> or <code>#with</code>:</p>
<pre><code class="language-handlebars">&lt;ui-calendar month={{currentMonth}} as |day|&gt;
  &lt;p class=&quot;title&quot;&gt;{{day.title}}&lt;/p&gt;
  &lt;p class=&quot;date&quot;&gt;{{day.date}}&lt;/p&gt;
&lt;/ui-calendar&gt;
</code></pre>
<p>In this case, the <code>ui-calendar</code> component iterates over all of days
in <code>currentMonth</code>, rendering each instance of the template with
information about which date it should represent.</p>
<p>We also think that this feature will be useful to allow container
components (like tabs or forms) to supply special-case component
definitions as block params. We are still working on the details,
but believe that an approach along these lines could make these
kinds of components simpler and more flexible.</p>
<a class="header" href="print.html#transition-plan-2" id="transition-plan-2"><h3>Transition Plan</h3></a>
<p>Block parameters will hopefully land in 1.12, and at that point the
two special forms for <code>{{each}}</code> and <code>{{with}}</code> will be deprecated.
You should refactor your templates to use the new block parameters
syntax once it lands, as it is a purely mechanical refactor.</p>
<p><strong>We have no plans to remove support for the <code>{{each}}</code> and <code>{{with}}</code>
special forms in Ember 2.0.</strong></p>
<a class="header" href="print.html#more-consistent-handlebars-scope" id="more-consistent-handlebars-scope"><h2>More Consistent Handlebars Scope</h2></a>
<p>In today's Ember, the <code>each</code> and <code>with</code> helpers come in two flavors: a
&quot;context-switching&quot; flavor and a &quot;named-parameter&quot; flavor.</p>
<pre><code class="language-handlebars">{{#each post in posts}}
  {{!-- the context in here is the same as the outside context,
        and `post` references the current iteration --}}
{{/each}}

{{#each posts}}
  {{!-- the context in here has shifted to the individual post.
        the outer context is no longer accessible --}}
{{/each}}
</code></pre>
<p>This has proven to be one of the more confusing parts of the Ember
templating system. It is also not clear to beginners which to use,
and when they choose the context-shifting form, they lose access to
values in the outer context that may be important.</p>
<p>Because the helper itself offers no clue about the context-shifting
behavior, it is easy (even for more experienced Ember developers)
to get confused when skimming a template about which object a value
refers to.</p>
<p>In Ember 1.10, we will deprecate the context-shifting forms of
<code>#each</code> and <code>#with</code> in favor of the named-parameter forms.</p>
<a class="header" href="print.html#transition-plan-3" id="transition-plan-3"><h3>Transition Plan</h3></a>
<p>To transition your code to the new syntax, you can change templates
that look like this:</p>
<pre><code class="language-hbs">{{#each people}}
  &lt;p&gt;{{firstName}} {{lastName}}&lt;/p&gt;
  &lt;p&gt;{{address}}&lt;/p&gt;
{{/each}}
</code></pre>
<p>with:</p>
<pre><code class="language-hbs">{{#each people as |person|}}
  &lt;p&gt;{{person.firstName}} {{person.lastName}}&lt;/p&gt;
  &lt;p&gt;{{person.address}}&lt;/p&gt;
{{/each}}
</code></pre>
<p><strong>We plan to deprecate support for the context-shifting helpers in Ember
1.10 and remove support in Ember 2.0.</strong> This change should be entirely
mechanical.</p>
<a class="header" href="print.html#one-way-bindings-by-default" id="one-way-bindings-by-default"><h2>One-Way Bindings by Default</h2></a>
<p>After a few years of having written Ember applications, we have observed
that most of the data bindings in the templating engine do not actually
require two-way bindings.</p>
<p>When we designed the original templating layer, we figured that making
all data bindings two-way wasn't very harmful: if you don't set a
two-way binding, it's a de facto one-way binding!</p>
<p>We have since realized (with some help from our friends at React), that
components want to be able to hand out data to their children without
having to be on guard for wayward mutations.</p>
<p>Additionally, communication between components is often most naturally
expressed as events or callbacks. This is possible in Ember, but the
dominance of two-way data bindings often leads people down a path of
using two-way bindings as a communication channel. Experienced Ember
developers don't (usually) make this mistake, but it's an easy one to
make.</p>
<p>When you use the new component syntax, the <code>{{}}</code> interpolation syntax
defaults to creating one-way bindings in the components.</p>
<pre><code class="language-handlebars">&lt;my-video src={{url}}&gt;&lt;/my-video&gt;
</code></pre>
<p>In this example, the component's <code>src</code> property will be updated whenever
<code>url</code> changes, but it will not be allowed to mutate it.</p>
<p>If a template wishes to allow the component to mutate a property, it can
explicitly create a two-way binding using the <code>mut</code> helper:</p>
<pre><code class="language-handlebars">&lt;my-video paused={{mut isPaused}}&gt;&lt;/my-video&gt;
</code></pre>
<p>This can help ease the transition to a more event-based style of
programming.</p>
<p>It also eliminates the boilerplate associated with an event-based style
when working with form controls. Instead of copying state out of a
model, listening for callbacks, and updating the model, the <code>input</code>
helper can be given an explicit mutable binding.</p>
<pre><code class="language-handlebars">&lt;input value={{mut firstName}}&gt;
&lt;input value={{mut lastName}}&gt;
</code></pre>
<p>This is similar to the approach taken by <a href="http://facebook.github.io/react/docs/two-way-binding-helpers.html">React.Link</a>, but we think
that the use-case of form helpers is sufficiently common to make it
ergonomic.</p>
<a class="header" href="print.html#transition-plan-4" id="transition-plan-4"><h3>Transition Plan</h3></a>
<p>The new one-way default is triggered by the use of new component syntax.
This means that component invocations in existing templates will
continue to work without changes.</p>
<p>When transitioning to the new HTML-based syntax, you will likely want to
evaluate whether bindings are actually being mutated, and avoid using
<code>mut</code> for values that the component never changes. This will make it
easier for future readers of your template to get an understanding of
what properties might be changed downstream.</p>
<p>To preserve the same semantics during a refactor to the new HTML-based
syntax, you can simply mark all bindings as <code>mut</code>.</p>
<pre><code class="language-handlebars">{{!-- these are semantically equivalent --}}

{{my-video src=movie.url paused=controller.isPaused}}

&lt;my-video src={{mut movie.url}} paused={{mut controller.isPaused}}&gt;
&lt;/my-video&gt;
</code></pre>
<p>While the above example preserves the same mutability semantics, it
should be clear that the video player component should never change the
<code>url</code> of the <code>movie</code> model.</p>
<p>To make sure you get an exception should this ever happen, simply remove
the <code>mut</code>:</p>
<pre><code class="language-handlebars">&lt;my-video src={{movie.url}} paused={{mut controller.isPaused}}&gt;
&lt;/my-video&gt;
</code></pre>
<p><strong>We have no plans to remove the old-style component syntax in Ember
2.0, so the semantics of existing component invocations will not
change.</strong></p>
<a class="header" href="print.html#separated-component-parameters" id="separated-component-parameters"><h2>Separated Component Parameters</h2></a>
<p>In today's Ember, parameters passed to components as attributes become
properties of the component itself, putting them in the same place as
other internal state.</p>
<p>This can be somewhat confusing, because it may not be obvious to the
reader of a component's JavaScript or template which values are
internal, and which are passed in as part of the public API.</p>
<p>To remind themselves, many Ember users write their components like this:</p>
<pre><code class="language-js">export default Component.extend({
  /* Public API */

  src: null,
  paused: null,
  title: null,

  /* Internal */
  scrubber: null
})
</code></pre>
<p>It can also be unclear how to react to a change in the external
properties. It is possible to use observers for this purpose in Ember,
but observers feel low-level and do not coordinate very well with the
rendering process.</p>
<p>To reduce confusion, we plan to move external attributes into a new
<code>attrs</code> hash.</p>
<p>If you invoke a component like this:</p>
<pre><code class="language-handlebars">&lt;my-video src={{movie.url}}&gt;&lt;/my-video&gt;
</code></pre>
<p>then the <code>my-video</code> component accesses the passed-in <code>src</code> attribute as
<code>this.attrs.src</code>.</p>
<p>We also plan to provide lifecycle callbacks (modelled after <a href="http://facebook.github.io/react/docs/component-specs.html#lifecycle-methods">React's
lifecycle callbacks</a>) for changes to <code>attrs</code> that will
integrate with the rendering lifecycle. We plan to supplement the API
with callbacks for changes in individual properties as well.</p>
<a class="header" href="print.html#transition-plan-5" id="transition-plan-5"><h3>Transition Plan</h3></a>
<p>In Ember 1.10, we will begin installing provided attributes in the
component's <code>attrs</code> hash. If a provided attribute is accessed directly
on the component, a deprecation warning will be issued.</p>
<p>In applications, you should update your component JavaScript and
templates to access provided attributes via the component's <code>attrs</code>
property.</p>
<p><strong>In Ember 2.0, we will stop setting attributes as properties on the
component itself.</strong></p>
<p>We will also provide a transitional mixin that Ember addons can use that
will make provided attributes available as <code>attrs.*</code>. This will allow
add-ons to move to the new location, while maintaining support for older
versions of Ember. We expect people to upgrade to Ember 1.10 relatively
quickly, and do not expect addons to need to maintain support for Ember
1.9 indefinitely.</p>
<a class="header" href="print.html#routeable-components" id="routeable-components"><h2>Routeable Components</h2></a>
<p>Many people have noticed that controllers in Ember look a lot like
components, but with an arbitrary division of responsibilities. We
agree!</p>
<p>In current versions of Ember, when a route is entered, it builds a
controller, associates a model with it, and hands it off to an
(old-style) view for rendering. The view itself is invisible; you just
write a template with the correct name.</p>
<p>We plan to transition to: when a route is entered, it renders a
<strong>component</strong>, passing along the model as an <code>attr</code>. This eliminates a
vestigial use of old-style views, and associates the top-level template
with a regular component.</p>
<a class="header" href="print.html#transition-plan-6" id="transition-plan-6"><h3>Transition Plan</h3></a>
<p>Initially, we will continue to support routing to a controller+template,
so nothing will break. Going forward, routes will route to a component
instead.</p>
<p>In order to do that refactoring, several things will change:</p>
<ul>
<li>Instead of referring to model properties directly (or on <code>this</code>), you
will refer to them as <code>model.propName</code>.</li>
<li>Similarly, computed properties that move to your component will need
to depend on <code>model.propName</code> if they are migrated from an
<code>ObjectController</code>.</li>
<li>In both cases, the short version is that you can no longer rely on the
proxying behavior of <code>ObjectController</code> or <code>ArrayController</code>, but you
can remedy the situation by prefixing <code>model.</code> to the property name.</li>
<li>Unlike controllers, top-level components do not persist across
navigation. Persistent state should be stored in route objects and
passed as initial properties to routable components.</li>
<li>In addition to the asynchronous <code>model</code> hook in routes, routes will
also be able to define a <code>attrs</code> hook, which can return additional
asynchronous data that should be provided to the component.</li>
<li>Routeable Components should be placed in a &quot;pod&quot; naming convention. For
example, the component for the <code>blog-post</code> route would be
<code>app/blog-post/component.js</code>.</li>
</ul>
<p><strong>We plan to land support for routeable components in Ember 1.12, and
deprecate routeable controllers at the same time. We plan to remove
support for routeable controllers in Ember 2.0.</strong> This will allow
you to move your codebases over to routeable components piecemeal before
making the jump to 2.0.</p>
<p><strong>We will also provide an optional plugin for Ember 2.0 apps that restores
existing behavior.</strong> This plugin will be included in the Ember automated
test suite to ensure that we do not introduce accidental regressions in
future releases on the 2.x series.</p>
<p>We realize that this is the change has the largest transitional cost of
all the planned features, and we plan to dedicate time to the precise
details in the full RFC on this topic.</p>
<a class="header" href="print.html#improving-actions" id="improving-actions"><h2>Improving Actions</h2></a>
<p>Today's components can communicate with their parent component through
actions. In particular, the <code>sendAction</code> method allows a child component
to invoke a named action on the parent (inside of the <code>actions</code> hash).</p>
<p>Part of the reason for this API was a limitation in the original
Handlebars syntax:</p>
<pre><code class="language-handlebars">{{!-- we can't get too fancy with the value of key-press --}}
{{input key-press=&quot;valueChanged&quot;}}
</code></pre>
<p>In this example, when the <code>input</code> component calls
<code>this.sendAction('key-press')</code>, it invokes the <code>valueChanged</code> action on
its parent component.</p>
<p>With the new HTML syntax for components, we have more flexibility:</p>
<pre><code class="language-handlebars">&lt;input key-press={{action &quot;valueChanged&quot;}}&gt;
</code></pre>
<p>This will package up the parent's <code>valueChanged</code> action (in the
<code>actions</code> hash) as a callback function that is available to the child
component as <code>this.attrs['key-press']</code>.</p>
<pre><code class="language-js">export default Ember.Component.extend({
  keypress: function(event) {
    this.attrs['key-press'](event.target.value);
  }
});
</code></pre>
<p>The benefit of this approach is twofold:</p>
<ul>
<li>Actions are no longer treated specially in the component API. They are
simply properties packaged up to be called by the child component.</li>
<li>It is possible to pass an alternative function as the <code>key-press</code>,
reducing the child component's knowledge of what the callback is
doing. This has testing and abstraction benefits.</li>
</ul>
<a class="header" href="print.html#transition-plan-7" id="transition-plan-7"><h3>Transition Plan</h3></a>
<p>We will continue to support the <code>sendAction</code> API for the forseeable
future in today's Handlebars syntax.</p>
<p>When calling an existing component with new HTMLBars syntax, you do not
need to change your existing <code>actions</code> hash. You should change syntax
that looks like this:</p>
<pre><code class="language-handlebars">{{video-player playing=&quot;playingBegins&quot;}}
</code></pre>
<p>To this:</p>
<pre><code class="language-handlebars">&lt;video-player playing={{action &quot;playingBegins&quot;}}&gt;
</code></pre>
<p>The <code>video-player</code> component's internal use of <code>sendAction</code> will work
with both calling styles.</p>
<p>New components should use <code>this.attrs.playing()</code>, but existing components
that want to continue supporting legacy callers should continue to use
<code>sendAction</code> for now. The <code>sendAction</code> API will seamlessly support both
calling styles, and will be supported for the forseeable future.</p>
<pre><code class="language-js">// instead of
this.sendAction('progress', value);

// new code can use
this.attrs.progress(value);
</code></pre>
<a class="header" href="print.html#onward" id="onward"><h2>Onward</h2></a>
<p>Version 2.0 marks the transformation of Ember from simply an MVC framework
to a complete front-end stack. Between Ember's best-in-class router,
revamped components with virtual DOM, easy-to-use build tools, and a growing
ecosystem that makes taking advantage of additional libraries a breeze, there's
no better way to get started and stay productive developing web apps today.</p>
<p>Hopefully, this plan demonstrates that staying on the cutting-edge can be done
without rewriting your app. There are a huge number of Ember apps in production
today, and we're looking forward to a time in the very near future where they
can start to take advantage these new features.</p>
<p>Expect to see many more RFCs covering these features in depth soon (including
a roadmap for Ember Data 1.0). We look forward to hearing your feedback!</p>
<ul>
<li>2014-11-26</li>
<li>RFC PR: https://github.com/emberjs/rfcs/pull/24</li>
<li>Ember Issue:</li>
</ul>
<a class="header" href="print.html#summary-6" id="summary-6"><h1>Summary</h1></a>
<p>Unlike Handlebars, HTMLBars parses HTML as it parses a template.
Bound attributes are one syntax now possible.</p>
<p>For example, this variable <code>color</code> is bound to set a class:</p>
<pre><code class="language-hbs">&lt;div class=&quot;{{color}}&quot;&gt;&lt;/div&gt;
</code></pre>
<p>Though traditional HTML attribute syntax should be preserved (using
<code>class</code> and not <code>className</code> for example), the default path will be
to set attributes as properties on the DOM node.</p>
<p>However this happy path has several important exceptions, and results
in a few strange edge cases. This rfc will go into detail about the
expected behavior without talking about the implementation of attribute
on the Ember rendering pipeline.</p>
<a class="header" href="print.html#motivation-7" id="motivation-7"><h1>Motivation</h1></a>
<p><code>{{bind-attr</code> is a verbose syntax and difficult for new developers to
understand.</p>
<a class="header" href="print.html#detailed-design-4" id="detailed-design-4"><h1>Detailed design</h1></a>
<p>Given a use of bound attributes:</p>
<pre><code class="language-hbs">&lt;input type=&quot;checkbox&quot; checked={{isChecked}}&gt;
</code></pre>
<p>There are three important inputs:</p>
<ul>
<li>The element (<code>tagName</code>, <code>namespaceURI</code>)</li>
<li>The attribute name</li>
<li>The value (literal or stream)</li>
</ul>
<p>The following described the algorithm for updating the attribute/property
value on an element.</p>
<ol>
<li>If the element has an SVG namespace, use <code>setAttribute</code>. Setting SVG attributes
as properties is not supported.</li>
<li>If the attribute name is <code>style</code>, use <code>setAttribute</code>.</li>
<li>Normalize the property name as described in <code>propertyNameFor</code> below. If a normalized
name is returned, set that property on the element (<code>element[normalizedPropName]</code>).
If it is not returned, set with <code>setAttribute</code>.</li>
</ol>
<p><code>propertyNameFor</code> is a normalization setup for attribute names that takes the element
and attribute name as input.</p>
<ol>
<li>Build a list of normalized properties for the passed element <code>normalizedAttrs[element.tagName][elementAttrName.toLowerCase()] = elementAttrName</code></li>
<li>Fetch the normalized property name from this list <code>normalizedAttr = normalizedAttrs[element.tagName][passedAttrName.toLowerCase()]</code></li>
<li>Return this normalized attr. If an <code>attrName</code> is did not normalize to a property (for example <code>class</code>), null is returned</li>
</ol>
<a class="header" href="print.html#acknowledged-edge-cases" id="acknowledged-edge-cases"><h3>Acknowledged edge cases</h3></a>
<ul>
<li>Boolean attrs with blank string won't work like they would in HTML: <code>&lt;input disabled=&quot;{{blankString}}&quot;&gt;</code> would be false</li>
<li>Some selectors may not work as expected. <code>&lt;input value=&quot;{{color}}&quot;&gt;</code> will not result in a working <code>[value=red]</code> selector</li>
</ul>
<a class="header" href="print.html#drawbacks-6" id="drawbacks-6"><h1>Drawbacks</h1></a>
<p>None.</p>
<a class="header" href="print.html#alternatives-6" id="alternatives-6"><h1>Alternatives</h1></a>
<p>Two obvious alternatives considered in detail are Angular and React.</p>
<p>In <strong>Angular 2.0</strong>, <a href="http://www.beyondjava.net/blog/angularjs-2-0-sneak-preview-data-binding/">a new prop/attr/event syntax</a>
is being introduced.</p>
<p>Setting an attribute just like setting an HTML attribute:</p>
<pre><code class="language-html">&lt;pui-tab title=&quot;What a nice tab!&quot;&gt;
</code></pre>
<p>Properties are flagged with the <code>[]</code> syntax:</p>
<pre><code class="language-html">&lt;input [disabled]=&quot;controller.isInputDisabled&quot;&gt;
</code></pre>
<p>Angular is limited by it's HTML templating here. The value must be quoted
to have complex content, where as in HTMLBars it is easier to bend the
rules to introduce literal values: <code>disabled={{controller.isInputDisabled}}</code>.</p>
<p>Events are out of our immediate purview in this RFC, but for completeness
note Angular's syntax:</p>
<pre><code class="language-html">&lt;button (click)=&quot;hide()&quot;&gt;hide image&lt;/button&gt;
</code></pre>
<p><strong>React's JSX</strong> has its own <a href="http://facebook.github.io/react/docs/jsx-in-depth.html">property syntax</a>,
one that diverges from traditional HTML by focusing entirely on properties
instead of attributes. This means the templates are well prepared for
use with components, but also that JSX must maintain a large whitelist of
special cases such as <a href="http://facebook.github.io/react/docs/tags-and-attributes.html">supported tags</a>
and <a href="http://facebook.github.io/react/docs/jsx-gotchas.html">some HTML attributes</a>.</p>
<p>In general we would prefer to have Ember templates be as close to HTML
as possible, without requiring developers to learn a new set of property
names replacing the attribute names they already know.</p>
<a class="header" href="print.html#unresolved-questions-4" id="unresolved-questions-4"><h1>Unresolved questions</h1></a>
<ul>
<li>How do we deal with <code>on*</code> attributes?</li>
<li>Should we do anything special about generic element properties like <code>&lt;div outerhtml={{lol}}&gt;&lt;/div&gt;</code>?</li>
<li>Should HTMLBars unbound attributes use the same alorithm?</li>
</ul>
<p>There is a spike of significant depth <a href="https://github.com/emberjs/ember.js/pull/9721">in PR #9721</a>
and a followup <a href="https://github.com/emberjs/ember.js/pull/9977">in PR #9977</a>.</p>
<ul>
<li>Start Date: 2015-06-07</li>
<li>RFC PR: https://github.com/emberjs/rfcs/pull/45</li>
<li>Ember Issue: (leave this empty)</li>
</ul>
<a class="header" href="print.html#summary-7" id="summary-7"><h1>Summary</h1></a>
<p>Solicit feedback about the support timeframe for Internet Explorer 8 and Internet Explorer 9.</p>
<a class="header" href="print.html#motivation-8" id="motivation-8"><h1>Motivation</h1></a>
<p>As Ember heads towards version 2.0, it is a good time to evaluate our browser support matrix. Ember follows Semantic Versioning, and we consider browser compatibility to be under the umbrella of those guarantees. In other words, we will continue to support whatever browsers we officially support in Ember 2.0 until Ember 3.0.</p>
<p>Ember 1.x did not have an official browser support matrix, but we would like to correct this for Ember 2.0.</p>
<p>We want to make this decision on the basis of the browsers that our community still needs to support, while weighing that against the costs we bear as a community to support older browsers. This RFC will lay out some of those costs, so we can decide what tradeoff is most appropriate.</p>
<p>Members of the core team maintain many different kinds of apps across many different kinds of companies. Some of us work on applications with small, agile teams, while others work inside of large corporations with many engineers. When this topic came up amongst the team, we discovered that, across all these different companies and Ember apps, no one was still supporting IE8.</p>
<p>Because of this, the core team's impression is that the costs of IE8 support now far exceed the benefits, and we are considering dropping support
for IE8 in Ember 2.0. Before we make the decision, we want to hear from the rest of the community. Supporting IE8 incurs significant cost, both in terms of features and maintenance, and we want the community to help us think through the cost-benefit analysis.</p>
<p>Ember is more than just the framework's code. When people use Ember, they expect to be able to use Ember's tooling, read Ember's documentation, find solutions to problems on Stack Overflow, and read tutorials produced by community members. All of these are shackled to the limitations of IE8, and by dropping support for IE8, people can begin to rely on the improved baseline of ES5.</p>
<p>Below, we outline the costs of continuing to support IE8, so that you can help us make a considered decision.</p>
<a class="header" href="print.html#detailed-design-5" id="detailed-design-5"><h1>Detailed design</h1></a>
<a class="header" href="print.html#ie8" id="ie8"><h2>IE8</h2></a>
<a class="header" href="print.html#eliminate-get" id="eliminate-get"><h3>Eliminate <code>get()</code></h3></a>
<p>Currently, accessing properties on an Ember object requires using the <code>.get()</code> method. By using this abstraction, we have been able to implement several powerful features, such as proxies and computed properties, even on older browsers like IE8 that lack getters and setters.</p>
<p>However, ECMAScript 5, which shipped in <strong>2009</strong>, added support for getters to JavaScript itself, and we would like to use this feature in Ember to eliminate the explicit calls to <code>get</code>. Developers new to the framework tell us that having to remember to use <code>.get()</code> is a big source of confusion. More seasoned developers get used to it, but moving the Ember object model closer to the pure JavaScript object model is a major goal for Ember 2.x. While many of the features of ES6 classes can be transpiled, getters and setters require engine support, and could not be used if we needed to support IE8.</p>
<a class="header" href="print.html#more-es6-features-today" id="more-es6-features-today"><h3>More ES6 Features, Today</h3></a>
<p>While much of ES6 can be transpiled correctly to ES3 (the version of JavaScript included with IE8), transpiling ES6 modules and classes requires <code>defineProperty</code>.</p>
<p>Continued support for IE8 limits our ability to adopt new ES6 features in the internals of Ember, and to talk about them in our documentation.</p>
<p>One example: In ES6, classes define their methods as non-enumerable properties. Transpiling this to existing browsers is only possible with <code>defineProperty</code>, which is not included in IE8. Trying to transpile ES6 classes to work on IE8 would lead to apps exhibiting subtly different behavior that would be painful to debug. IE8 users would discover that the larger Ember ecosystem was incompatible with their apps in hard-to-predict ways, and we think the ecosystem is one of the biggest advantages Ember offers.</p>
<p>In other words, we don't think we can make the full transition to JavaScript classes a first-class part of the Ember experience if we still support IE8. As we did with modules, we would like to move more of our core to JavaScript features in the future, which would be significantly stymied by the lack of <code>defineProperty</code> in IE8.</p>
<a class="header" href="print.html#remove-the-jquery-dependency" id="remove-the-jquery-dependency"><h3>Remove the jQuery Dependency</h3></a>
<p>For its entire lifetime, Ember has relied on jQuery to smooth the rough edges of browser compatibility when interacting with the DOM. When people think about that dependency, they often assume that we could just replace calls to things like <code>.attr</code> with their more verbose DOM counterpart and call it a day.</p>
<p>jQuery does more than just patch over IE8 rough spots; it also serves as the central place for normalizing behavior that can differ significantly across browsers. If we tried to pick-and-choose pieces of jQuery to pull into Ember, we would also be responsible for backporting any changes made to jQuery. We'd rather just rely on jQuery directly; that's what dependencies are for.</p>
<p>The jQuery dependency has helped us with a few cross-browser areas:</p>
<ul>
<li>Portable <code>DOMContentLoaded</code> (via <code>jQuery.ready</code>)</li>
<li>Support for event delegation across a wide variety of events.</li>
<li>Attribute and property normalization, which has already been implemented by HTMLBars</li>
<li>HTML parsing, which has also been implemented by HTMLBars</li>
</ul>
<p>Of these, proper support for event delegation is the largest remaining reason to rely on jQuery. IE9's support for the capture phase of events makes it simpler to support event delegation properly across all event types without a normalization layer.</p>
<a class="header" href="print.html#support-more-event-types" id="support-more-event-types"><h3>Support More Event Types</h3></a>
<p>Many newly specified events in the web platform (such as the media events) do not bubble, which is a problem for frameworks like Ember that rely on event delegation. However, the capture API, which was added in IE9, is invoked properly for all events, and does not require a normalization layer. Not only would supporting the capture API allow us to drop the jQuery dependency, but it would allow us to properly handle these non-bubbling events. This would allow you to use events like <code>playing</code> in your components without having to manually set up event listeners.</p>
<a class="header" href="print.html#css-improvements-in-ember-2x" id="css-improvements-in-ember-2x"><h3>CSS Improvements in Ember 2.x</h3></a>
<p>Today, the main Ember framework does very little to directly help with CSS. We expect that to change in the 2.x series, as we explore ways to help tame the CSS beast.</p>
<p>However, a number of important CSS features landed in IE9: CSS3 selectors, full support for <code>querySelectorAll</code>, <code>getComputedStyle</code>, <code>calc()</code> to name a few. Productively tackling the CSS problem without these features would be like fighting with both hands tied behind our backs, and it may be impossible for us to robustly tackle the problem until Ember 3.0 if we needed to continue to support IE8.</p>
<p>While it may be theoretically possible to implement some form of this feature in IE8, it is likely that the cost of doing so in a backwards-compatible way would significantly add to development time; perhaps so significantly it would be better to wait until we drop support for IE8 than attempt to bolt it on to a browser released half a decade ago.</p>
<a class="header" href="print.html#maintenance-costs" id="maintenance-costs"><h3>Maintenance Costs</h3></a>
<p>While it's very easy to weigh the costs of features that we could not implement at all due to IE8, there is a much more pernicious cost that is harder to see.</p>
<p>Support for IE8 adds costs, sometimes significant, to every new feature we work on. For example, broken support for text nodes in IE8 significantly impeded early work on Glimmer. Every new area of work requires budgeting a significant amount of time for IE8 support.</p>
<p>This is not surprising. When asked many years ago what jQuery could do when IE6 was gone, John Resig replied that we would gain little from dropping IE6, and that the benefits would not come until jQuery could drop IE8, the last version of IE featuring the bugs that made IE6 so difficult to develop for.</p>
<p>Quite often, we will assume that a feature is ready to ship, and only discover subtle issues in IE8 very close to the release once it has been tested. We estimate that support for legacy Internet Explorer slowed down the development of HTMLBars by 2x.</p>
<p>In short, we would be able to implement more features more quickly without the burden of bugs that were first introduced 15 years ago.</p>
<a class="header" href="print.html#what-about-ie9" id="what-about-ie9"><h2>What About IE9?</h2></a>
<p>In the first decade of 2000, browsers were updated very slowly, and every new release took a long time to be supplanted by the next release. As the last version of Internet Explorer supported by Windows XP, IE8 is a relic of this bygone era. In contrast, IE9 usage was quickly supplanted by IE10, and that pattern continues with IE11.</p>
<p>The public trackers have IE9 at a lower share of total usage than IE8, so it might be worth considering dropping them together. Our decision for Ember 2.0 will likely hold until late 2016, so it's worth considering more than just the current moment when making the decision.</p>
<p>While IE9 added support for the ES5 features we need to move into the future for JavaScript, IE10 added support for the last great wave of web features. Here is a sampling:</p>
<ul>
<li>Flexbox and Grid Layout</li>
<li>Offline storage (IndexedDB, File, Blob)</li>
<li>Web Workers</li>
<li>Typed Arrays</li>
<li>Web Sockets</li>
<li>App Cache</li>
<li>History API</li>
</ul>
<p>Several of these features are required for asm.js, and in total, they make the web platform a capable application runtime. While we don't have any immediate plans to take advantage of these web features right now, the best experiments that people are doing today rely on them. By assuming IE10 as the baseline across the entire ecosystem, we would be able to do much more aggressive experimentation on the web platform.</p>
<a class="header" href="print.html#drawbacks-7" id="drawbacks-7"><h1>Drawbacks</h1></a>
<p>Many users have told us that they chose Ember because of the community's commitment to backwards compatibility. When we announced in early 2014 that we would continue to support IE8 for at least another year, other libraries and frameworks had already dropped support. That being said, there will always be organizations using Ember that exist on the tail-end of browser adoption patterns. We risk alienating or upsetting those users by dropping support for a browser that, while on the way out, is not yet completely gone.</p>
<p>However, in many cases, the requirement of IE8 support is driven by non-technical management who do not have a strong sense of the experience of using apps in IE8. In practice, many applications are not rigorously tested in older browsers, and the performance of IE8 is so bad that applications written using any framework perform poorly. Techniques that framework and application developers use to make Chrome fast quite often have pathological characteristics on browsers with a DOM and JavaScript engine written in the 90s.</p>
<p>Still, some people make it work, and dropping IE8 support may prevent those teams from staying with the community as it migrates to Ember 2.0.</p>
<a class="header" href="print.html#alternatives-7" id="alternatives-7"><h1>Alternatives</h1></a>
<a class="header" href="print.html#drop-ie8-support-during-2x" id="drop-ie8-support-during-2x"><h2>Drop IE8 Support During 2.x</h2></a>
<p>One alternative we have considered is deprecating IE8 support prior to releasing 2.0, but still maintaining it for a few point releases to give IE8 more time to lose market share.</p>
<p>After discussing with the core team, we believe that this would be a violation of our Semantic Versioning commitment to users. Specifically, we want to avoid a large group of apps getting stuck midway through the 2.x cycle. Version numbers are an important tool for developers, maintainers and ecosystems to communicate compatibility. Tools such as package managers rely on version numbers correctly indicating breaking changes.</p>
<p>We consider browser compatibility to be a feature of Ember, and dropping IE8 support in a minor release would be akin to stripping out any other major feature. While the ecosystem would muddle along in either case, such a move would cause exactly the kind of ecosystem fragmentation that Semantic Versioning is designed to prevent.</p>
<p>If we want to communicate the idea that changing versions comes with a reduction in functionality, we should do that the same way we always do, by incrementing the major version.</p>
<a class="header" href="print.html#early-30" id="early-30"><h2>Early 3.0</h2></a>
<p>Another option is to release 3.0 in six months, rather than the nearly two years between Ember 1.0 and Ember 2.0.</p>
<p>Correctly tuning the cadence of major releases is a delicate tradeoff. Semantic Versioning allows us to easily communicate about breaking changes, and some take this as a license to make them frequently. However, a robust ecosystem relies on a certain measure of stability.</p>
<p>We believe that the frustration of breaking changes every six months (or even a year) would outweigh whatever benefits it would provide. Ember's biggest goal is building a shared foundation for our ecosystem to build on, and this requires a careful commitment to stability.</p>
<p>While we could make a &quot;small&quot; breaking release soon after 2.0, breaking changes inherently fragment the ecosystem, and we hope that the years to come bring more stability for add-on authors and tool-makers, not less.</p>
<a class="header" href="print.html#bring-your-own-compatibility" id="bring-your-own-compatibility"><h2>Bring Your Own Compatibility</h2></a>
<p>Some libraries attempt to thread the needle of IE8 compatibility by asking users to bring their own compatibility libraries. They write the internals of their framework as if IE8 did not exist, and require end users to use polyfills to make the environment look equivalent to newer browsers. For example, React asks users to bring libraries such as <code>es5-shim</code>, <code>es5-sham</code>, <code>console-polyfill</code> and <code>html5shiv</code> if they want IE8 support.</p>
<p>Facebook.com supports IE8, and uses React, so there is a path to using React with IE8. This path is partially documented on the React website. This gives us a perfect opportunity to evaluate the impact of this strategy in the real world. We admire the React team's work in this area: support for IE8 is difficult and triaging and fixing IE8 bugs requires diligent effort.</p>
<p>After reviewing the <a href="https://github.com/facebook/react/issues?utf8=%E2%9C%93&amp;q=is%3Aissue+is%3Aopen+ie8">IE8-compatibility issues filed on React.js tracker</a>, we believe there are significant user experience costs to this strategy.</p>
<p>We have spent considerable effort on first-class IE8 support in Ember 1.x, and we feel that users who require IE8 support will have a better experience using Ember 1.14 (with the subset of the ecosystem that supports 1.x) than trying to cobble together a solution that works reliably in a version of Ember with second-class, bring-your-own-compatibility support.</p>
<a class="header" href="print.html#unresolved-questions-5" id="unresolved-questions-5"><h1>Unresolved questions</h1></a>
<p>We are relying on the community to help us weigh the above tradeoffs. The more data you can provide about the browser makeup of your customers (especially as it affects revenue), the better we can reason whether now is the time to remove IE8 (and possibly IE9) support.</p>
<p>If you cannot share the information publicly, please email whatever information you consider useful to browserusage@emberjs.com. We will keep it in the strictest of confidence.</p>
<ul>
<li>Start Date: 2015-04-09</li>
<li>RFC PR: https://github.com/emberjs/rfcs/pull/46</li>
<li>Ember Issue: https://github.com/emberjs/ember.js/pull/11440</li>
</ul>
<a class="header" href="print.html#summary-8" id="summary-8"><h1>Summary</h1></a>
<p>Fully encapsulate and privatize the <code>Container</code> and <code>Registry</code> classes by
exposing a select subset of public methods on <code>Application</code> and
<code>ApplicationInstance</code>.</p>
<a class="header" href="print.html#motivation-9" id="motivation-9"><h1>Motivation</h1></a>
<p>The <code>Container</code> and <code>Registry</code> classes currently lead a confusing life of
semi-private exclusion within Ember applications. They are undocumented
publicly but not fully private either, as knowledge of their particulars is
required for developing both initializers and unit tests. This situation has
become untenable as the new <code>Registry</code> class has been extracted from
<code>Container</code>, and the complexity of their usage has grown across
<code>Application</code> and <code>ApplicationInstance</code> classes.</p>
<p>We can bring sanity to this situation by continuing the work started at the
<code>Application</code> level to expose methods such as <code>register</code> and <code>inject</code> from the
internally maintained <code>Registry</code>.</p>
<p>Furthermore, once <code>Container</code> and <code>Registry</code> are fully private, their
architecture and documentation can be cleaned up. For instance, a
<code>Container</code> can freely reference its associated <code>Registry</code> as <code>registry</code>
rather than <code>_registry</code>, as it can be assumed that only framework developers
will reference this property.</p>
<a class="header" href="print.html#detailed-design-6" id="detailed-design-6"><h1>Detailed design</h1></a>
<p><code>Application</code> will expose the following methods from its internally maintained
registry:</p>
<ul>
<li><code>register</code></li>
<li><code>inject</code></li>
<li><code>registerOptions</code> - mapped to <code>Registry#options</code></li>
<li><code>registerOptionsForType</code> - mapped to <code>Registry#optionsForType</code></li>
</ul>
<p><code>ApplicationInstance</code> will also expose the the same methods. However, these
methods will be exposed from its own internally maintained registry, which
has the associated <code>Application</code>'s registry configured as a &quot;fall back&quot;. No
direct path will be provided from the <code>ApplicationInstance</code> to the
<code>Application</code>'s registry.</p>
<p><code>ApplicationInstance</code> will also expose the following methods from its
internally maintained container:</p>
<ul>
<li><code>lookup</code></li>
<li><code>lookupFactory</code></li>
</ul>
<p><code>ApplicationInstance</code> will cease exposing <code>container</code>, <code>registry</code>, and
<code>applicationRegistry</code> publicly.</p>
<p><code>Application</code> initializers will receive a single argument to <code>initialize</code>:
<code>application</code>.</p>
<p>Likewise, <code>ApplicationInstance</code> initializers will receive a single argument
to <code>initialize</code>: <code>applicationInstance</code>.</p>
<p><code>Container</code> and <code>Registry</code> will be made fully private and documented as
such. Each <code>Container</code> will freely reference its associated <code>Registry</code> as
<code>registry</code> rather than <code>_registry</code>.</p>
<p><a href="https://github.com/switchfly/ember-test-helpers">ember-test-helpers</a>
will provide an <code>isolatedApplicationInstance</code> method instead of an
<code>isolatedContainer</code> for unit testing. A mechanism will be developed to specify
which initializers should be engaged in the initialization of this instance.
In this way, we can avoid duplication of registration logic, as is currently
done in a most un-DRY manner in the <a href="https://github.com/switchfly/ember-test-helpers/blob/master/lib/ember-test-helpers/isolated-container.js#L56-L79">isolatedContainer</a>.</p>
<a class="header" href="print.html#drawbacks-8" id="drawbacks-8"><h1>Drawbacks</h1></a>
<p>This refactor will require maintaining backwards compatibility and
deprecation warnings until Ember 2.0. This will temporarily increase
internal code complexity and file sizes.</p>
<a class="header" href="print.html#alternatives-8" id="alternatives-8"><h1>Alternatives</h1></a>
<p>The obvious alternative is to make <code>Container</code> and <code>Registry</code> fully public
and documented. An application's registry would be available as a <code>registry</code>
property. An application instance's container would remain available as
<code>container</code>.</p>
<p>We could still pass an <code>Application</code> into application initializers
and an <code>ApplicationInstance</code> into application instance initializers.</p>
<p>If this alternative is taken, I would suggest that <code>Application</code> should
deprecate <code>register</code> and <code>inject</code> in favor of calling the equivalents on its
public <code>registry</code>.</p>
<p>Regardless of which alternative is chosen, we should ensure that the public
aspects of container and registry usage are well documented.</p>
<a class="header" href="print.html#unresolved-questions-6" id="unresolved-questions-6"><h1>Unresolved questions</h1></a>
<ul>
<li>
<p>Are the public methods listed above sufficient or should any others be
exposed?</p>
</li>
<li>
<p>What mechanism should be used to engage initializers in unit and
integration tests? Should test modules simply have an <code>initializers</code> array,
similar to the current <code>needs</code> array?</p>
</li>
<li>
<p>Given the semi-private nature of containers and registries, we may not need
to worry about semver for deprecations. However, we should be good citizens
and properly deprecate as much as possible. Some real world use cases in
initializers will no doubt be a surprise, so we need to tread carefully.</p>
</li>
</ul>
<ul>
<li>Start Date: 2014-05-06</li>
<li>RFC PR: https://github.com/emberjs/rfcs/pull/50</li>
<li>Ember Issue: (leave this empty)</li>
</ul>
<a class="header" href="print.html#summary-9" id="summary-9"><h1>Summary</h1></a>
<p>The <code>{{action</code> helper should be improved to allow for the creation of
closed over functions that can be passed between components and passed
the action handlers.</p>
<p>See <a href="http://emberjs.jsbin.com/rwjblue/466/edit?html,js,output">this example JSBin from @rwjblue</a>
for a demonstration of some of these ideas.</p>
<a class="header" href="print.html#motivation-10" id="motivation-10"><h1>Motivation</h1></a>
<p>Block params allow data to be passed from one component to a downstream
component, however there is currently no way to pass a callback to a downstream
component.</p>
<a class="header" href="print.html#detailed-design-7" id="detailed-design-7"><h1>Detailed design</h1></a>
<p>First, the existing uses of <code>{{action</code> will be maintained. An action can be attached to an
element by using the helper in element space:</p>
<pre><code class="language-hbs">{{! app/index/template.hbs }}
{{! submit action will hit immediate parent }}
&lt;button {{action &quot;submit&quot;}}&gt;Save&lt;/button&gt;
</code></pre>
<p>An action can be passed to a component as a string:</p>
<pre><code class="language-hbs">{{! app/index/template.hbs }}
{{my-button on-click=&quot;submit&quot;}}
</code></pre>
<pre><code class="language-js">// app/components/my-button/component.js
export default Ember.Component.extend({
  click: function(){
    this.sendAction('on-click');
  }
});
</code></pre>
<p>Or a default action can be passed:</p>
<pre><code class="language-hbs">{{! app/index/template.hbs }}
{{my-button action=&quot;submit&quot;}}
</code></pre>
<pre><code class="language-js">// app/components/my-button/component.js
export default Ember.Component.extend({
  click: function(){
    this.sendAction();
  }
});
</code></pre>
<p>In all these cases, <code>submit</code> is called on the parent context relative to the scope <code>action</code> is
attached in. The value <code>&quot;submit&quot;</code> is attached to the component in the last two as
<code>this.attrs.on-click</code> or <code>this.attrs.action</code>, although it is not directly used.</p>
<a class="header" href="print.html#creating-closure-actions" id="creating-closure-actions"><h3>Creating closure actions</h3></a>
<p>Closure actions are created in a template and may be used in all places a string
action name can be used. For example, this current functionality:</p>
<pre><code class="language-hbs">&lt;button {{action &quot;submit&quot; on=&quot;click&quot;}}&gt;Save&lt;/button&gt;
</code></pre>
<p>Would be written using a closure action as:</p>
<pre><code class="language-hbs">&lt;button {{action (action &quot;submit&quot;) on=&quot;click&quot;}}&gt;Save&lt;/button&gt;
</code></pre>
<p>The functionality is exactly the same as the string-based action example.
How does that happen?</p>
<ul>
<li><code>(action &quot;submit&quot;)</code> reads the <code>submit</code> function off the current scope's
<code>actions.submit</code> property.</li>
<li>It then creates a closure to call that function.</li>
<li><code>{{action</code> receives that function as a param. It registers a listener (in
this case on click) and when fired calls the closure function.</li>
</ul>
<p>Consider usage on the calling side. With the current string-based actions:</p>
<pre><code class="language-hbs">{{my-component action=&quot;submit&quot;}}
</code></pre>
<pre><code class="language-js">export default Ember.Component.extend({
  click: function(){
    this.sendAction(); // submit action, legacy
    // this.attrs.action is a string
    this.attrs.action; // =&gt; &quot;submit&quot;
  }
});
</code></pre>
<p>With closure actions, the action is available to call directly. The <code>(action</code> helper
wraps the action in the current context and returns a function:</p>
<pre><code class="language-hbs">{{my-component action=(action &quot;submit&quot;)}}
</code></pre>
<pre><code class="language-js">export default Ember.Component.extend({
  click: function(){
    this.sendAction(); // submit action, legacy
    // this.attrs.action is a function
    this.attrs.action(); // submit action, new style
  }
});
</code></pre>
<p>A more complete example follows, with a controller for context:</p>
<pre><code class="language-js">// app/index/controller.js
export default Ember.Controller.extend({
  actions: {
    submit: function(){
      // some submission task
    }
  }
});
</code></pre>
<pre><code class="language-hbs">{{! app/index/template.hbs }}
{{my-button save=(action 'submit')}}
</code></pre>
<pre><code class="language-js">// app/components/my-button/component.js
export default Ember.Component.extend({
  click: function(){
    this.attrs.save();
    // for backwards compat, you may also this.sendAction('save');
  }
});
</code></pre>
<a class="header" href="print.html#hole-punching-with-a-closure-based-action" id="hole-punching-with-a-closure-based-action"><h3>Hole punching with a closure-based action</h3></a>
<p>The current system of action bubbling falls down quickly when you want to pass a message through multiple
levels of components. A closure based action system helps address this.</p>
<p>Instead of relying on bubbling, a closure action wraps an action from the current context's
<code>actions</code> hash in a function that will call it on that context. For example:</p>
<pre><code class="language-hbs">{{! app/index/template.hbs }}
{{my-form submit=(action 'submit')}}
</code></pre>
<pre><code class="language-hbs">{{! app/components/my-form/template.hbs }}
{{my-button on-click=attrs.submit}}
</code></pre>
<pre><code class="language-hbs">{{! app/components/my-button/template.hbs }}
&lt;button&gt;&lt;/button&gt;
</code></pre>
<pre><code class="language-js">// app/components/my-button/component.js
export default Ember.Component.extend({
  click: function(){
    this.attrs['on-click']();
    // for backwards compat, you may also this.sendAction();
  }
});
</code></pre>
<p>A closure action can also be called by an action handler:</p>
<pre><code class="language-hbs">{{! app/index/template.hbs }}
{{my-form submit=(action 'submit')}}
</code></pre>
<pre><code class="language-hbs">{{! app/components/my-form/template.hbs }}
{{my-button on-click=submit}}
</code></pre>
<pre><code class="language-hbs">{{! app/components/my-button/template.hbs }}
&lt;button {{action on-click}}&gt;&lt;/button&gt;
</code></pre>
<p>Lastly, closure actions allow for yielding an action to a block. For example:</p>
<pre><code class="language-hbs">{{! app/index/template.hbs }}
{{my-form save=(action 'submit') as |submit reset|}}
  &lt;button {{action submit}}&gt;Save&lt;/button&gt;
  {{! ^ goes to my-form's save attr property, which
        is the submit action on the outer scope }}
  &lt;button {{action reset}}&gt;Reset&lt;/button&gt;
  {{! ^ goes to my-form }}
  &lt;button {{action &quot;cancel&quot;}}&gt;Cancel&lt;/button&gt;
  {{! ^ goes to outer scope }}
{{/my-form}}
</code></pre>
<pre><code class="language-hbs">{{! app/components/my-form/template.hbs }}
{{yield attrs.save (action 'reset')}}
</code></pre>
<pre><code class="language-js">// app/components/my-form/component.js
export default Ember.Component.extend({
  actions: {
    reset: function(){
      // rollback
    }
  }
});
</code></pre>
<a class="header" href="print.html#currying-arguments-with-a-closure-based-action" id="currying-arguments-with-a-closure-based-action"><h3>Currying arguments with a closure-based action</h3></a>
<p>With string-based actions, an argument can be passed to the called function. For
example:</p>
<pre><code class="language-hbs">&lt;button {{action &quot;save&quot; model}}&gt;&lt;/button&gt;
</code></pre>
<pre><code class="language-js">export default Ember.Component.extend({
  actions: {
    save: function(model) {
      model.save();
    }
  }
});
</code></pre>
<p>Closure actions allow for another opportunity to curry arguments. Arguments
set by an element action helper simply add to the end of the arguments list:</p>
<pre><code class="language-hbs">{{! app/index/template.hbs }}
{{my-component save=(action &quot;save&quot; model)}}
</code></pre>
<pre><code class="language-hbs">{{! app/components/my-component/template.hbs }}
&lt;button {{action attrs.save prefs}}&gt;&lt;/button&gt;
</code></pre>
<pre><code class="language-js">// app/index/controller.js
export default Ember.Controller.extend({
  actions: {
    save: function(model, prefs) {
      model.set('prefs', prefs);
      model.save();
    }
  }
});
</code></pre>
<p>Multiple arguments can be curried or set at any level. If an action is called ala
<code>this.attrs.save(additionalPrefs)</code>, that final argument is added
to the end of the arguments list.</p>
<a class="header" href="print.html#re-targeting-the-scope-of-a-closure-action" id="re-targeting-the-scope-of-a-closure-action"><h3>Re-targeting the scope of a closure action</h3></a>
<p>The <code>target</code> option may be provided to specify what scope the closure is called
with. For example:</p>
<pre><code class="language-hbs">{{! app/index/template.hbs }}
&lt;my-component on-click={{action &quot;save&quot; model target=someComponentInstance}}&gt;&lt;/my-component&gt;
</code></pre>
<p>Much like with the <code>{{action</code> helper, passing both a
target and a bound argument will throw.</p>
<p>The default target for a closure is always the current scope.</p>
<ul>
<li>When routable components land, the current component will be the default target.</li>
<li>If a controller is the current scope, that controller will also be a default target.</li>
<li>A route will <em>never</em> be a closure action target. String actions will continue
to have their current behavior of bubbling to the route.</li>
</ul>
<p>A later proposal will determine how actions on a route are passed to a routable
component.</p>
<a class="header" href="print.html#return-values-of-a-closure-action" id="return-values-of-a-closure-action"><h3>Return values of a closure action</h3></a>
<p>Closure actions return the returned value of their called function. For example:</p>
<pre><code class="language-js">// app/index/controller.js
export default Ember.Controller.extend({
  actions: {
    submit: function(){
      return 'great success';
    }
  }
});
</code></pre>
<pre><code class="language-hbs">{{! app/index/template.hbs }}
{{my-button save=(action 'submit')}}
</code></pre>
<pre><code class="language-js">// app/components/my-button/component.js
export default Ember.Component.extend({
  click: function(){
    var result = this.attrs.save();
    // for backwards compat, you may also this.sendAction('save') but
    // in that case you do not have access to the return value.
    result; // =&gt; 'great success'
  }
});
</code></pre>
<a class="header" href="print.html#actionable-object-with-invoke" id="actionable-object-with-invoke"><h3>Actionable object with INVOKE</h3></a>
<p><code>{{mut</code> is a new helper in Ember.js. It is not yet widely used in Ember apps, but its
interaction with the action helper is important to align early on.</p>
<p>Mut objects represent a modifiable value. For example with tag-based components:</p>
<pre><code class="language-hbs">{{! app/index/template.hbs }}
&lt;my-form name={{mut model.name}}&gt;&lt;/my-component&gt;
</code></pre>
<p>This will cause a mutable property to be added to <code>attrs</code>. To update the name,
<code>this.attrs.name.update(newName)</code> can be called. The value can be read (in
JavaScript) as <code>this.attrs.name.value</code>.</p>
<p>Often, a mutable value will be set as the result of an action. Mutable values
can be called actionable. For example:</p>
<pre><code class="language-hbs">{{! app/index/template.hbs }}
&lt;my-form submit={{action (mut model.name)}}&gt;&lt;/my-component&gt;
</code></pre>
<pre><code class="language-js">// app/components/my-form/component.js
export default Ember.Component.extend({
  click() {
    const value = this.get('newValue');
    this.attrs.submit(value);
  }
});
</code></pre>
<p>What is happening here?</p>
<ul>
<li><code>(mut model.name)</code> creates a mutable object for the <code>model.name</code> value.</li>
<li><code>{{action (mut model.name)}}</code> tests the passed object for a property with the
key <code>INVOKE</code> (an internal symbol). This value is a function that updates the mutable value.</li>
<li>Action wraps the calling of the <code>INVOKE</code> property in a function like any
other action, and passes it to the <code>attrs</code>.</li>
</ul>
<p>Thus, when the action is called the argument is passed to <code>INVOKE</code> which uses
it to update the mutable value. This is a simple way to enable the &quot;actions up&quot;
part of component-driven app architecture without ceremony around changing state.</p>
<a class="header" href="print.html#plucking-a-property-from-the-first-argument-with-value" id="plucking-a-property-from-the-first-argument-with-value"><h3>Plucking a property from the first argument with value</h3></a>
<p>A component (or when Ember supports this better, an element) may emit an event
object and pass it to an action. In this case the value will need to be read off
the event before it can be passed to the action function. For example:</p>
<pre><code class="language-hbs">{{input input=(action 'setName')}}
</code></pre>
<pre><code class="language-js">export default Ember.Component.extend({
  actions: {
    setName(event) {
      this.get('model').set('name', event.target.value);
    }
  }
});
</code></pre>
<p>The action serves only to read the value off of the event. Here the <code>value</code>
option can be used as sugar to accomplish the same task:</p>
<pre><code class="language-hbs">{{input input=(action (mut model.name) value=&quot;target.value&quot;)}}
</code></pre>
<p>The <code>value</code> path is read off of whatever the first argument to the actions is.</p>
<ul>
<li><code>(mut model.name)</code> becomes a function, our action</li>
<li>When the <code>input</code> event fires, the function is called with the event as the
first argument.</li>
<li>The first argument is re-written to the value of <code>event.target.value</code></li>
<li>The function wrapping the <code>mut</code> is set</li>
<li>The <code>mut</code> is updated.</li>
</ul>
<p>This option is designed to align with future plans for <code>on-some-event</code> handlers
for html elements.</p>
<a class="header" href="print.html#drawbacks-9" id="drawbacks-9"><h1>Drawbacks</h1></a>
<p>Currently <code>{{action</code> is only used in an element space:</p>
<pre><code class="language-hbs">&lt;button {{action &quot;booyah&quot;}}&gt;Fire&lt;/button&gt;
</code></pre>
<p>The closure usage is a new, perhaps <code>action</code> is not the right word. However the two
behaviors are pretty similar in their conceptual behavior.</p>
<ul>
<li><code>{{action</code> in element space attaches an event listener that fires a bubbling
action.</li>
<li><code>(action</code> closes over an action from the current scope so it can be attached
via <code>{{action</code> or passed around and called later.</li>
</ul>
<p>This confusion should go away as we move to an <code>on-click</code> event listener pattern,
ala <code>&lt;button on-click={{someClosureAction}}&gt;</code>.</p>
<p>Additionally, there may be developers who still have <code>{{action someActionName}}</code> instead
of the quoted version. This is long deprecated, but these apps may see some
unexpected behavior.</p>
<p>Also additionally, some emergent behaviors exist that may not be desired as real APIs. For example,
an action being a function means it can be passed directly to event handlers:</p>
<pre><code class="language-hbs">{{my-component mouseEnter=(action 'didEnter')}}
</code></pre>
<p>The actual API we plan for 2.0 (ideally) is:</p>
<pre><code class="language-hbs">{{my-component on-mouse-enter=(action 'didEnter')}}
</code></pre>
<p>These behaviors should not be documented, and we should make clear that they rely on behavior that
will be deprecated. A mitigating move is to <em>not</em> proxy actions through to
<code>get</code> on a component, and only allow them to be accessed on <code>attrs</code>.</p>
<p>Lastly, default actions may look a bit confusing:</p>
<pre><code class="language-hbs">{{my-button action=(action 'action')}}
{{! ^ this is valid }}
</code></pre>
<p>But the quoted string syntax is not being removed.</p>
<a class="header" href="print.html#alternatives-9" id="alternatives-9"><h1>Alternatives</h1></a>
<p>There is maybe a thing called <code>ref</code> that solves this same problem. There has also
been discussion of accessing properties on <code>outlet</code> across all child components
and their layouts, which would allow easy targetting of the top level component.</p>
<a class="header" href="print.html#unresolved-questions-7" id="unresolved-questions-7"><h1>Unresolved questions</h1></a>
<p>Interaction with <code>ref</code> or <code>outlet.</code> if any..</p>
<ul>
<li>Start Date: 2015-05-17</li>
<li>RFC PR: https://github.com/emberjs/rfcs/pull/53</li>
<li>Ember Issue: https://github.com/emberjs/ember.js/pull/11278</li>
</ul>
<a class="header" href="print.html#summary-10" id="summary-10"><h1>Summary</h1></a>
<p>Ember.js 1.13 will introduce a new API for helpers. Helpers will come in two
flavors:</p>
<p><strong>Helpers</strong> are a class-based way to define HTMLBars subexpressions. Helpers:</p>
<ul>
<li>Have a single return value.</li>
<li>Must have a dash in their name.</li>
<li>Cannot be used as a block (<code>{{#some-helper}}{{/some-helper}}</code>).</li>
<li>Can store and read state.</li>
<li>Have lifecycle hooks analogous to components where appropriate. For
example, a helper may call <code>recompute</code> at any time to generate a new
value (this is akin to <code>rerender</code>).</li>
<li>Are a superset of shorthand helpers, the function-based syntax described
below. They can do more, but in many cases a shorthand helper is appropriate.</li>
</ul>
<p><strong>Shorthand helpers</strong> are a function-based way to define HTMLBars
subexpressions. Helpers written this way:</p>
<ul>
<li>Have all the limitations of regular helpers.</li>
<li>Have no instance associated with them, cannot store or read state.</li>
<li>Have no lifecycle hooks. The function is simply re-computed when any input
changes.</li>
</ul>
<p>These improved helpers fill a gap in Ember's current template APIs:</p>
<table><thead><tr><th>                   </th><th> has positional params </th><th> has layout (shadow DOM) </th><th> can yield template </th><th> has lifecycle, instance </th><th> can control rerender </th></tr></thead><tbody>
<tr><td> components        </td><td> Yes                   </td><td> Yes                     </td><td> Yes                </td><td> Yes                     </td><td> Yes                  </td></tr>
<tr><td> helpers           </td><td> Yes                   </td><td> No                      </td><td> No                 </td><td> Yes                     </td><td> Yes                  </td></tr>
<tr><td> shorthand helpers </td><td> Yes                   </td><td> No                      </td><td> No                 </td><td> No                      </td><td> No                   </td></tr>
</tbody></table>
<p>An example helper:</p>
<pre><code class="language-js">// app/helpers/full-name.js
import Ember from &quot;ember&quot;;

export default Ember.Helper.extend({
  nameBuilder: Ember.inject.service(),
  compute(params) {
    const builder = this.get('nameBuilder');
    return builder.fullName(params[0], params[1]);
  }
});
</code></pre>
<p>An example shorthand helper:</p>
<pre><code class="language-js">// app/helpers/full-name.js
import Ember from &quot;ember&quot;;

export default Ember.Helper.helper(function(params, hash) {
  let fullName = params.join(' ');
  if (hash.honorific) {
    fullName = `${hash.honorific} ${fullName}`
  }
  return fullName;
});
</code></pre>
<p>Helpers can be used anywhere an HTMLBars subexpression is valid:</p>
<pre><code class="language-hbs">{{full-name 'Bigtime' 'Beagle'}}
{{input value=(full-name 'Gyro' 'Gearloose') readonly=true}}
{{#if (eq (full-name 'Webbigail' 'Vanderquack') selectedFullName))}}
  You have chosen wisely.
{{/if}}
</code></pre>
<a class="header" href="print.html#motivation-11" id="motivation-11"><h1>Motivation</h1></a>
<p>Ember.js 1.13 make a private API change that removed the ability to access
application containers. <code>Ember.HTMLBars._registerHelper</code> was previously passed
the <code>env</code> object, and this was removed as it is an internal implementation
detail.</p>
<p>Ember's helper API has not kept pace with improvements possible
after the introduction of HTMLBars. This has resulted in the community using
a variety of private APIs, many of which leak information about the outer
context of a helpers invocation as well as the render layer implementation.</p>
<p>The current public API is:</p>
<ul>
<li><a href="http://emberjs.com/api/classes/Ember.Handlebars.html#method_makeBoundHelper">Ember.Handlebars.makeBoundHelper</a></li>
</ul>
<p>This API is sorely lacking in functionality required by addon authors.</p>
<ul>
<li>Has no access to other parts of the app, like services</li>
<li>Leaks a private API for dealing with blocks</li>
<li>Results in less efficient helpers due to the Handlebars compatibility layer</li>
<li>Has poor support for hash arguments</li>
</ul>
<p>Additionally it remains difficult to write a helper that recomputes due to
something besides the change of its input.</p>
<p>Specifically, this RFC addresses many of the concerns in
<a href="https://github.com/emberjs/ember.js/issues/11080">emberjs/ember.js#11080</a>.
Libraries such as <a href="https://github.com/yahoo/ember-intl">yahoo/ember-intl</a>,
<a href="https://github.com/dockyard/ember-cli-i18n">dockyard/ember-cli-i18n</a>, and
<a href="https://github.com/minutebase/ember-can">minutebase/ember-can</a> will be
provided a viable public API to couple to.</p>
<a class="header" href="print.html#detailed-design-8" id="detailed-design-8"><h1>Detailed design</h1></a>
<p>Helpers must have a dash in their name. In an Ember-CLI app, they can be named
according to the <code>app/helpers/full-name.js</code> convention (<code>app/full-name/helper.js</code>
in pods mode). For a globals app, naming a helper <code>App.FullNameHelper</code> is
sufficient.</p>
<a class="header" href="print.html#definition-and-lifecycle" id="definition-and-lifecycle"><h3>Definition and lifecycle</h3></a>
<p>A helper is defined as a class inheriting from <code>Ember.Helper</code>. For
example:</p>
<pre><code class="language-js">// app/helpers/hello-world.js
import Ember from &quot;ember&quot;;

// Usage: {{hello-world}}
export default Ember.Helper.extend({
  compute() {
    return &quot;Hello Helper World&quot;;
  }
});
</code></pre>
<p>Upon initial render:</p>
<ul>
<li>The helper instance is created.</li>
<li>The <code>compute</code> method is called. The return value is outputted where the
helper is used. For example in <code>&lt;div class={{some-helper}}&gt;&lt;/div&gt;</code> the return
value is set to the class.</li>
</ul>
<p>The <code>compute</code> function is always called with <code>params</code> (the bare, ordered
arguments) and <code>hash</code> (the named arguments). For example:</p>
<pre><code class="language-js">// app/helpers/greet-someone.js
import Ember from &quot;ember&quot;;

// Usage: {{greet-someone 'bob' greeting='say hello'}}
export default Ember.Helper.extend({
  compute(params, hash) {
    return `Hello ${params[0]}, nice to ${hash.greeting}`;
  }
});
</code></pre>
<p>Which functions the same as this shorthand:</p>
<pre><code class="language-js">// app/helpers/greet-someone.js
import Ember from &quot;ember&quot;;

// Usage: {{greet-someone 'bob' greeting='say hello'}}
export default Ember.Helper.helper(function(params, hash) {
  return `Hello ${params[0]}, nice to ${hash.greeting}`;
});
</code></pre>
<p>When the <code>params</code> or <code>hash</code> contents change, the <code>compute</code> method is called
again. The instance of the helper is preserved across rerenders of the parent.
A shorthand helper, having no instance, is called every time a bound
argument changes.</p>
<p>The <code>init</code> and <code>destroy</code> methods can be subclassed for setup and teardown.</p>
<a class="header" href="print.html#consuming-a-helper" id="consuming-a-helper"><h3>Consuming a helper</h3></a>
<p>Helpers can be used anywhere an HTMLBars subexpression can be
used. For example:</p>
<pre><code class="language-hbs">{{#if (can-access 'admin')}}
  {{link-to 'login'}}
{{/if}}
{{#if (eq (can-access 'admin') false)}}
  No login for you
{{/if}}
&lt;my-login-button isAdmin={{can-access 'admin'}} /&gt;
Can access? {{can-access 'admin'}}
</code></pre>
<p>Passing a helper to a <code>{{</code>- invoked component skips the auto-<code>mut</code> behavior:</p>
<pre><code class="language-hbs">{{my-login-button isAdmin=(can-access 'admin')}}
</code></pre>
<p>Let's step through exactly what happens when using an helper like this:</p>
<pre><code class="language-hbs">&lt;my-login-button isAdmin={{can-access 'admin'}} /&gt;
</code></pre>
<p>Upon initial render:</p>
<ul>
<li>The helper <code>can-access</code> is looked up on the container</li>
<li>The helper is identified as a full helper, not a shorthand helper function</li>
<li>The helper is initialized (<code>init</code> is called)</li>
<li>The <code>compute</code> function is called on the helper.</li>
<li>The return value from <code>compute</code> is passed as an <code>attr</code> to <code>my-login-button</code>.</li>
<li>The helper instance remains in memory.</li>
</ul>
<p>If the parent scope is rerendered:</p>
<ul>
<li>The <code>compute</code> function is called again.</li>
<li>The return value from <code>compute</code> is passed as an <code>attr</code> to <code>my-login-button</code>.</li>
</ul>
<p>Upon teardown:</p>
<ul>
<li>The helper is destroyed, calling the <code>destroy</code> method.</li>
</ul>
<a class="header" href="print.html#returning-a-value" id="returning-a-value"><h3>Returning a value</h3></a>
<p>The return value of helper is passed through to where their subexpression
is called. For example, given a helper (this one a shorthand helper):</p>
<pre><code class="language-js">// app/helpers/full-name.js
import Ember from &quot;ember&quot;;

export default Ember.Helper.helper(function fullName(params, hash) {
  return params.join(' ');
}
</code></pre>
<p>The following are effectively the same:</p>
<pre><code class="language-hbs">&lt;div data-name={{full-name &quot;Fenton&quot; &quot;Crackshell&quot;}}&gt;&lt;/div&gt;
&lt;div data-name={{&quot;Fenton Crackshell&quot;}}&gt;&lt;/div&gt;
</code></pre>
<pre><code class="language-hbs">{{my-component name=(full-name &quot;Magica&quot; &quot;De Spell&quot;)}}
{{my-component name=&quot;Magica De Spell&quot;}}
</code></pre>
<pre><code class="language-hbs">&lt;p&gt;{{full-name &quot;Bentina&quot; &quot;Beakley&quot;}}&lt;/p&gt;
&lt;p&gt;{{&quot;Bentina Beakley&quot;}}&lt;/p&gt;
</code></pre>
<p>An exclusion to this pattern is the following form:</p>
<pre><code class="language-hbs">&lt;div {{full-name &quot;Webbigail&quot; &quot;Vanderquack&quot;}}&gt;&lt;/div&gt;
</code></pre>
<p>This is a legacy form of mustache usage. Helpers will throw an exception when
used in this manner.</p>
<a class="header" href="print.html#consuming-services-and-recompute" id="consuming-services-and-recompute"><h3>Consuming services and recompute</h3></a>
<p>Helpers are a valid target for service injection. For example:</p>
<pre><code class="language-js">// app/helpers/current-user-name.js
import Ember from &quot;ember&quot;;

export default Ember.Helper.extend({
  // Same API as components:
  session: Ember.inject.service(),
  compute() {
    return this.get('session.currentUser.name');
  }
});
</code></pre>
<p>However consuming a property from a service does not bind the data being
displayed to that property. After <code>{{current-user-name}}</code> has been computed
and rendered, it will never be invalidated.</p>
<p>For this reason, helpers are granted some control over their
computation lifecycle. A helper will recompute when:</p>
<ul>
<li>A value passed via the template changes (<code>params</code> or <code>hash</code>)</li>
<li>The <code>recompute</code> method is called</li>
</ul>
<p>For example, this helper checks if the current use has access to a
resource type:</p>
<pre><code class="language-js">// app/helpers/can-access.js
import Ember from &quot;ember&quot;;

// Usage {{if (can-access 'admin') 'Welcome, boss' 'Heck no!'}}
export default Ember.Helper.extend({
  session: Ember.inject.service(),
  onCurrentUserChange: Ember.observes('session.currentUser', function() {
    this.recompute();
  }),
  compute(params) {
    const currentUser = this.get('session.currentUser');
    return currentUser.can(params[0]);
  }
});
</code></pre>
<a class="header" href="print.html#drawbacks-10" id="drawbacks-10"><h1>Drawbacks</h1></a>
<p>Helpers may superficially appear similar to components, but in
practice they have none of the special behavior of components such as managing
DOM. The intent of this RFC is that full class-based helpers remain very close
to the spirit of a pure function (as in the shorthand). However, despite this
intent they are a new concept for the framework.</p>
<a class="header" href="print.html#alternatives-10" id="alternatives-10"><h1>Alternatives</h1></a>
<p>A <a href="https://github.com/emberjs/rfcs/pull/52">previous RFC</a> explored creating a new class called Expressions, which would have
more closely modeled the API of components (using positional params, attrs).
After discussion and consideration it was clear that a third kind of template
API would be very challenging to document and teach well.</p>
<a class="header" href="print.html#unresolved-questions-8" id="unresolved-questions-8"><h1>Unresolved questions</h1></a>
<p>Perhaps there should be hooks in place for the lifecycle, instead of relying on
<code>init</code> and <code>destroy</code>.</p>
<ul>
<li>Start Date: 2015-10-02</li>
<li>RFC PR: https://github.com/emberjs/rfcs/pull/56</li>
<li>Ember Issue: (leave this empty)</li>
</ul>
<a class="header" href="print.html#refining-the-release-process" id="refining-the-release-process"><h1>Refining the Release Process</h1></a>
<p>Ember balances a desire for overall stability with a desire for continued improvements using a two-pronged approach:</p>
<ul>
<li>General adherence to Semantic Versioning, which means that we don't
make breaking changes to public, documented APIs except when the
major version changes.</li>
<li>A rapid release cycle that allows us to ship additive changes to the
framework on a regular, digestible basis.</li>
</ul>
<p>Since Ember 1.0, we have refined this approach:</p>
<ul>
<li>All new public APIs are added using feature flags onto the master
branch. Feature flagged features are not included in beta or release
builds until they are &quot;Go&quot;ed by the core team.</li>
<li>We avoid breaking heavily used but private APIs in minor versions.</li>
<li>When we feel we must break a private API that is heavily used, we
use a two-step deprecation approach: deprecate the private API in
one release and remove it in a subsequent release, once apps and
add-ons have had an opportunity to upgrade.</li>
<li>When we plan to make breaking changes in a future major release,
we first deprecate the changes in a previous minor release.</li>
<li>We never deprecate features until there is an already-landed
transition path to a new approach whose feature flag has already
been &quot;Go&quot;ed.</li>
</ul>
<p>And finally:</p>
<ul>
<li>A major release does not introduce any new breaking changes that
were not previously deprecated. Major versions simply remove
deprecated features that already landed.</li>
</ul>
<p>Ember 2.0 is the first major release cycle where we have followed these refinements; this document is an attempt to outline some additional refinements that we might adopt going forward.</p>
<a class="header" href="print.html#benefits-of-the-1x-model" id="benefits-of-the-1x-model"><h2>Benefits of the 1.x Model</h2></a>
<ul>
<li>New features are added predictably, and it's relatively easy to
follow the list of new APIs that are under development, and where
they are in the process.</li>
<li>There is little pressure for contributors to land a feature
prematurely, because missing a release deadline isn't
catastrophicthere will be another train six weeks hence.</li>
<li>We have a lot of very good automation tools that keep the trains
runningcommits can be (mostly) automatically backported to the
current beta or release version.</li>
<li>Upgrading Ember itself from version to version is typically a quick
process, except when private APIs are in use. We aim for upgrades to
be possible to slot into existing product sprints, and the nature of
the process means that we tend to hit this goal for most users.</li>
<li>Upgrading Ember across a number of versions is typically pretty
straightforward, at least in theory.</li>
</ul>
<p>In total, this process provides a way for us to clearly message medium-term changes in a way that helps you make the changes predictably and as mechanically as possible.</p>
<p>The process of getting from <em>here</em> to <em>there</em> is a series of incremental releases with deprecations, which gives you a trail of breadcrumbs to follow as things change.</p>
<a class="header" href="print.html#problems-with-the-1x-model" id="problems-with-the-1x-model"><h2>Problems with the 1.x Model</h2></a>
<p>While the approach we're using has provided a lot of benefits, there are a number of areas that could still use improvement:</p>
<ul>
<li>While it is in theory possible to upgrade only once every few
releases, there is no guidance about exactly how to do that, and
little clarity about how many releases we plan to support with
security fixes. (Because of the two-step deprecations of heavily
used  private APIs, it is in practice important to go through each
intermediate release to clear deprecation warnings before
proceeding.)</li>
<li>While SemVer guarantees apply to public APIs, many addons are forced
to use private APIs as part of experiments. These experiments are a
crucial part of the evolution of the Ember ecosystem, and the Ember
1.x series has had a fair bit of churn in these APIs.</li>
<li>While the SemVer guarantees apply to Ember proper, they do not apply
to parts of the blessed experience that have not yet reached 1.0.</li>
<li>While the SemVer guarantees promise that your code will continue
working, they do not address changes to idiomatic Ember usage, which
can change over time. In practice, this means that there can be
churn in the experience of using Ember without actual breakages.</li>
<li>While deprecations technically don't force you to change anything,
in practice clearing deprecations is a part of the upgrade process.
A constant stream of deprecations, like in the lead-up to Ember 2.0,
can feel almost as bad as breaking changes.</li>
<li>In the lead-up to Ember 2.0, a desire to remove as much cruft as
quickly as possible led to a need to land new features with much
more urgency than usual.</li>
</ul>
<p>In total, these problems introduce churn in the experience of using Ember. In practice, things like moving to ES6 modules, moving to Ember CLI, and the changes in Ember Data have made the experience of &quot;keeping up&quot; more frenetic than we would have liked.</p>
<p>Because Ember releases a new version every six-weeks, it's easy to associate the overall churn with the rapid pace of releases.</p>
<a class="header" href="print.html#non-goals-of-the-improvements" id="non-goals-of-the-improvements"><h2>Non-Goals of the Improvements</h2></a>
<p>The release process does not attempt to change the overall pace of change, but rather to make changes more predictable, easy to track, and easy to upgrade to.</p>
<p>The six-week cycle can incidentally affect the pace of change, because it means that large changes usually need to be broken up into pieces that can land a bit at a time. However, in practice this speeds up ecosystem-wide adoption of the entire feature, because people do not find themselves stuck behind a big-bang change that they can't schedule the time to upgrade to.</p>
<p>A recent survey of the Ember ecosystem, which had close to 1,000 respondents, showed that the vast majority of Ember users are using one of the past three versions of Ember.</p>
<a class="header" href="print.html#proposal-lts-releases" id="proposal-lts-releases"><h2>Proposal: LTS Releases</h2></a>
<p>In theory, it's possible to upgrade every few releases, instead of every release. This has a few drawbacks:</p>
<ul>
<li>Because of the two-step deprecation process for heavily-used
private APIs that we want to remove, it is in practice necessary
to go through all intermediate releases in order to catch possible
deprecations.</li>
<li>We currently don't have any official policy about which exact
releases we backport security patches to, other than a promise
that we will always backport to the previous released version.</li>
<li>Since different people upgrade at different rates, it's hard for
add-ons and other parts of the Ember ecosystem that are not
bound by the same SemVer guarantees to know which versions to
continue to support.</li>
</ul>
<p><strong>I propose that every 4 releases is considered a &quot;Long-Term-Support (LTS) release&quot; . With the six-week cycle, that means every 24 weeks, or roughly twice per year.</strong></p>
<p>This means:</p>
<ul>
<li>We will only remove heavily used private APIs if they were
deprecated in a previous LTS release. This means that
if a feature is deprecated in 2.3, the first LTS release that
the deprecation will appear in is 2.4, and it can therefore be
removed in 2.5.</li>
<li>We will provide release notes for each LTS release that
roll up the changes for the releases it includes, including new
deprecations and new features.</li>
<li>We will use the LTS releases to provide better big-picture
messaging on the goals of any deprecations and changes to
idiomatic Ember.</li>
<li>Security fixes will always be backported to the most recent
LTS release.</li>
<li>We will encourage the Ember ecosystem to maintain support for
the LTS releases, and lead by example with our own
projects that have not yet reached SemVer stability. Ideally, this
will give more of a voice to people who are upgrading less
frequently.</li>
</ul>
<p>This means that people who want to stay on the latest and greatest can continue to upgrade every six weeks (with the same SemVer guarantees we've come to expect), and people who want to upgrade less frequently can do so.</p>
<p>In practice, since these releases still abide by SemVer, upgrading from LTS release to LTS release should not be significantly more work than upgrading along the six-week release cycle.</p>
<p>Upgrading less frequently will mean, of course, that you would need to wait to take advantage of new features, and experience less gradual changes to idioms. It will also mean that every upgrade will come with a bigger bundle of deprecations to clear.</p>
<blockquote>
<p>It is important for us to keep an eye on the situation to see whether less frequent updates result in people getting left behind.</p>
</blockquote>
<a class="header" href="print.html#proposal-svelte-releases-and-major-releases" id="proposal-svelte-releases-and-major-releases"><h2>Proposal: Svelte Releases and Major Releases</h2></a>
<p>Another problem worth addressing is that, as Ember gradually deprecates old idioms to make way for new ones, SemVer guarantees require that we continue shipping deprecated features until the next major release.</p>
<p>This has two related problems:</p>
<ol>
<li>Ember users who are not using deprecated features need to continue
shipping deprecated code, which increases both code bloat and
an opportunity to accidentally slip back into older idioms.</li>
<li>Ember itself needs to continue maintaining support for
deprecated features in its internals, which, over time, results
in cruft that impacts our ability to improve Ember.</li>
</ol>
<p>However, we also need to be cognizant of the fact that changes to Ember idioms take time to be reflected in online materials, so it's important for snippets copy-and-pasted from tutorials to continue to produce deprecation notices for some time.</p>
<p>In general, this is the question of how to &quot;garbage collect&quot; cruft in the framework gradually and with minimal impact.</p>
<p>Leading up to the 2.0 release, we thought we would address this issue with periodic &quot;cruft removal&quot; major releases. Every so often, we would issue a major release with the primary purpose of clearing out accumulated cruft. Minor releases could create deprecations, but not purge their associated code.</p>
<p>Unfortunately, because of the fact that <strong>Ember does not generally deprecate features without a clear transition to something else</strong>, this meant that the 2.0 release became a critical release for adding new features as well. In the run-up to 2.0, we felt a higher degree of urgency to add new features in the programming model to replace ones we expected to want to remove early in the 2.x series.</p>
<p>The goal of the train release model is to eliminate big-bang releases and the attendant stress on releasing particular features by a given date, and the 2.0 release has been far too disruptive to that goal.</p>
<p>In the 2.x cycle, I propose a few enhancements:</p>
<ol>
<li>Ember itself will more clearly mark deprecated features in a
similar way that it marks new features, including with the
release it was deprecated in.</li>
<li>Ember CLI will support &quot;svelte builds&quot;, which strip out
deprecated features.</li>
<li>In development mode, Ember CLI will convert deprecated features
into errors, to ensure that people running svelte builds can still
get clear messages when using code that was designed for earlier
builds, including addons.</li>
<li>We will still use major releases to remove built up cruft,
especially deeply intertwined cruft, but the svelte releases
should take the pressure off of the major release timeline.</li>
</ol>
<p><strong>The 1.x release cycle helped us establish an orderly process for adding features; this proposal establishes a more orderly process for removing them.</strong></p>
<a class="header" href="print.html#proposal-plugin-apis" id="proposal-plugin-apis"><h2>Proposal: Plugin APIs</h2></a>
<p>Since the release of Ember 1.0, we have worked on refining the public APIs while maintaining stability. However, those public APIs do not cover all possible use-cases, and add-ons have cropped up to fill the gaps.</p>
<p>Unfortunately, this has placed a heavy compatibility burden on add-on authors who want to maintain stability in their public APIs even as versions of Ember have changed the private APIs they rely on.</p>
<p>In practice, the costs of the six-week release cycle weigh most heavily on add-on authors, who are often forced into using private APIs, but still want to keep their add-ons working with every release.</p>
<p>The canary and beta cycles help to ensure that popular add-ons work by the time the release version comes out, but only because add-on authors keep a close eye on the beta releases and absorb the churn on behalf of their users.</p>
<p><strong>I propose that as of Ember 2.0, any use of a private API in a plugin is considered a bug in Ember to be fixed.</strong></p>
<p>That doesn't mean that add-on authors should never use private APIs: to the contrary, use of private APIs when no other choice is available helps us discover what APIs are missing.</p>
<p>But a major goal of the 2.x series of Ember should be to identify ways to extend the stability promises that Ember offers to application authors to add-on authors.</p>
<ul>
<li>Start Date: 2015-05-20</li>
<li>RFC PR: https://github.com/emberjs/rfcs/pull/57</li>
<li>Ember Issue: https://github.com/emberjs/data/pull/3303</li>
</ul>
<a class="header" href="print.html#summary-11" id="summary-11"><h1>Summary</h1></a>
<p>This RFC adds a unified way to perform meta-operations on records, has-many relationships and belongs-to relationships:</p>
<ul>
<li>get the current local data synchronously without triggering a fetch or producing a promise</li>
<li>notify the store that a fetch for a given record has begun, and provide a promise for its result</li>
<li>similarly, notify a record that a fetch for a given relationship has begun, and provide a promise for its result</li>
<li>retrieve server-provided metadata about a record or relationship</li>
</ul>
<a class="header" href="print.html#motivation-12" id="motivation-12"><h1>Motivation</h1></a>
<p>When we initially designed the Ember Data API for relationships, we focused on consumption and mutation of the relationship data. For example, you can retrieve the value of a <code>belongsTo</code> relationship via <code>get('post')</code>, or adding new records to a has-many relationship via <code>get('comments').pushObject(newComment)</code>.</p>
<p>The top-level reading operations are designed to be <a href="http://blog.izs.me/post/59142742143/designing-apis-for-asynchrony">zalgo</a>-proof: regardless of whether or not the record or relationship has been loaded already, you get back a promise for the result. Behind the scenes, this will trigger a fetch if needed, or simply return the current value if it has already been fetched. From a programming model perspective, this simplifies your code because you can handle locally-available data and remotely-available data in a single code path.</p>
<p>However, in sophisticated applications, there is often a need to refer to a record without triggering side effects.</p>
<p>For example, you may want to initiate the fetch for a record or relationship yourself, and provide Ember Data with a promise representing the result of that fetch. That use-case is supported by the <code>store.push</code> API, but it has a few problems:</p>
<ul>
<li>The <code>store.push</code> API supports pushing data once the fetch has completed, but no way of telling
Ember Data that a fetch has begun. As a result, any calls to <code>store.find</code> in the interim will
trigger unnecessary fetches.</li>
<li>The <code>store.push</code> API works only for top-level records with already-known types and IDs. It does
not support any way of &quot;feeding&quot; the data for a relationship to Ember Data.</li>
</ul>
<p>In sum, this makes it difficult to front-load work (especially asynchronous work). Instead, Ember Data is currently optimized for reacting to requests from the application layer, which is sometimes a very awkward way of structuring your code.</p>
<p>Second, Ember Data was originally designed with APIs that refer to data and operations on data. Over time, we have come to realize that people quite often need to look at metadata about records or relationships, as well as perform meta-operations on them.</p>
<p>Some examples:</p>
<ul>
<li>getting the expected count of a has-many relationship before it has been fetched</li>
<li>learning whether a relationship is already loaded or not</li>
<li>examining server-sent metadata</li>
<li>working with pages of records in a has-many relationship, especially when pages are loaded asynchronously (&quot;pagination&quot;)</li>
</ul>
<p>Third, because has-many relationships are represented as a <code>RecordArray</code>, we have been able to kludge around some of these issues by adding meta-operations to the has-many relationship itself. In contrast, belongs-to relationships have remained anemic. For example, there is no way to trigger a reload of a belongs-to relationship, whereas has-many relationships can be reloaded by calling <code>.reload()</code> on the <code>RecordArray</code>.</p>
<a class="header" href="print.html#detailed-design-9" id="detailed-design-9"><h1>Detailed design</h1></a>
<p>This RFC proposes the addition of three new <strong>public</strong> APIs:</p>
<ul>
<li><code>RecordReference</code></li>
<li><code>HasManyReference</code></li>
<li><code>BelongsToReference</code></li>
</ul>
<a class="header" href="print.html#getting-references" id="getting-references"><h2>Getting References</h2></a>
<ul>
<li><code>store.getReference(type, id)</code></li>
<li><code>record.getReference(name)</code></li>
</ul>
<a class="header" href="print.html#references" id="references"><h2>References</h2></a>
<a class="header" href="print.html#push" id="push"><h3><code>push</code></h3></a>
<pre><code class="language-js">/**
  This API allows you to provide a reference with new data. The simplest usage
  of this API is similar to `store.push`: you provide a normalized hash of data
  and the object represented by the reference will update.

  If you pass a promise to `push`, Ember Data will not ask the adapter for the
  data if another attempt to fetch it is made in the interim. When the promise
  resolves, the underlying object is updated with the new data, and the promise
  returned by *this function* is resolved with that object.

  For example, `recordReference.push(promise)` will be resolved with a record.

  @method
  @param {Promise|Object}
  @returns Promise&lt;T&gt; a promise for the value (record or relationship)
*/
</code></pre>
<a class="header" href="print.html#pushpayload" id="pushpayload"><h3><code>pushPayload</code></h3></a>
<pre><code class="language-js">/**
  This API is similar to `push`, but it invokes the serializer with the
  resolved data. This makes it possible to share normalization logic
  across multiple calls to `pushPayload` or between proactive pushes
  and reactive responses from the adapter.

  @method
  @param {Promise|Object}
  @returns Promise&lt;T&gt; a promise for the value (record or relationship)
*/
</code></pre>
<a class="header" href="print.html#state" id="state"><h3><code>state</code></h3></a>
<pre><code class="language-js">/**
  The current state of the entity, based on the semantics of the
  entity in question. For records, this should expose a subset of
  the named states in the internal state machine.

  @property
  @type String
*/
</code></pre>
<a class="header" href="print.html#value" id="value"><h3><code>value</code></h3></a>
<pre><code class="language-js">/**
  If the entity referred to by the reference is already loaded, it
  is present as `reference.value`. Otherwise, the value of this
  property is `null`.

  @property
*/
</code></pre>
<a class="header" href="print.html#data" id="data"><h3><code>data</code></h3></a>
<pre><code class="language-js">/**
  The value of the (normalized) representation of this entity. For
  example, `recordReference.data` will return a normalized dictionary
  of attributes and links.

  @property
*/
</code></pre>
<a class="header" href="print.html#metadata" id="metadata"><h3><code>metadata</code></h3></a>
<pre><code class="language-js">/**
  The most recent value of the metadata returned by the server for
  the value represented by this reference.

  @property
*/
</code></pre>
<a class="header" href="print.html#load" id="load"><h3><code>load</code></h3></a>
<pre><code class="language-js">/**
  Triggers a fetch for the backing entity based on its `remoteType`
  (see `remoteType` definitions per reference type).

  @method
  @param {Object} an options hash, similar to the one currently
    passed to `store.find`.
*/
</code></pre>
<a class="header" href="print.html#unload" id="unload"><h3><code>unload</code></h3></a>
<pre><code class="language-js">/**
  Unload the entity referred to by this relationship. After this
  operation, its `value`, `data` and `metadata` members will return
  to `null`, and the record itself will be purged from the identity
  map.

  @method
*/
</code></pre>
<a class="header" href="print.html#recordreference" id="recordreference"><h2>RecordReference</h2></a>
<a class="header" href="print.html#remotetype" id="remotetype"><h3><code>remoteType</code></h3></a>
<pre><code class="language-js">/**
  How the reference will be looked up with it is loaded:

  * `link`, a URL
  * `identity`, by the `type` and `id`
*/
</code></pre>
<a class="header" href="print.html#type" id="type"><h3><code>type</code></h3></a>
<pre><code class="language-js">/**
  The type of the record that this reference refers to.

  @property
*/
</code></pre>
<a class="header" href="print.html#id" id="id"><h3><code>id</code></h3></a>
<pre><code class="language-js">/**
  The `id` of the record that this reference refers to.

  Together, the `type` and `id` properties form a composite key
  for the identity map.

  @property
*/
</code></pre>
<a class="header" href="print.html#hasmanyreference" id="hasmanyreference"><h2>HasManyReference</h2></a>
<a class="header" href="print.html#remotetype-1" id="remotetype-1"><h3><code>remoteType</code></h3></a>
<pre><code class="language-js">/**
  How the reference will be looked up when it is fetched:

  * `link`, a URL provided by the server
  * `ids`, a list of IDs provided by the server
  * `dynamic`, a dynamic URL will be created based on the identity
    of the parent.

  @property
*/
</code></pre>
<a class="header" href="print.html#link" id="link"><h3><code>link</code></h3></a>
<pre><code class="language-js">/**
  If the `remoteType` is `link`, the URL to use to load the relationship.

  @property
*/
</code></pre>
<a class="header" href="print.html#ids" id="ids"><h3><code>ids</code></h3></a>
<pre><code class="language-js">/**
  If the `remoteType` is `ids`, a list of IDs that is used to formulate
  the query to the server (together with `type`).

  @property
*/
</code></pre>
<a class="header" href="print.html#type-1" id="type-1"><h3><code>type</code></h3></a>
<pre><code>/**
  The model type represented by this relationship.

  @property
*/
</code></pre>
<a class="header" href="print.html#parent" id="parent"><h3><code>parent</code></h3></a>
<pre><code class="language-js">/**
  A reference to the record that has this `hasMany` on it.

  @property
*/
</code></pre>
<a class="header" href="print.html#inverse" id="inverse"><h3><code>inverse</code></h3></a>
<pre><code class="language-js">/**
  If there is an inverse relationship, this property is a reference
  to it.

  @property
*/
</code></pre>
<a class="header" href="print.html#belongstoreference" id="belongstoreference"><h2>BelongsToReference</h2></a>
<a class="header" href="print.html#remotetype-2" id="remotetype-2"><h3><code>remoteType</code></h3></a>
<pre><code class="language-js">/**
  How the reference will be looked up when it is fetched:

  * `link`, a URL provided by the server
  * `id`, an ID to use to form the URL
  * `dynamic`, a dynamic URL will be created based on the identity
    of the parent.

  @property
*/
</code></pre>
<a class="header" href="print.html#link-1" id="link-1"><h3><code>link</code></h3></a>
<pre><code class="language-js">/**
  If the `remoteType` is `link`, the URL to use to load the relationship.

  @property
*/
</code></pre>
<a class="header" href="print.html#ids-1" id="ids-1"><h3><code>ids</code></h3></a>
<pre><code class="language-js">/**
  If the `remoteType` is `id`, an ID that is used to formulate
  the query to the server (together with `type`).

  @property
*/
</code></pre>
<a class="header" href="print.html#type-2" id="type-2"><h3><code>type</code></h3></a>
<pre><code>/**
  The model type represented by this relationship.

  @property
*/
</code></pre>
<a class="header" href="print.html#parent-1" id="parent-1"><h3><code>parent</code></h3></a>
<pre><code class="language-js">/**
  A reference to the record that has this `belongsTo` on it.

  @property
*/
</code></pre>
<a class="header" href="print.html#inverse-1" id="inverse-1"><h3><code>inverse</code></h3></a>
<pre><code class="language-js">/**
  If there is an inverse relationship, this property is a reference
  to it.

  @property
*/
</code></pre>
<a class="header" href="print.html#drawbacks-11" id="drawbacks-11"><h1>Drawbacks</h1></a>
<p>The main drawback to this proposal is that it adds significant surface area to Ember Data, which could easily be perceived as significant additional complexity. However, we believe that the unification of the various entities in Ember Data, as well as exposing internal tools that were previously only available to the store, will actually reduce the complexity of many common patterns.</p>
<a class="header" href="print.html#alternatives-11" id="alternatives-11"><h1>Alternatives</h1></a>
<p>The main alternative is to address each use case with a new API:</p>
<ul>
<li><code>store.peek(record, id)</code>, <code>record.peek(relationship)</code> to retrieve the current value of the relationship only if it was loaded</li>
<li>extend <code>store.push</code> and <code>store.pushPayload</code> to take promises</li>
<li>APIs like <code>record.inverseFor(relationship)</code>, <code>record.typeFor(relationship)</code>, etc.</li>
<li>APIs like <code>record.idsFor(relationship)</code>, <code>record.metadataFor(relationship)</code>, and <code>store.metadataFor(type, id)</code></li>
</ul>
<p>We believe that the cumulative overhead of all of these APIs is far more than the overhead of the reference APIs.</p>
<a class="header" href="print.html#unresolved-questions-9" id="unresolved-questions-9"><h1>Unresolved questions</h1></a>
<p>Is there a need to represent &quot;prefetch metadata&quot; separately? This is metadata that the app knows about before fetch, and which it would want to persist through an <code>unload()</code> operation (along with identity information like type, id and link).</p>
<ul>
<li>Start Date: 2015-05-24</li>
<li>RFC PR: https://github.com/emberjs/rfcs/pull/58</li>
<li>Ember Issue: https://github.com/emberjs/ember.js/pull/11393</li>
</ul>
<a class="header" href="print.html#summary-12" id="summary-12"><h1>Summary</h1></a>
<p>This RFC outlines a new strategy for the registration of helpers in Ember 1.13.
In previous versions of Ember, helper lookup was a two-phase process of:</p>
<ul>
<li>Look in a whitelist of registered helpers. If in the whitelist, resolve that
path in the container.</li>
<li>If the path has a dash, try to resolve it in the container</li>
<li>If the container does not have a factory for this path, treat the path as a
bound value.</li>
</ul>
<p>This logic runs for every <code>{{somePath}}</code> in an Ember application.</p>
<p>This proposal attempts to simplify and unify that logic in a a single pass
against a whitelist, thus removing the special behavior of dashed paths.
Additionally, it attempts to design a solution that removes the current
<code>registerHelper</code> ceremony for undashed helpers.</p>
<a class="header" href="print.html#motivation-13" id="motivation-13"><h1>Motivation</h1></a>
<p>In <a href="https://github.com/emberjs/rfcs/pull/53">RFC #53</a> a new API for helpers is
outlined. This RFC presumes helpers will continue to have the naming
requirement of including a dash character.</p>
<p>The dash requirement for helpers exists for two reasons:</p>
<ul>
<li>For every <code>{{path}}</code> in an Ember application, it must be decided if that path
is a bound value, component, or helper. Component and helper lookup (the
discovery of a class or template) is lazy in Ember, thus for every <code>{{path}}</code>
a lookup for that string in the container is required. Container lookups
(the first time) are fairly slow, and performing this lookup for every
path may significantly impact initial render time. Thus, helpers are either
added to a whitelist (with <code>registerHelper</code>) or require a way to differentiate
themselves from the majority of data-binding cases (the dash).</li>
<li>In Ember 1.x, components were treated as helpers for certain code paths. This
made the dash requirement for components a natural extension to helpers.</li>
</ul>
<p>The Glimmer engine has removed some of these concerns and limitations.</p>
<p>Addon authors and app authors have both felt a need for non-dashed helper
names, for example <code>{{t 'some-string-to-translate'}}</code>. New developers to Ember
often find the dash requirement arbitrary and the <code>registerHelper</code> work around
difficult to understand and use.</p>
<p>For the new helper API to provide feature parity with APIs available to addon
authors in 1.12, a path to dashless helpers must be present in 1.13.</p>
<p>Given that a solution exists that addresses the performance concern, dropping
the dash requirement would resolve a significant amount of developer pain and
confusion.</p>
<a class="header" href="print.html#detailed-design-10" id="detailed-design-10"><h1>Detailed design</h1></a>
<p>At application boot, all known helper items (according to the resolver) are
iterated and added to a <code>helper-listing</code> service. This service is merely a
Set object with the names of all helpers.</p>
<p>When handling a <code>{{path}}</code>, the <code>helper-listing</code> service is consulted for the
presence of that <code>path</code>. If it is present, the path is looked up
on the container as a helper and the helper is used. Dashed paths are treated
no differently than any other path (for helpers).</p>
<a class="header" href="print.html#boot-time-discovery" id="boot-time-discovery"><h3>Boot time discovery</h3></a>
<p>To discover what paths may be helpers in Ember-CLI, the module names are
iterated. For example:</p>
<pre><code>not helper: app/components/foo-bar/component
not helper: app/controllers/foo-bar
not helper: app/foo-bar/route
helper &quot;t&quot;: app/t/helper
helper &quot;t&quot;: app/helpers/t
helper &quot;foo-bar&quot;: app/helpers/foo-bar
helper &quot;foo/bar&quot;: app/helpers/foo/bar
</code></pre>
<p>In a globals-mode application, The app namespace is iterated:</p>
<pre><code>not helper: App.FooBarComponent
not helper: App.FooBarController
not helper: App.FooBarRoute
helper &quot;t&quot;: App.THelper
helper &quot;foo-bar&quot;: App.FooBarHelper &lt;- should dasherize
</code></pre>
<p>In both cases <strong>the resolver is responsible for providing a list of modules
by type</strong>. The proposed API is <code>eachOfType</code>, here with Ember-CLI as an example:</p>
<pre><code class="language-js">// Given helperListing as a Set:
resolver.eachOfType(helper, function(parsedName, item) {
  helperListing.add(parsedName.fullName);
})
</code></pre>
<p>In Ember-CLI, the <code>app/</code> tree of an addon is merged with the app tree of an
application. This means for a helper like <code>t</code> to be discovered, nothing besides
adding it to <code>app/helpers/t.js</code> must be done.</p>
<p>In 1.13, this will impact existing apps by discovering all helpers regardless
of if <code>registerHelper</code> has been called. This is a small behavior change that
should match intent, and will not impact sanely written apps.</p>
<p>Note that only the path of the helper is added to the listing. During discovery,
the helper is not looked up from the container, instead lookup still occurs
at render time.</p>
<p>The helper listing is intended to be a private service in Ember, and will be
registered at <code>services:-helper-listing</code>. If the discovery semantics described
here are not sufficient for some edge-cases, wrapping this service in a
public API on application instances may be required.</p>
<a class="header" href="print.html#render-time-lookup-and-use" id="render-time-lookup-and-use"><h3>Render-time lookup and use</h3></a>
<p>Let us consider how a path is rendered. For example:</p>
<pre><code class="language-hbs">{{date}}
</code></pre>
<ul>
<li>The <code>service:-helper-listing</code> service is fetched</li>
<li>The path <code>date</code> is checked for on the listing: <code>helperListing.has(path)</code></li>
<li>If the path is not in the listing, <code>date</code> is treated like a bound value</li>
<li>If the path is in the listing, the helper is looked up from Ember's
container as <code>helper:date</code></li>
<li>depending on the instance returned from the factory (a helper, shorthand
helper, or legacy <code>Ember.Handlebars</code> or <code>Ember.HTMLBars._registerHelper</code>
helper) the proper invocation for that helper is executed</li>
</ul>
<p>Every rendered path will hit the <code>helper-listing</code> service, but the check
against a well-implemented Set should be inexpensive.</p>
<a class="header" href="print.html#drawbacks-12" id="drawbacks-12"><h1>Drawbacks</h1></a>
<p>Removing the dash requirement will likely result in a larger number of naming
conflicts between addons and apps than has existed before now. In general,
encouraging verbose helper names may mitigate this concern. Long term, there
have been several discussions to date about how to implement namespaces in
Ember templates and for Ember engines.</p>
<p>That the helper listing is eagerly discovered at application boot time may
impact the design of Ember engines and lazy-loading parts of an app. The
discovery cache may need to be flushed and re-generated, however this limitation
already exists for the container lookup itself (which caches failures).</p>
<p>That the helper listing is not based on the container means helpers registered,
but not added to the listing because of non-standard naming, may need to
manually register against the private helper listing API.</p>
<a class="header" href="print.html#alternatives-12" id="alternatives-12"><h1>Alternatives</h1></a>
<p>Instead of a new across-the-board solution, Ember could continue to use a
<code>registerHelper</code> pattern very similar to what exists today. This would
perpetuate the existing pain, but would perhaps be more similar to what devs
already know.</p>
<a class="header" href="print.html#unresolved-questions-10" id="unresolved-questions-10"><h1>Unresolved questions</h1></a>
<p>The exact timing of helper discovery in Ember-CLI and globals mode has not been
decided.</p>
<ul>
<li>Start Date: 2015-06-03</li>
<li>RFC PR: https://github.com/emberjs/rfcs/pull/61</li>
<li>Ember Issue: This RFC is implemented over many Ember Data PRs</li>
</ul>
<a class="header" href="print.html#summary-13" id="summary-13"><h1>Summary</h1></a>
<p>This RFC proposes new methods on the adapter to signal to the Ember Data store when it should re-request a record that is already cached in the store. It also proposes a new adapter options object that can be used by to provide instructions to the adapter from the place where the store's find method is called.</p>
<a class="header" href="print.html#motivation-14" id="motivation-14"><h1>Motivation</h1></a>
<a class="header" href="print.html#use-cases" id="use-cases"><h2>Use Cases</h2></a>
<p>When it comes to fetching records, there are several different behaviors
that users may expect. The behavior that users expect is influenced by
unique quirks in their data model, pre-existing expectations based on
traditional development models, and implementation details of their
adapter.</p>
<p>Fundamentally, users may expect or want one of the following sets of
behavior when fetching a model for the <code>model()</code> hook:</p>
<ul>
<li>Fetching data from the server the first time a record is requested,
but using only cached data subsequent times the route is entered.
(This is the current behavior of <code>find()</code>.)</li>
<li>Fetching new data every time the route is entered. The route will
&quot;block&quot; (show a loading spinner) until fresh data is received.</li>
<li>Using local data if available, but otherwise not triggering any
fetches if the data is not available. This is useful if records will
be pushed into the store ahead of time, e.g. by a socket, and
non-existence in the store means non-existence on the server.</li>
<li>Immediately returning a model with local data if available, rendering
the route's template immediately, and updating the record in the
background. If the record changes after conferring with the server,
the template is re-rendered.</li>
</ul>
<a class="header" href="print.html#discussion" id="discussion"><h2>Discussion</h2></a>
<a class="header" href="print.html#fetch-only-on-initial-render" id="fetch-only-on-initial-render"><h3>Fetch Only On Initial Render</h3></a>
<p>In this model, the record data is fetched from the server the first time
a record with a given ID is requested. Subsequent requests (e.g. leaving
and re-entering the same route) use locally cached data. This is the
strategy used by the current <code>find()</code> method.</p>
<p>The advantage of this model is that it keeps conferring with the server
to a minimum. Once data is loaded, the client can render new routes with
the model data that it has cached, without a network roundtrip.</p>
<p>Additionally, in some data models, records are immutable. For example, on
Twitter, tweets never change. In an email app, emails cannot change once
they are sent. Asking the server for the most up-to-date version of an
immutable record is a waste of resources.</p>
<p>The downsides of this model are two-fold.</p>
<p>First, this model is surprising to new developers. When navigating
between pages, they expect the most up-to-date representation to be
fetched and displayed every time.</p>
<p>Second, even for developers who understand what is happening, it is very
easy for long-lived applications to accumulate stale information,
particularly if the model they are displaying updates frequently.
Developers must somehow disambiguate between the first time a model is
looked up, and allowing it to proceed, and detecting when a cached model
is being used and updating it manually.</p>
<a class="header" href="print.html#new-fetch-every-render" id="new-fetch-every-render"><h3>New Fetch Every Render</h3></a>
<p>The advantages of this model are that it most closely matches the mental
model for developers coming from server-rendered and jQuery backgrounds.
In that model, every time a new page is loaded, the most up-to-date
information is guaranteed to be displayed. Because each page navigation
triggers a fetch from the database, the only way for information to
become stale is for the user to stop navigating.</p>
<p>The downside of this model is that it eliminates many of the advantages
of client-side routing. In traditional client apps, data is stored
locally, and navigations use that local data. In this model, every page
transition is blocked awaiting a network response from the server. It's
a slight improvement in that the data should be much smaller than a full
HTML page, but it is often latency and not bandwidth that causes
slowdowns.</p>
<a class="header" href="print.html#never-fetch" id="never-fetch"><h3>Never Fetch</h3></a>
<p>While an edge case, many Ember Data users have requested the ability to
fetch a record out of the store only if it exists locally.</p>
<p>One use case is for stores that are optimistically populated via pushed
data from a socket. In that case, if the record doesn't exist in the
store, it means that it doesn't exist on the server.</p>
<p>For obvious reasons, this is an uncommon case for the majority of apps.
While we should support it, it should not be part of the happy path for
new developers.</p>
<a class="header" href="print.html#immediate-render-background-refresh" id="immediate-render-background-refresh"><h3>Immediate Render, Background Refresh</h3></a>
<p>In this model, the first time a record is requested, it blocks the
render and shows a loading spinner. On subsequent requests, the locally
cached data is displayed and the render happens immediately without
making the user wait.</p>
<p>However, in the background, the store also kicks off a request to the
adapter to update the record. When the new data comes in, the record is
updated, and if there have been changes to the record since the initial
render, the template is re-rendered with the new information.</p>
<p>This is the model that I believe strikes the best tradeoff among the
options available.</p>
<p>First, it preserves the speed of client-side navigation. Once data for a
record is cached, transitioning to any route that relies on it is nearly
instantaneous and has no network bottleneck.</p>
<p>Second, because it triggers a background update, even users who expect a
new fetch every time will not be surprised as, ideally after a few
milliseconds, the new data will arrive and be persisted into the DOM.</p>
<p>Third, in most applications, models are not changing frequently.  Most
of the time, the cached version in the Ember Data store will be
identical to the latest server revision. In those cases, there is no
point in making users stare at a loading spinner</p>
<p>Of course, there are several downsides to this model that we should keep
in mind. For immutable records, fetching a new version in the background
is wasteful of bandwidth and server capacity and we should allow
developers to opt out of this behavior.</p>
<p>A second related case is apps using a socket to subscribe to record
changes once a record is fetched. In those cases, fetching up-to-date
information on subsequent requests for the model is wasteful because
they have guaranteed that they will keep the model up-to-date via change
events from the server. In this case, we need a way for adapter authors
to signal that subsequent update requests for a record are a no-op.</p>
<p>Third, it may be an unpleasant user experience for new information to
pop in suddenly after the initial render, particularly for records that
frequently change in dramatic ways. In those instances, we should make
sure we give developers the tools to build UIs that can indicate to the
user that the information is being updated, perhaps by greying it out or
displaying a loading spinner.</p>
<a class="header" href="print.html#detailed-design-11" id="detailed-design-11"><h1>Detailed design</h1></a>
<a class="header" href="print.html#proposal" id="proposal"><h2>Proposal</h2></a>
<a class="header" href="print.html#new-adapter-methods" id="new-adapter-methods"><h3>New Adapter Methods.</h3></a>
<p><code>shouldRefetchRecord</code> is a new method on the adapter that will be called by the store to make initial decision whether to refetch the record form the adapter or return the cached record from the store. This could method could be used to implement caching logic (e.g. only refetch this record after the time specified in its cache expires token) or for improved offline support (e.g. always refetch unless there is no internet connection then use cached record).</p>
<p>This record would only be called if the record was already found in the store and is in the loaded state.</p>
<p>This method is only checked by <code>store.findById</code> and <code>store.findAll</code>. Methods with <code>fetch</code> in their name always refetch the record(s) from the adapter.</p>
<pre><code class="language-js">{
  /**
   `shouldRefetchRecord` returns true if the adapter determines the record is
   stale and should be refetch. It should return false if the record
   is not stale or some other condition indicates that a fetch should
   not happen at this time (e.g. loss of internet connection). 

   This method is synchronous.

   @method shouldRefetchRecord
   @param {DS.Store} store
   @param {DS.Model} record
   @param {Object} adapterOptions
   @return {Boolean}
   */
  shouldRefetchRecord: function(store, record, adapterOptions),
}
</code></pre>
<p>The method <code>shouldBackgroundUpdate</code> would be used by the store to make the decision to re-fetch the record after it has already been returned to the user. This would allow realtime adapter to opt out of the background fetch if the adapter is already subscribing to changes on the record.</p>
<pre><code class="language-js">{
  /**
   `shouldBackgroundUpdate` returns true if the store should re fetch a
   record in the store after returning it to the user to ensure the
   record has the most up to date data.
   
   This method is synchronous.

   @method shouldBackgroundUpdate
   @param {DS.Store} store
   @param {DS.Model} record
   @param {Object} adapterOptions
   @return {Boolean}
  */
  shouldBackgroundUpdate: function(store, record, adapterOptions),
}
</code></pre>
<p>In the next major version of Ember Data the recommend way of finding a record
will be:</p>
<pre><code class="language-js">this.store.findById('person', 1);
</code></pre>
<p>This will return a promise that:</p>
<ol>
<li>Waits to resolve until the data is fetched from the server, on the
initial request.</li>
<li>Resolves immediately with the locally cached request for subsequent
requests, but triggers a request to the server for the updated
version and updates the record in-place if there are changes.</li>
</ol>
<p>In terms of the above methods <code>shouldRefetchRecord</code> will always return <code>false</code> and <code>shouldBackgroundUpdate</code> will always return <code>true</code> in the default <code>RESTAdapter</code>.</p>
<p>The fundamental guarantee of <code>findById()/findAll()</code> when using the default <code>RESTAdapter</code> is:</p>
<blockquote>
<p>Give me the information you have available locally, then give me the
most up-to-date information as soon as possible.</p>
</blockquote>
<p>Currently, the <code>find()</code> method takes an optional third parameters that
is passed to the adapter. In this API, that data structure is moved to
a field in the new options hash:</p>
<pre><code class="language-js">this.store.findById('person', 1, {
  preload: { comment_id: 1 }
});
</code></pre>
<a class="header" href="print.html#isupdating-flag" id="isupdating-flag"><h3><code>isUpdating</code> Flag</h3></a>
<p>To assist developers in building UIs that communicate the state of
models to their users, we should provide a helper that allows developers
to show UI elements when a model is in the process of being updated via
<code>fetch()</code>.</p>
<p>I propose adding an <code>isUpdating</code> flag to models, which can be used to
conditionally show a spinner:</p>
<pre><code class="language-handlebars">&lt;h1&gt;{{post.title}}&lt;/h1&gt;
{{#if isUpdating post}}
  &lt;small&gt;Updating...&lt;/small&gt;
{{/if}}

&lt;p&gt;{{post.body}}&lt;/p&gt;
</code></pre>
<p>(Currently, only <code>RecordArray</code>s have an <code>isUpdating</code> flag.)</p>
<p>Models have an <code>isReloading</code> flag. This will be deprecated in favor of the new <code>isUpdating</code> flag.</p>
<a class="header" href="print.html#drawbacks-13" id="drawbacks-13"><h1>Drawbacks</h1></a>
<p>Why should we <em>not</em> do this?</p>
<p>After the record has been updated in the background Ember's Data binding will cause any views to automatically update with the latest changes. This can result an a surprising &quot;popping&quot; effect which is especially pronounced when the background fetch resolves quickly (The user sees an initial render with the stale data then a quick re-render with the fresh data).</p>
<a class="header" href="print.html#alternatives-13" id="alternatives-13"><h1>Alternatives</h1></a>
<p>What other designs have been considered? What is the impact of not doing this?</p>
<p>One alternate option could be for Ember Data to track an expires token on a model. This would allow Ember
Data to behave like a caching proxy when fetching. If the record is expired, fetch should block.
If the record is not expired it would return a resolve the record right away however still issue a
second request.</p>
<p>When used with backends that do not return an expires token. Ember Data would assume that the
record is stale (this could be configured on the adapter).</p>
<a class="header" href="print.html#unresolved-questions-11" id="unresolved-questions-11"><h1>Unresolved questions</h1></a>
<ul>
<li>Start Date: 2015-06-12</li>
<li>RFC PR: https://github.com/emberjs/rfcs/pull/64</li>
<li>Ember Issue: (leave this empty)</li>
</ul>
<a class="header" href="print.html#summary-14" id="summary-14"><h1>Summary</h1></a>
<p>The goal of this RFC is to allow for better component composition and the
usage of components for domain specific languages.</p>
<p>Ember components can be invoked three ways:</p>
<ul>
<li><code>{{a-component</code></li>
<li><code>{{component someBoundComponentName</code></li>
<li><code>&lt;a-component</code> (coming soon!)</li>
</ul>
<p>In all these cases, attrs passed to the component must be set at the place of
invocation. Only the <code>{{component someBoundComponentName</code> syntax allows for the name
of the component invoked to be decided elsewhere.</p>
<p>All component names are resolved to components through one global resolution
path.</p>
<p>To improve composition, four changes are proposed:</p>
<ul>
<li>The <code>(component</code> helper will be introduced to close over component attrs in
a yielding context.</li>
<li>The <code>{{component</code> helper will accept an argument of the object created by
<code>(component</code> for invocation (as it invokes strings today).</li>
<li>Property lookups with a value containing a dot will be considered for
rendering as components. <code>{{form.input}}</code> would be considered, for instance.
Helper invocations with a dot will also be treated like a component if the
key has a value of a component, for instance <code>{{form.input value=baz}}</code>.</li>
<li>A <code>(hash</code> helper will be introduced.</li>
</ul>
<a class="header" href="print.html#motivation-15" id="motivation-15"><h1>Motivation</h1></a>
<p>When building a complex UI from several components, it can be difficult to
share data without breaking encapsulation. For example this template:</p>
<pre><code class="language-hbs">{{#great-toolbar role=user.role}}
  {{great-button role=user.role}}
{{/great-toolbar}}
</code></pre>
<p>Causes the user to pass the <code>role</code> data twice for what are obviously related
components. A component can yield itself down:</p>
<pre><code class="language-hbs">{{! app/components/great-toolbar/template.hbs }}
{{yield this}}
</code></pre>
<pre><code class="language-hbs">{{#great-toolbar role=user.role as |toolbar|}}
  {{great-button toolbar=toolbar}}
{{/great-toolbar}}
</code></pre>
<p>And <code>great-button</code> can have knowledge about properties on <code>great-toolbar</code>, but
this break the isolation of components. Additionally the calling syntax is not
much better, <code>toolbar</code> must still be passed to each downstream component.</p>
<p>Often <code>nearestOfType</code> is used as a workaround for these limitations. This API
is poorly performing, and still results in the downstream child accessing the
parent component properties directly.</p>
<p>Consequently there is a demand by several addons for improvement. Our goal
is a syntax similar to DSLs in Ruby:</p>
<pre><code class="language-hbs">{{#great-toolbar role=user.role as |toolbar|}}
  {{toolbar.button}}
  {{toolbar.button orWith=additionalProperties}}
{{/great-toolbar}}
</code></pre>
<p>As laid out in this proposal, the <code>great-toolbar</code> implementation would look
like:</p>
<pre><code class="language-hbs">{{! app/components/great-toolbar/template.hbs }}
{{yield (hash
  button=(component 'great-button' role=user.role)
)}}
</code></pre>
<a class="header" href="print.html#detailed-design-12" id="detailed-design-12"><h1>Detailed design</h1></a>
<a class="header" href="print.html#the-component-helper-and-component-helper" id="the-component-helper-and-component-helper"><h3>The <code>(component</code> helper and <code>{{component</code> helper</h3></a>
<p>Much like <code>(action</code> creates a closure, it is proposed that the <code>(component</code>
helper create something similar. For example with actions:</p>
<pre><code class="language-hbs">{{#with (action &quot;save&quot; model) as |save|}}
  &lt;button {{action save}}&gt;Save&lt;/button&gt;
{{/with}}
</code></pre>
<p>The returned value of the <code>(action</code> nested helper (a function) closes over the
action being called (<code>actions.save</code> on the context and the <code>model</code> property).
The <code>{{action</code> helper can accept this resulting value and invoke the action
when the user clicks.</p>
<p>The <code>(component</code> helper will close over a component name. The
<code>{{component</code> helper will be modified to accept this resulting value and invoke
the component:</p>
<pre><code class="language-hbs">{{#with (component &quot;user-profile&quot;) as |uiPane|}}
  {{component uiPane}}
{{/with}}
</code></pre>
<p>Additionally, a bound value may be passed to the <code>(component</code> helper. For
example <code>(component someComponentName)</code>.</p>
<p>Attrs for the final component can also be closed over. Used with yield, this
allows for the creation of components that have attrs from other scopes. For
example:</p>
<pre><code class="language-hbs">{{! app/components/user-profile.hbs }}
{{yield (component &quot;user-profile&quot; user=user.name age=user.age)}}
</code></pre>
<pre><code class="language-hbs">{{#user-profile user=model as |profile|}}
  {{component profile}}
{{/user-profile}}
</code></pre>
<p>Of course attrs can also be passed at invocation. They smash any conflicting
attrs that were closed over. For example <code>{{component profile age=lyingUser.age}}</code></p>
<p>Passing the resulting value from <code>(component</code> into JavaScript is permitted,
however that object has no public properties or methods. Its only use would
be to set it on state and reference it in template somewhere.</p>
<a class="header" href="print.html#hash-helper" id="hash-helper"><h3>Hash helper</h3></a>
<p>Unlike values, components are likely to have specific names that are semantically
relevent. When yielded to a new scope, allowing the user to change the name
of the component's variable would quickly lead to confusing addon documentation.
For example:</p>
<pre><code class="language-hbs">{{#with (component &quot;user-profile&quot;) as |dropDatabaseUI|}}
  {{component dropDatabaseUI}}
{{/with}}
</code></pre>
<p>The simplest way to enforce specific names is to make building hashes
of components (or anything) easy. For example:</p>
<pre><code class="language-hbs">{{#with (hash profile=(component &quot;user-profile&quot;)) as |userComponents|}}
  {{component userComponents.profile}}
{{/with}}
</code></pre>
<p>The <code>(hash</code> helper is a generic builder of objects, given hash arguments. It
would also be useful in the same manner for actions:</p>
<pre><code class="language-hbs">{{#with (hash save=(action &quot;save&quot; model)) as |userActions|}}
  &lt;button {{action userActions.save}}&gt;Save&lt;/button&gt;
{{/with}}
</code></pre>
<a class="header" href="print.html#component-helper-shorthand" id="component-helper-shorthand"><h3>Component helper shorthand</h3></a>
<p>To complete building a viable DSL, <code>.</code> invocation for <code>{{</code> components will be
introduced. For example this <code>{{component</code> invocation:</p>
<pre><code class="language-hbs">{{#with (hash profile=(component &quot;user-profile&quot;)) as |userComponents|}}
  {{component userComponents.profile}}
{{/with}}
</code></pre>
<p>Could be converted to drop the explicit <code>component</code> helper call.</p>
<pre><code class="language-hbs">{{#with (hash profile=(component &quot;user-profile&quot;)) as |userComponents|}}
  {{userComponents.profile}}
{{/with}}
</code></pre>
<p>A component can be invoked like this only when it was created by the
<code>(component</code> nested helper form. For example unlike with the <code>{{component</code>
helper, a string is not acceptable.</p>
<p>To be a valid invocation, one of two criteria must be met:</p>
<ul>
<li>The component can be called as a path. For example <code>{{form.input}}</code> or <code>{{this.input}}</code></li>
<li>The component can be called as a helper. For example <code>{{form.input value=baz}}</code> or <code>{{this.input value=baz}}</code></li>
</ul>
<p>And of course a <code>.</code> must be present in the path.</p>
<a class="header" href="print.html#drawbacks-14" id="drawbacks-14"><h1>Drawbacks</h1></a>
<p>This proposal encourages aggressive use of the <code>(</code> nested helper syntax.
Encouraging this has been slightly controversial.</p>
<p>No solution for angle components is presented here. The syntax for <code>.</code>
notation in angle components is coupled to a decision on the syntax for
bound, dynamic angle component invocation (a <code>{{component</code> helper for angle
components basically).</p>
<p><code>(component 'some-component'</code> may be too verbose. It may make sense to simply
allow <code>(some-component</code>.</p>
<p>Other proposals have leaned more heavy on extending factories in JavaScript
then passing an object created in that space. Some arguments against this:</p>
<ul>
<li>Getting the container correct is tricky. Who sets it when?</li>
<li>Properties on the classes would not be naturally bound, as they are in this proposal.</li>
<li>As soon as you start setting properties, you likely want a <code>mut</code> helper,
<code>action</code> helper, etc, in JavaScript space.</li>
<li>Keeping the component lookup in the template layer allows us to take advantage
of changes to lookup semantics later, such as local lookup in the pods
proposal.</li>
</ul>
<a class="header" href="print.html#alternatives-14" id="alternatives-14"><h1>Alternatives</h1></a>
<p>All pain, no gain. Addons really want this.</p>
<a class="header" href="print.html#unresolved-questions-12" id="unresolved-questions-12"><h1>Unresolved questions</h1></a>
<p>There has been discussion of if a similar mechanism should be available for
helpers.</p>
<ul>
<li>Start Date: 2015-06-30</li>
<li>RFC PR: https://github.com/emberjs/rfcs/pull/65</li>
<li>Ember Issue: (leave this empty)</li>
</ul>
<a class="header" href="print.html#summary-15" id="summary-15"><h1>Summary</h1></a>
<p>Deprecations and warnings in Ember.js should have configurable runtime handlers.
This allows default behavior (logging, raise when <code>RAISE_ON_DEPRECATION</code> is true)
to be overridden by an enviornment (Ember's tests), addon, or other tool
(like the Ember Inspector).</p>
<p>Ember-Data and the Ember Inspector have both requested a public
API for changing how deprecation and warning messages are handled. The requirements
for these and other requests are complex enough that deferring the message
behavior into a runtime hook is the suggested path.</p>
<a class="header" href="print.html#motivation-16" id="motivation-16"><h1>Motivation</h1></a>
<p><code>Ember.deprecate</code> and <code>Ember.warn</code> usually log messages. With <code>ENV.RAISE_ON_DEPRECATION</code>
all deprecations will throw an exception. In some scenarios, this
is less than ideal:</p>
<ul>
<li>Ember itself needs a way to silence some deprecations before their usage
is completely removed from tests. For example, many view APIs in Ember 1.13.</li>
<li>The Ember inspector desires to raise on specific deprecations, or silence
specific deprecations.</li>
<li>Ember-Data also desires to silence some deprecations in tests</li>
</ul>
<p>In <a href="https://github.com/emberjs/ember.js/pull/11419">PR #1141</a>
a private log level API has been introduced, which allows finer grained control
if specific deprecations should be logged, throwing an error or be silenced
completely. For example:</p>
<pre><code class="language-js">Ember.Debug._addDeprecationLevel('my-feature', Ember.Debug._deprecationLevels.LOG);
// ...
Ember.deprecate(&quot;x is deprecated, use Y instead&quot;, false, { id: 'my-feature' });
</code></pre>
<p>Initially a public version of this API was discussed, but it quickly became
clear that a runtime hook provided more flexibility without incurring the
cost of a complex log-level API.</p>
<p>Note that &quot;runtime&quot; refers to Ember itself. A custom handler could be injected
into Ember-CLI's template compilation code. &quot;runtime&quot; in this context still
refers to handling deprecations raised during compilation.</p>
<a class="header" href="print.html#detailed-design-13" id="detailed-design-13"><h1>Detailed design</h1></a>
<p>A handler for deprecations can be registered. This handler will be called
with relevent information about a deprecation, including guarantees about
the presence of these items:</p>
<ul>
<li>The deprecation message</li>
<li>The version number where this deprecation (and feature) will be removed</li>
<li>The &quot;id&quot; of this deprecation, a stable identifier independent of the message</li>
</ul>
<p>Additionally, an application instance may be passed with the options. An example
handler would look like:</p>
<pre><code class="language-js">import { registerHandler } from &quot;ember-debug/deprecations&quot;;

registerHandler(function deprecationHandler(message, options) {
  // * message is the deprecation message
  // * options.until is the version this deprecation will be removed at
  // * options.id is the canonical id for this deprecation
  if (options.until === &quot;2.4.0&quot;) {
    throw new Error(message);
  } else {
    console.log(message);
  }
});
</code></pre>
<p>Warnings are similar, but will not recieve an <code>until</code> value:</p>
<pre><code class="language-js">import { registerHandler } from &quot;ember-debug/warnings&quot;;

registerHandler(function warningHandler(message, options) {
  // * message is the warning message
  // * options.id is the canonical id for this warning
  if (options.id !== 'view.rerender-on-set') {
    console.log(message);
  }
});
</code></pre>
<a class="header" href="print.html#chained-handlers" id="chained-handlers"><h5>chained handlers</h5></a>
<p>Since several handlers may be registered, a method of deferring to a previously
registered handler must be allowed. A third option is passed to handlers, the
function <code>next</code> which represents the previously registered handler.</p>
<p>For example:</p>
<pre><code class="language-js">import { registerHandler } from &quot;ember-debug/deprecations&quot;;

registerHandler(function firstDeprecationHandler(message, options, next) {
  console.warn(message);
});

registerHandler(function secondDeprecationHandler(message, options, next) {
  if (options.until === &quot;2.4.0&quot;) {
    throw new Error(message);
  }
  next(...arguments);
});
</code></pre>
<p>The first registed handler will receive Ember's default behavior as <code>next</code>.</p>
<a class="header" href="print.html#new-assertions-for-deprecate-and-warn" id="new-assertions-for-deprecate-and-warn"><h5>new assertions for deprecate and warn</h5></a>
<p>Ember's APIs for deprecation and warning do not currently require any information
beyond a message. It is proposed that deprecations be <strong>required</strong> to pass
the following information:</p>
<ul>
<li>Message</li>
<li>Test</li>
<li>Canonical id (with a format of <code>package-name.some-id</code>)</li>
<li>Release when this deprecation will be stripped</li>
</ul>
<p>For example:</p>
<pre><code>import Ember from &quot;ember&quot;;

Ember.deprecate(&quot;Some message&quot;, false, {
  id: 'ember-routing.query-params',
  until: '3.0.0'
});
</code></pre>
<p>If this information is not present and assertion will be made.</p>
<p>Warnings likewise will be required to pass a canonical id:</p>
<pre><code>import Ember from &quot;ember&quot;;

Ember.warn(&quot;Some warning&quot;, {id: 'ember-debug.something'});
</code></pre>
<a class="header" href="print.html#default-handlers" id="default-handlers"><h5>default handlers</h5></a>
<p>The default handler for deprecation should be quite simple, and mirrors current
behavior:</p>
<pre><code class="language-js">function defaultDeprecationHandler(message, options) {
  if (Ember.ENV.RAISE_ON_DEPRECATION) {
   throw new Error(format(message, options));
  } else {
   console.log(format(message, options));
  }
}
</code></pre>
<p>The default handler for warnings would be simple <code>console.log</code>.</p>
<a class="header" href="print.html#drawbacks-15" id="drawbacks-15"><h1>Drawbacks</h1></a>
<p>By not providing a robust log-level API, we are punting complexity to the
consumer of this API. For a low-level tooling API such as this one, it seems
and appropriate tradeoff.</p>
<a class="header" href="print.html#alternatives-15" id="alternatives-15"><h1>Alternatives</h1></a>
<p>Each app can stub out <code>deprecate</code> and <code>warn</code>.</p>
<a class="header" href="print.html#unresolved-questions-13" id="unresolved-questions-13"><h1>Unresolved questions</h1></a>
<p><code>RAISE_ON_DEPRECATION</code> could be considered deprecated with this new API.</p>
<ul>
<li>Start Date: 2015-09-11</li>
<li>RFC PR: https://github.com/emberjs/rfcs/pull/91</li>
<li>Ember Issue: <a href="https://github.com/emberjs/ember.js/pull/12224">#12224</a> / <a href="https://github.com/emberjs/ember.js/pull/12990">#12990</a> / <a href="https://github.com/emberjs/ember.js/pull/13688">#13688</a></li>
</ul>
<a class="header" href="print.html#summary-16" id="summary-16"><h1>Summary</h1></a>
<p>Introduce <code>Ember.WeakMap</code> (<code>@ember/weakmap</code>), an ES6 enspired WeakMap. A
WeakMap provides a mechanism for storing and retriving private state. The
WeakMap itself does not retain a reference to the state, allowing the state to
be reclaimed when the key is reclaimed.</p>
<p>A traditional WeakMap (and the one that will be part of the language) allows
for weakness from key -&gt; map, and also from map -&gt; key. This allows either the
Map, or the key being reclaimed to also release the state.</p>
<p>Unforunately, this bi-directional weakness is problemative to polyfil. Luckily,
uni-directional weakness, in either direction, &quot;just works&quot;. A polyfil must
just choose a direction.</p>
<p><em>Note: Just like ES2015 WeakMap, only non null Objects can be used as keys</em>
<em>Note: <code>Ember.WeakMap</code> can be used interchangibly with the ES2015 WeakMap. This
will allow us to eventually cut over entirely to the Native WeakMap.</em></p>
<a class="header" href="print.html#motivation-17" id="motivation-17"><h1>Motivation</h1></a>
<p>It is a common pattern to want to store private state about a specific object.
When one stores this private state off-object, it can be tricky to understand
when to release the state. When one stores this state on-object, it will be
released when the object is released. Unfortunately, storing the state
on-object without poluting the object itself is non-obvious.</p>
<p>As it turns out, Ember's Meta already solves this problem for
listeners/caches/chains/descriptors etc. Unfortunately today, there is no
public API for apps or addons to utilize this. <code>Ember.WeakMap</code> aims to be
exactly that API.</p>
<p>Some examples:</p>
<ul>
<li>https://github.com/offirgolan/ember-cp-validations/blob/master/addon/utils/cycle-breaker.js</li>
<li>https://github.com/stefanpenner/ember-state-services/ (will soon utilize the user-land polyfil of this) to prevent common leaks.</li>
</ul>
<a class="header" href="print.html#detailed-design-14" id="detailed-design-14"><h1>Detailed design</h1></a>
<a class="header" href="print.html#public-api" id="public-api"><h2>Public API</h2></a>
<pre><code class="language-js">import WeakMap from '@ember/weak-map'

var private = new WeakMap();
var object = {};
var otherObject = {};

private.set(object, {
  id: 1,
  name: 'My File',
  progress: 0
}) === private;

private.get(object) === {
  id: 1,
  name: 'My File',
  progress: 0
});


private.has(object) === true;
private.has(otherObject) === false;

private.delete(object) === private;
private.has(object) === false;
</code></pre>
<a class="header" href="print.html#implementation-details" id="implementation-details"><h2>Implementation Details</h2></a>
<p>The backing store for <code>Ember.WeakMap</code> will reside in a lazy <code>ownMap</code> named
<code>weak</code> on the key objects <code>__meta__</code> object.</p>
<p>Each <code>WeakMap</code> has its own internal GUID, which will be the name of its slot,
in the key objects meta weak bucket. This will allow one object to belong in
multiple weakMaps without chance of collision.</p>
<p>Concrete Implementation: https://github.com/emberjs/ember.js/pull/12224
Polyfill: https://www.npmjs.com/package/ember-weakmap</p>
<a class="header" href="print.html#drawbacks-16" id="drawbacks-16"><h1>Drawbacks</h1></a>
<ul>
<li>implementing bi-direction Weakness in userland is problematic.</li>
<li>Using WeakMap will insert a non-enumerable <code>meta</code> onto the key Object.</li>
</ul>
<a class="header" href="print.html#alternatives-16" id="alternatives-16"><h1>Alternatives</h1></a>
<ul>
<li>Weakness could be implemented in the other direction, but this has questionable utility.</li>
</ul>
<a class="header" href="print.html#unresolved-questions-14" id="unresolved-questions-14"><h1>Unresolved questions</h1></a>
<p>N/A</p>
<ul>
<li>Start Date: 2015-09-24</li>
<li>RFC PR: https://github.com/emberjs/rfcs/pull/95</li>
<li>Ember Issue: https://github.com/emberjs/ember.js/pull/14805</li>
</ul>
<a class="header" href="print.html#summary-17" id="summary-17"><h1>Summary</h1></a>
<p>This RFC proposes:</p>
<ul>
<li>
<p>creating a public <code>router</code> service that is a superset of today's <code>Ember.Router</code>.</p>
</li>
<li>
<p>codifying and expanding the supported public API for the <code>transition</code> object that is currently passed to <code>Route</code> hooks.</p>
</li>
<li>
<p>introducing the <code>get-route-info</code> template helper</p>
</li>
<li>
<p>introducing the <code>#with-route-info</code> template keyword</p>
</li>
<li>
<p>introducing the <code>readsRouteInfo</code> static property on <code>Component</code> and <code>Helper</code>.</p>
</li>
</ul>
<p>These topics are closely related because they share a unified <code>RouteInfo</code> type, which will be described in detail.</p>
<a class="header" href="print.html#motivation-18" id="motivation-18"><h1>Motivation</h1></a>
<p>Given the modern Ember concepts of Components and Services, it is clear that routing capability should be exposed as a Service. I hope this is uncontroversial, given that we already implement it as a service internally, and given that usage of these nominally-private APIs is already becoming widespread.</p>
<p>The immediate benefit of having a <code>RouterService</code> is that you can inject it into components, giving them a friendly way to initiate transitions and ask questions about the current global router state.</p>
<p>A second benefit is that we have the opportunity to add new capabilities to the <code>RouterService</code> to replace several common patterns in the wild that dive into private internals in order to get things done. There are several places where we leak internals from router.js, and we can plug those leaks.</p>
<p>A <code>RouterService</code> is great for asking global questions, but some questions are not global and today we incur complexity by treating them as if they are. For example:</p>
<ul>
<li>
<p><code>{{link-to}}</code> can use implicit models from its context, but that breaks when you're trying to animate to or from a state where those models are not present.</p>
</li>
<li>
<p><code>{{link-to}}</code> has a lot of complexity and performance cost that deals with changing its active state, and the precise timing of when that should happen.</p>
</li>
<li>
<p>there is no way to ask the router what it would do to handle a given URL without actually visiting that URL.</p>
</li>
</ul>
<p>All of the above can be addressed by embracing what is already internally true: &quot;the current route&quot; is not a single global, it's a dynamically-scoped variable that can have different values in different parts of the application simultaneously.</p>
<a class="header" href="print.html#detailed-design-15" id="detailed-design-15"><h1>Detailed design</h1></a>
<a class="header" href="print.html#routerservice" id="routerservice"><h2>RouterService</h2></a>
<p>By way of a simple example, the router service behaves like this:</p>
<pre><code class="language-js">import Component from 'ember-component';
import service from 'ember-service/inject';

export default Component.extend({
  router: service(),
  actions: {
    goToMars() {
      this.get('router').transitionTo('planet.mars');
    }
  }
});
</code></pre>
<p>Like any Service, it can also be injected into Helpers, Routes, etc.</p>
<a class="header" href="print.html#relationship-between-emberrouter-and-routerservice" id="relationship-between-emberrouter-and-routerservice"><h3>Relationship between EmberRouter and RouterService</h3></a>
<p>Q: &quot;Why are you calling this thing 'router' when we already have a router? Shouldn't the new thing be called 'routing' or something else?&quot;.</p>
<p>A: We shouldn't have two things. From the user's perspective, there is just &quot;the router&quot;, and it happens to be available as a service. While we're free to continue implementing it as multiple classes under the hood, the public API should present as a single, coherent concept.</p>
<p>Terminology:</p>
<ul>
<li><code>EmberRouter</code> is the class that we already have today, defined in <code>ember-routing/system/router</code> and available publicly as <code>Ember.Router</code></li>
<li><code>RouterService</code> is the new class I am proposing.</li>
</ul>
<p><code>EmberRouter</code> has the following public API today:</p>
<ul>
<li><code>map</code></li>
<li><code>location</code></li>
<li><code>rootURL</code></li>
<li><code>willTransition</code></li>
<li><code>didTransition</code></li>
</ul>
<p>That API will be carried over verbatim to <code>RouterService</code>, and the publicly accessible <code>Ember.Router</code> class will <em>become</em> <code>RouterService</code>. In terms of implementation, I expect the existing <code>EmberRouter</code> class will continue to exist mostly unchanged. But public access to it will be moderated through <code>RouterService</code>.</p>
<a class="header" href="print.html#new-methods-initiating-transitions" id="new-methods-initiating-transitions"><h3>New Methods: Initiating Transitions</h3></a>
<pre><code class="language-js">transitionTo(routeName, ...models, queryParams)
replaceWith(routeName, ...models, queryParams)
</code></pre>
<p>These two have the same semantics as the existing methods on <code>Ember.Route</code>:</p>
<a class="header" href="print.html#new-method-checking-for-active-route" id="new-method-checking-for-active-route"><h3>New Method: Checking For Active Route</h3></a>
<ul>
<li><code>isActive(routeName, ...models, queryParams)</code></li>
</ul>
<p>The arguments have the same semantics as <code>transitionTo</code>, the return value is a boolean. This should provide the same logic that determines whether to put an active class on a <code>link-to</code>. Here's an example of how we can implement <code>is-active</code> as a helper, using this method:</p>
<pre><code class="language-js">import Helper from 'ember-helper';
import service from 'ember-service/inject';
import observer from 'ember-metal/observer';

export default Helper.extend({
  router: service(),
  compute([routeName, ...models], hash) {
    let allModels;
    if (hash.models) {
      allModels = models.concat(hash.models);
    } else {
      allModels = models;
    }
    return this.get('router').isActive(routeName, ...allModels, hash.queryParams);
  },
  didTransition: observer('router.currentRoute', function() {
    this.recompute();
  })
});
</code></pre>
<pre><code class="language-hbs">{{!- Example usage -}}
&lt;li class={{if (is-active &quot;person.detail&quot; model) 'chosen'}} &gt;

{{!- Example usage with generic routeName and list of models (avoids splat) -}}
&lt;a class={{if (is-active routeName models=models) 'chosen'}} &gt;

{{!- Note that the complexities of currentWhen can be avoided by composing instead. }}
&lt;a class={{if (or (is-active 'one') (is-active 'two')) 'active'}} href={{url-for 'two'}} &gt;

</code></pre>
<a class="header" href="print.html#new-method-url-generation" id="new-method-url-generation"><h3>New Method: URL generation</h3></a>
<p><code>urlFor(routeName, ...models, queryParams)</code></p>
<p>This takes the same arguments as <code>transitionTo</code>, but instead of initiating the transition it returns the resulting root-relative URL as a string (which will include the application's <code>rootUrl</code>).</p>
<p>A <code>url-for</code> helper can be implemented almost identically to the <code>is-active</code> example above.</p>
<a class="header" href="print.html#new-method-url-recognition" id="new-method-url-recognition"><h3>New Method: URL recognition</h3></a>
<p><code>recognize(url)</code></p>
<p>Takes a string URL and returns a <code>RouteInfo</code> for the leafmost route represented by the URL. Returns <code>null</code> if the URL is not recognized. This method expects to receive the actual URL as seen by the browser <em>including</em> the app's <code>rootURL</code>.</p>
<p>Example: this feature can replace <a href="https://github.com/intercom/ember-href-to/blob/b8cf0699eec6a65570b05e4fc22b27d8cea49c42/app/instance-initializers/browser/ember-href-to.js#L34">this use of private API in ember-href-to</a>.</p>
<a class="header" href="print.html#new-method-recognize-and-load-models" id="new-method-recognize-and-load-models"><h3>New Method: Recognize and load models</h3></a>
<p><code>recognizeAndLoad(url)</code></p>
<p>Takes a string URL and returns a promise that resolves to a <code>RouteInfoWithAttributes</code> for the leafmost route represented by the URL. The promise rejects if the URL is not recognized or an unhandled exception is encountered. This method expects to receive the actual URL as seen by the browser <em>including</em> the app's <code>rootURL</code>.</p>
<a class="header" href="print.html#deprecating-willtransition-and-didtransition" id="deprecating-willtransition-and-didtransition"><h3>Deprecating willTransition and didTransition</h3></a>
<p>Application-wide transition monitoring events belong on the Router service, not spread throughout the Route classes. That is the reason for the existing <code>willTransition</code> and <code>didTransition</code> hooks/events on the Router. But they are not sufficient to capture all the detail people need. See for example, https://github.com/nickiaconis/rfcs/blob/1bd98ec534441a38f62a48599ffa8a63551b785f/text/0000-transition-hooks-events.md</p>
<p>In addition, they receive handlerInfos in their arguments, which are an undocumented internal implementation detail of router.js that doesn't belong in Ember's public API. Everything you can do with handlerInfos can be done with the RouteInfo type that is proposed in this RFC, with the benefit of sticking to supported public API.</p>
<p>So we should deprecate willTransition and didTransition in favor of the following new events.</p>
<a class="header" href="print.html#new-events-routewillchange--routedidchange" id="new-events-routewillchange--routedidchange"><h3>New Events: routeWillChange &amp; routeDidChange</h3></a>
<p>The <code>routeWillChange</code> event fires whenever a new route is chosen as the desired target of a transition. This includes <code>transitionTo</code>, <code>replaceWith</code>, all redirection for any reason including error handling, and abort. Aborting implies changing the desired target back to where you already were. Once a transition has completed, <code>routeDidChange</code> fires.</p>
<p>Both events receive a single <code>transition</code> argument as described in the &quot;Transition Object&quot; section below, which explains the meaning of <code>from</code> and <code>to</code> in more detail.</p>
<p>Redirection example:</p>
<ol>
<li>current route is A</li>
<li>user initiates a transition to B</li>
<li>routeWillChange fires <code>from</code> A <code>to</code> B.</li>
<li>B redirects to C</li>
<li>routeWillChange fires <code>from</code> A <code>to</code> C.</li>
<li>routeDidChange fires <code>from</code> A <code>to</code> C.</li>
</ol>
<p>Abort example:</p>
<ol>
<li>current route is A</li>
<li>user initiates a transition to B</li>
<li>routeWillChange fires <code>from</code> A <code>to</code> B.</li>
<li>in response to the previous routeWillChange event, the transition is aborted.</li>
<li>routeWillChange fires <code>from</code> A <code>to</code> A.</li>
<li>routeDidChange fires <code>from</code> A <code>to</code> A.</li>
</ol>
<p>Error example:</p>
<ol>
<li>current route is A</li>
<li>user initiates a transition to B.index</li>
<li>routeWillChange fires <code>from</code> A <code>to</code> B.</li>
<li>B throws an exception, and the router discovers a &quot;B-error&quot; template.</li>
<li>routeWillChange fires <code>from</code> A <code>to</code> B-error</li>
<li>routeDidChange fires <code>from</code> A <code>to</code> B-error</li>
</ol>
<p>These are events, not extension hooks -- now that we are exposing a Service, it makes more sense to subscribe to its events than extend it.</p>
<a class="header" href="print.html#new-properties" id="new-properties"><h3>New Properties</h3></a>
<p><code>currentRoute</code>: an observable property. It is guaranteed to change whenever a route transition happens (even when that transition only changes parameters and doesn't change the active route). You should consider its value deeply immutable -- we will replace the whole structure whenever it changes. The value of <code>currentRoute</code> is a <code>RouteInfo</code> representing the current leaf route. <code>RouteInfo</code> is described below.</p>
<p><code>currentRouteName</code>:  a convenient alias for <code>currentRoute.name</code>.</p>
<p><code>currentURL</code>: provides the serialized string representing <code>currentRoute</code>.</p>
<a class="header" href="print.html#query-parameter-semantics" id="query-parameter-semantics"><h3>Query Parameter Semantics</h3></a>
<p>Today, <code>queryParams</code> impose unnecessarily high cost because we cannot generate URLs or determine if a link is active without taking into account the default values of query parameters. Determining their default values is expensive, because it involves instantiating the corresponding controller, even in cases where we will never visit its route.</p>
<p>Therefore, the <code>queryParams</code> argument to the new <code>urlFor</code>, <code>transitionTo</code>, <code>replaceWith</code>, and <code>isActive</code> methods defined in this document will behave differently.</p>
<ul>
<li>
<p>default values will not be stripped from generated URLs. For example, <code>urlFor('my-route', { sortBy: 'title' })</code> will always include <code>?sortBy=title</code>, whether or not <code>title</code> is the default value of <code>sortBy</code>.</p>
</li>
<li>
<p>to explicitly unset a query parameter, you can pass the symbol <code>Ember.DEFAULT_VALUE</code> as its value. For example, <code>transitionTo('my-route', { sortBy: Ember.DEFAULT_VALUE })</code> will result in a URL that does not contain any <code>?sortBy=</code>.</p>
</li>
</ul>
<p>(Sticky parameters are still allowed, because they only apply when the destination controller has already been instantiated anyway.)</p>
<a class="header" href="print.html#routeinfo-type" id="routeinfo-type"><h2>RouteInfo Type</h2></a>
<p>A RouteInfo object has the following properties. They are all read-only.</p>
<ul>
<li>name: the dot-separated, fully-qualified name of this route, like <code>&quot;people.index&quot;</code>.</li>
<li>localName: the final part of the <code>name</code>, like <code>&quot;index&quot;</code>.</li>
<li>params: the values of this route's parameters. Same as the argument to <code>Route</code>'s <code>model</code> hook. Contains only the parameters valid for this route, if any (params for parent or child routes are not merged).</li>
<li>paramNames: ordered list of the names of the params required for this route. It will contain the same strings as <code>Object.keys(params)</code>, but here the order is significant. This allows users to correctly pass params into routes programmatically.</li>
<li>queryParams: the values of any queryParams on this route.</li>
<li>parent: another RouteInfo instance, describing this route's parent route, if any.</li>
<li>child: another RouteInfo instance, describing this route's active child route, if any.</li>
</ul>
<p>Notice that the <code>parent</code> and <code>child</code> properties cause <code>RouteInfos</code> to form a linked list. So even though the <code>currentRoute</code> property on <code>RouterService</code> points at the leafmost route, it can be traversed to discover everything about all active routes. As a convenience, <code>RouteInfo</code> also implements <code>Enumerable</code> over all the reachable <code>RouteInfos</code> from topmost to leafmost. This makes it possible to say things like:</p>
<pre><code class="language-js">router.currentRoute.find(info =&gt; info.name === 'people').params
</code></pre>
<a class="header" href="print.html#routeinfowithattributes" id="routeinfowithattributes"><h2>RouteInfoWithAttributes</h2></a>
<p>This type is almost identical to <code>RouteInfo</code>, except it has one additional property named <code>attributes</code>. The attributes contain the data that was loaded for this route, which is typically just <code>{ model }</code>.</p>
<a class="header" href="print.html#transition-object" id="transition-object"><h2>Transition Object</h2></a>
<p>A <code>transition</code> argument is passed to <code>Route#beforeModel</code>, <code>Route#model</code>, <code>Route#afterModel</code>, <code>Route#willTransition</code>, and <code>Router#willTransition</code>. Today <code>transition</code>'s public API is only really <code>abort()</code> and <code>retry()</code>.</p>
<a class="header" href="print.html#new-properties-from-and-to" id="new-properties-from-and-to"><h3>New Properties: <code>from</code> and <code>to</code></h3></a>
<p>I'm proposing we add <code>from</code> and <code>to</code> properties on <code>transition</code> whose values are <code>RouteInfo</code> instances representing the initial and final leafmost routes for this transition. Like all RouteInfos, these are read-only and internally immutable. They are not observable, because a  <code>transition</code> instance is never changed after creation.</p>
<p>On an initial full-page load, the <code>from</code> property will be <code>null</code>. This creates a public API for distinguishing in-app transitions from full-page reloads.</p>
<a class="header" href="print.html#example-testing-whether-route-will-remain-active" id="example-testing-whether-route-will-remain-active"><h3>Example: testing whether route will remain active</h3></a>
<p>Here's an example showing how <code>willTransition</code> can figure out if the current route will remain active after the transition:</p>
<pre><code class="language-js">willTransition(transition) {
  if (!this.transition.to.find(route =&gt; route.name === this.routeName)) {
    alert(&quot;Please save or cancel your changes.&quot;);
    transition.abort();
  }
}
</code></pre>
<a class="header" href="print.html#example-parent-redirecting-to-a-fallback-model" id="example-parent-redirecting-to-a-fallback-model"><h3>Example: parent redirecting to a fallback model</h3></a>
<p>Here's an example of a parent route that can redirect to a fallback model, without losing its child route:</p>
<pre><code class="language-js">this.route('person', { path: '/person/:person_id' }, function() {
  this.route('index');
  this.route('detail');
});

//PersonRoute
const fallbackPersonId = 0;
model({ personId }, transition) {
  return this.get('store').find('person', personId).catch(err =&gt; {
    this.replaceWith(transition.to.name, fallbackPersonId);
  });
}

// If personId 5 is invalid, and the user visits /person/5/detail, they will get
// redirected to /person/0/detail. And /person/5 will get redirected to /person/0.
</code></pre>
<a class="header" href="print.html#actively-discourage-use-of-private-api" id="actively-discourage-use-of-private-api"><h3>Actively discourage use of private API</h3></a>
<p>This RFC provides public API for doing the things people have become accustomed to doing via private API. To eliminate confusion over the correct way, we should hide all the private API away behind symbols, and provide deprecation warnings per our usual release policy around breaking &quot;widely-used private APIs&quot;.</p>
<p>Some of the private APIs we should mark and warn include:</p>
<ul>
<li>transition.state</li>
<li>transition.params</li>
<li><code>lookup('router:main')</code> (should use <code>service:router</code> instead)</li>
</ul>
<a class="header" href="print.html#dynamically-scoped-route-info" id="dynamically-scoped-route-info"><h2>Dynamically-Scoped Route Info</h2></a>
<p>&quot;The current route&quot; is not a global value -- it varies from place to place within an application. Internally, Ember already models route info as a dynamically-scoped variable (currently named <code>outletState</code>). This RFC proposes publicly exposing that value in order to make things like <code>link-to</code> easier to implement directly on public primitives, and in order to enable stable public API for addons usage like <code>{{liquid-outlet}}</code>.</p>
<p>We propose <code>get-route-info</code> for reading the current route info in handlebars:</p>
<pre><code class="language-hbs">{{!- retrieve the value of a dynamically scoped variable }}
{{some-component currentRoute=(get-route-info)}}
</code></pre>
<p>We propose <code>readsRouteInfo</code> for defining a component that reads route info:</p>
<pre><code class="language-js">let MyComponent = Ember.Component.extend({
  didInsertElement() {
    // Accessing routInfo here is intended to be indistinguishable
    // from a normal, explicitly-passed input argument. 
    doSomethingWith(this.get('routeInfo'));
  }
});
MyComponent.reopenClass({
  // This is where we declare that we need access to routeInfo
  readsRouteInfo: true
});
</code></pre>
<p>And <code>readsRouteInfo</code> also works on <code>Helper</code>:</p>
<pre><code class="language-js">let MyHelper = Ember.Helper.extend({
  compute(params, hash) {
    // routeInfo is indistinguishable from a normally-passed hash argument
    return doSomethingWith(hash.routeInfo);
  }
});
MyHelper.reopenClass({
  readsRouteInfo: true
});
</code></pre>
<p>We propose the <code>#with-route-info</code> keyword for setting a new route info:</p>
<pre><code class="language-hbs">{{#with-route-info someValue}}
  {{!-
    within this block AND ALL ITS DESCENDANTS until
    otherwise overridden by another set-route-info statement, 
    `get-route-info` returns someValue.
  -}}
{{/with-route-info}}
</code></pre>
<p>Note that there is no <code>set-route-info</code>. You can only introduce new scopes, not mutate your containing scope. There is also no way to set routeInfo directly from Javascript -- your component must use a <code>with-route-info</code> block within its handlebars template.</p>
<a class="header" href="print.html#routeinfos-type-and-examples" id="routeinfos-type-and-examples"><h3>routeInfo's type, and examples</h3></a>
<p>The value returned from <code>get-route-info</code> and acceptd by <code>with-route-info</code> is always a <code>RouteInfoWithAttributes</code> object. This enables several nice things, which I will illustrate with examples:</p>
<ol>
<li>Here is a simplified <code>is-active</code> helper that will always update at the appropriate time to match exactly what is rendered in the current outlet. It will maintain the correct state even during animations. Instead of injecting the router service, it consumes the <code>routeInfo</code> from its containing environment:</li>
</ol>
<pre><code class="language-js">Ember.Helper.extend({
  compute([routeName], { routeInfo }) {
    return !!routeInfo.find(info =&gt; info.name === routeName);
  }
}).reopenClass({
  readsRouteInfo: true
});
</code></pre>
<p>A more complete version that also matches models and queryParams can be written in the same way.</p>
<ol start="2">
<li>
<p>We can improve <code>link-to</code> so that it always finds implicit model arguments from the local context, rather than trying to locate them on the global router service. This will fix longstanding bugs like https://github.com/ember-animation/liquid-fire/issues/347 and it will make it easier to test components that contain <code>{{link-to}}</code>. This would also open the door to relative link-tos.</p>
</li>
<li>
<p><code>liquid-outlet</code> can be implemented entirely via public API. It would become:</p>
</li>
</ol>
<pre><code class="language-hbs">{{#liquid-bind (get-route-info) as |currentRouteInfo|}}
  {{#with-route-info currentRouteInfo}}
    {{outlet}}
  {{/with-route-info}}
{{/liquid-bind}}
</code></pre>
<ol start="4">
<li>Prerendering of non-current routes becomes possible. You can use <code>recognizeAndLoad</code> to obtain a <code>RouteInfoWithAttributes</code> and then use <code>{{#with-route-info myRouteInfo}} {{outlet}} {{/with-route-info}}</code> to render it.</li>
</ol>
<a class="header" href="print.html#drawbacks-17" id="drawbacks-17"><h1>Drawbacks</h1></a>
<p>This RFC deprecates only two public extension hooks API, so the API-churn burden may appear low. However, we know that use of the private APIs we're deliberately disabling is widespread, so users will experience churn. We can provide our usual deprecation cycle to give them early warning, but it still imposes some cost.</p>
<p>This RFC doesn't attempt to change the existing and fairly rich semantics for initiating transitions. For example, you can pass either models or IDs, and those have subtle semantic differences. I think an ideal rewrite would also change the semantics of the route hooks and transitionTo to simplify that area.</p>
<a class="header" href="print.html#alternatives-17" id="alternatives-17"><h1>Alternatives</h1></a>
<a class="header" href="print.html#less-churn" id="less-churn"><h2>Less Churn</h2></a>
<p>We could adopt some of the existing broadly used APIs as de-facto public. This avoids churn, but imposes a complexity burden on every new learner, who needs to be told &quot;this is a weird API, but it's what we're stuck with&quot;.</p>
<a class="header" href="print.html#semver-lawyering" id="semver-lawyering"><h2>Semver Lawyering</h2></a>
<p>I'm interpreting router.js's public/private documentation as out-of-scope for Ember's semver. The fact that we pass an instance of router.js's Transition as our <code>transition</code> argument is not documented. An alternative interpretation is that we need to continue supporting those methods marked as public in router.js's docs.</p>
<a class="header" href="print.html#optional-helpers" id="optional-helpers"><h2>Optional Helpers</h2></a>
<p>I didn't propose shipping <code>is-active</code> and <code>url-for</code> template helpers -- I merely showed that they're easy to build using the router service. But we should arguably just ship them as part of the framework too.</p>
<a class="header" href="print.html#branching-route-hierarchies" id="branching-route-hierarchies"><h2>Branching Route Hierarchies</h2></a>
<p>I am implicitly assuming we will only ever have linear route hierarchies, where a given route has at most one child. I can imagine eventually wanting a way to support branching route hierarchies, where each branch can transition independently. I'm not trying to account for that future.</p>
<a class="header" href="print.html#routeparentroute" id="routeparentroute"><h2>Route.parentRoute</h2></a>
<p>This RFC makes it possible for a route to determine its parent's name dynamically via public API, and thus access its parent's model/params/controller:</p>
<pre><code class="language-js">beforeModel(transition) {
  const parentInfo = transition.to.find(info =&gt; info.name === this.routeName).parent;
  const parentModel = this.modelFor(parentInfo.name);
}
</code></pre>
<p>However, this pattern feels awkward, and I think it justifies just adding a public <code>parentRouteName()</code> method to <code>Route</code> that would simplify to:</p>
<pre><code class="language-js">beforeModel(transition) {
  const parentModel = this.modelFor(this.parentRouteName());
}
</code></pre>
<p>Possibly we <em>want</em> this to feel awkward because it's a weird thing to do.</p>
<a class="header" href="print.html#naming-of-emberdefault_value-symbol" id="naming-of-emberdefault_value-symbol"><h2>Naming of Ember.DEFAULT_VALUE Symbol</h2></a>
<p>Should we introduce new API via the <code>Ember</code> global and switch to a module export once all the rest of Ember does, or should we just start with a module export right now? If so, what module?</p>
<pre><code>import { DEFAULT_VALUE } from 'ember-routing';
</code></pre>
<ul>
<li>Start Date: 2015-10-23</li>
<li>RFC PR: https://github.com/emberjs/rfcs/pull/101</li>
<li>Ember Issue: https://github.com/emberjs/data/pull/3930</li>
</ul>
<a class="header" href="print.html#summary-18" id="summary-18"><h1>Summary</h1></a>
<p>Add more illustrative detail to the default Ember Data Adapter Errors.</p>
<a class="header" href="print.html#motivation-19" id="motivation-19"><h1>Motivation</h1></a>
<p>With a production Ember project, it's common to have many errors of the form &quot;Adapter Error&quot;,
originating from deep in the Ember Data stack and carrying little context about what the
original error cause was.</p>
<p>The intent is to add the original request URL, the response code, and some payload information
to the default Error message for <code>DS.AdapterError</code>s. From there Errors can be handled or
tracked as normal.</p>
<a class="header" href="print.html#detailed-design-16" id="detailed-design-16"><h1>Detailed design</h1></a>
<p>I've been using something similar to the following Adapter (<code>friendly-error-adapter.js</code>):</p>
<pre><code class="language-js">import ActiveModelAdapter from 'active-model-adapter';

import DS from 'ember-data';

export default ActiveModelAdapter.extend({

  ajax(url, method)  {
    this.lastRequest = {
      url:    url,
      method: method
    };
    return this._super(...arguments);
  },

  handleResponse: function (status, headers, payload) {
    let payloadContentType = headers[&quot;Content-Type&quot;].split(&quot;;&quot;).get(&quot;firstObject&quot;);
    let shortenedPayload;

    if (payloadContentType === &quot;text/html&quot; &amp;&amp; payload.length &gt; 250) {
      shortenedPayload = &quot;[omitted long blob of HTML]&quot;;
    } else {
      shortenedPayload = payload;
    }

    let errorMessage = `Ember Data Error (${this.lastRequest.method} ${this.lastRequest.url} returned a ${status}). \n Payload (${payloadContentType}): \n\n ${shortenedPayload}`;

    if (this.isSuccess(status, headers, payload)) {
      return payload;
    } else if (this.isInvalid(status, headers, payload)) {
      return new DS.InvalidError(payload.errors, errorMessage);
    }

    let errors = this.normalizeErrorResponse(status, headers, payload);

    return new DS.AdapterError(errors, errorMessage);
  }
});
</code></pre>
<p>(Note that the code inside the adapter could be MUCH simpler and cleaner, the above
is a very quick hacked up example! :bomb:)</p>
<p>The intent is to get an error message out of the form:</p>
<ol>
<li>&quot;Ember Data Error&quot;</li>
<li>Request Method &amp; URI</li>
<li>Response Status</li>
<li>Response Content Type</li>
<li>A sane representation of the Response payload</li>
</ol>
<a class="header" href="print.html#drawbacks-18" id="drawbacks-18"><h1>Drawbacks</h1></a>
<p>Adding complexity to an Error handler always runs the risk of generating errors inside
the handler itself, which would not be overly friendly.</p>
<a class="header" href="print.html#alternatives-18" id="alternatives-18"><h1>Alternatives</h1></a>
<p>There's probably quite a few different pieces of information that could be included
in the message.</p>
<p>We could also potentially look at attaching the extra information to other fields on
the <code>AdapterError</code> (and its subclasses). The only drawback there would be that most
error reporters would then not include that information by default.</p>
<a class="header" href="print.html#unresolved-questions-15" id="unresolved-questions-15"><h1>Unresolved questions</h1></a>
<ul>
<li>Exact Error Message Format</li>
</ul>
<ul>
<li>Start Date: 2016-02-11</li>
<li>RFC PR: <a href="https://github.com/emberjs/rfcs/pull/120">emberjs/rfcs#120</a></li>
<li>Ember Issue: https://github.com/emberjs/ember.js/pull/13016</li>
</ul>
<a class="header" href="print.html#summary-19" id="summary-19"><h1>Summary</h1></a>
<p>This RFC proposes replacing the existing <a href="http://emberjs.com/api/classes/Ember.Route.html#method_serialize"><code>Route#serialize</code></a> method with an equivalent method on the options hash passed into <a href="http://emberjs.com/api/classes/Ember.Router.html#method_map"><code>this.route</code> within <code>Router#map</code></a>. The primary goal here is to enable asynchronous Engines by decoupling information about how to link to a route from the actual route object.</p>
<a class="header" href="print.html#motivation-20" id="motivation-20"><h1>Motivation</h1></a>
<p>As we move towards an increasingly asynchronous world with Engines, we need to separate knowledge about how to <em><strong>link</strong> to a route</em> and how to <em><strong>enter</strong> a route</em>. Linking to a route should be able to happen <em>before</em> a route object is instantiated, which is the behavior needed to asynchronously load Engines. However, in our current reality, these concerns are coupled and a route object must be instantiated before being able to link to <em>or</em> enter a route.</p>
<p>By separating these concerns, we can preemptively load the information on how to link to a route without also requiring all the knowledge of how to enter that route. This would be beneficial in both the asynchronous and synchronous worlds by allowing us to defer work.</p>
<p>Since the <code>serialize</code> method is the only method currently used by the <code>Route</code> class to define how to link to a route, the proposal is to extract this method into the space which currently contains the other linking information (e.g., the Router's map).</p>
<p><em><strong>Note:</strong> this separation of concerns will also need to be implemented in router.js for the preemptive loading proposed here to actually work, but we can prepare for that future world by creating a separation of concerns within application code now.</em></p>
<a class="header" href="print.html#detailed-design-17" id="detailed-design-17"><h1>Detailed Design</h1></a>
<p>Since the current API is a simple function, the new hash option will also be a simple function that mirrors the signature of the original. Here's an example:</p>
<pre><code class="language-js">// app/router.js
function serializePostRoute(model, params) {
  // serialize the model into the dynamic paths
}

export default Router.map(function() {
  this.route('post', { path: '/post/:id', serialize: serializePostRoute });
});
</code></pre>
<p>Preserving the current function signature means that refactoring existing code should be simple in most cases. Here's the example currently given in the Ember docs (updated to reflect Ember-CLI):</p>
<pre><code class="language-js">// app/routes/post.js
import Ember from 'ember';
export default Ember.Route.extend({
  model(params) {
    // the server returns `{ id: 12 }`
    return Ember.$.getJSON('/posts/' + params.post_id);
  },

  serialize(model) {
    // this will make the URL `/posts/12`
    return { post_id: model.id };
  }
});

// app/router.js
export default Router.map(function() {
  this.route('post', {
    path: '/post/:id'
  });
});
</code></pre>
<p>Here is that same code refactored for the proposal:</p>
<pre><code class="language-js">// app/routes/post.js
import Ember from 'ember';
export default Ember.Route.extend({
  model(params) {
    // the server returns `{ id: 12 }`
    return Ember.$.getJSON('/posts/' + params.post_id);
  }
});

// app/router.js
function serializePostRoute(model) {
  // this will make the URL `/posts/12`
  return { post_id: model.id };
}

export default Router.map(function() {
  this.route('post', { path: '/post/:id', serialize: serializePostRoute });
});
</code></pre>
<a class="header" href="print.html#migration-plan" id="migration-plan"><h1>Migration Plan</h1></a>
<p>Even though the refactoring needed here is easy, we still need a clear (though simple) migration plan.</p>
<p>The first step will be to introduce the new option into the Router's callback <code>route</code> function. Once that is done, we can deprecate <code>Route#serialize</code> over the remainder of the 2.x series to give developers the time to update their code base. We can then remove support in 3.x.</p>
<p>As noted in the &quot;Motivation&quot; section, there is still work to be done in router.js in order to support this separation of concerns. Due to this, the initial implementation of this new option will essentially be a polyfill that proxies to the corresponding <code>Route#serialize</code> property internally. This will set us up for an internal migration at a later point to actually separate the two; this, however, should not affect developers as it will be internal.</p>
<a class="header" href="print.html#pedagogy-how-we-teach-this" id="pedagogy-how-we-teach-this"><h1>Pedagogy (How We Teach This)</h1></a>
<p>Once the new option is introduced, the Ember guides will need to be updated to reflect this. Those changes should be relatively straightforward as shown in the example above. This will help introduce the feature to new users and those users that haven't used <code>Route#serialize</code> before. Since inline serializers in the router map can be distracting to understanding the general layout of a codebase, we should teach them as defined outside the map itself (as in the code example in this RFC).</p>
<p>For existing users, we can introduce this feature through deprecation warnings (as mentioned above). The deprecations should briefly introduce the new option and point to an appropriate deprecation guide that explains how to migrate.</p>
<a class="header" href="print.html#drawbacks-19" id="drawbacks-19"><h1>Drawbacks</h1></a>
<ul>
<li>Adds another option to the Router map. Though this is largely mitigated due to the fact that this feature is not in wide use currently.</li>
<li>Can be sort of ugly to format.</li>
</ul>
<a class="header" href="print.html#alternatives-19" id="alternatives-19"><h1>Alternatives</h1></a>
<ul>
<li>Introduce a standalone module to represent the <code>Route#serialize</code>. This was the first proposal of this RFC and there is much opposition to introducing yet another construct for Ember-CLI and developers to manage. The approach proposed above avoids this major drawback.</li>
<li>Introduce a holistic construct to represent route linking information. Instead of introducing a new option as a function, we could introduce a class that would represent all the information needed to link to a route. Since there is not currently much other information needed, this seems overkill and would suffer similar opposition as the first alternative.</li>
<li>Don't do this and continue loading and instantiating all route information upfront. This prevents us from improving performance by keeping concerns coupled with prevents introducing async engines. It also requires all Route classes be instantiaed upfront.</li>
</ul>
<a class="header" href="print.html#unresolved-questions-16" id="unresolved-questions-16"><h1>Unresolved Questions</h1></a>
<ul>
<li>Do we wish to apply a similar approach for default query params? And if so, do we wish to incorporate that approach into this new construct?</li>
</ul>
<ul>
<li>Start Date: 2016-04-16</li>
<li>RFC PR: https://github.com/emberjs/rfcs/pull/136</li>
<li>Ember Issue: https://github.com/emberjs/ember.js/pull/13553</li>
</ul>
<a class="header" href="print.html#summary-20" id="summary-20"><h1>Summary</h1></a>
<p><a href="http://emberjs.com/api/classes/Ember.Array.html#method_contains"><code>contains</code></a> is
implemented on <code>Ember.Array</code>, but [contains was renamed to includes in 2014]
(https://github.com/tc39/Array.prototype.includes/commit/4b6b9534582cb7991daea3980c26a34af0e76c6c)</p>
<ul>
<li>this proposal is for <code>contains</code> to be deprecated in favour of an <code>includes</code>
method on <code>Ember.Array</code></li>
</ul>
<a class="header" href="print.html#motivation-21" id="motivation-21"><h1>Motivation</h1></a>
<p>Motivation is to stay in line with web standards</p>
<a class="header" href="print.html#detailed-design-18" id="detailed-design-18"><h1>Detailed design</h1></a>
<p>First, implement <code>includes</code> polyfill in compliance with <code>includes</code> spec. Polyfill
sample from MDN is:</p>
<pre><code class="language-js">if (!Array.prototype.includes) {
  Array.prototype.includes = function(searchElement /*, fromIndex*/ ) {
    'use strict';
    var O = Object(this);
    var len = parseInt(O.length) || 0;
    if (len === 0) {
      return false;
    }
    var n = parseInt(arguments[1]) || 0;
    var k;
    if (n &gt;= 0) {
      k = n;
    } else {
      k = len + n;
      if (k &lt; 0) {k = 0;}
    }
    var currentElement;
    while (k &lt; len) {
      currentElement = O[k];
      if (searchElement === currentElement ||
         (searchElement !== searchElement &amp;&amp; currentElement !== currentElement)) { // NaN !== NaN
        return true;
      }
      k++;
    }
    return false;
  };
}
</code></pre>
<p>Then, alias <code>contains</code> to <code>includes</code> with deprecation warning, deprecate in line with standard
deprecation process. I don't believe that adding the additional parameter will
have any affect on existing usage of <code>contains</code>.</p>
<a class="header" href="print.html#how-we-teach-this-2" id="how-we-teach-this-2"><h1>How We Teach This</h1></a>
<ul>
<li>Update any references in docs and guides to <code>includes</code></li>
<li>Write a deprecation guide, mentioning any edge cases where the new <code>includes</code> behaves differently to <code>contains</code>, and giving migration examples</li>
<li>Indicate in api docs that this is a polyfill</li>
</ul>
<a class="header" href="print.html#drawbacks-20" id="drawbacks-20"><h1>Drawbacks</h1></a>
<ul>
<li>May break existing apps</li>
<li><a href="https://github.com/emberjs/ember.js/issues/5670#issuecomment-64084814">Was considered before but was too early</a></li>
</ul>
<a class="header" href="print.html#alternatives-20" id="alternatives-20"><h1>Alternatives</h1></a>
<p>Keep current methods</p>
<a class="header" href="print.html#unresolved-questions-17" id="unresolved-questions-17"><h1>Unresolved questions</h1></a>
<p>None</p>
<ul>
<li>Start Date: 2016-04-18</li>
<li>RFC PR: <a href="https://github.com/emberjs/rfcs/pull/139">#139</a></li>
<li>Ember Issue: <a href="https://github.com/emberjs/ember.js/pull/13666">emberjs/ember.js#13666</a></li>
</ul>
<a class="header" href="print.html#summary-21" id="summary-21"><h1>Summary</h1></a>
<p>Introduce <code>Ember.String.isHtmlSafe()</code> to provide a reliable way to determine if an object is an &quot;html safe string&quot;, i.e. was it created with <code>Ember.String.htmlSafe()</code>.</p>
<a class="header" href="print.html#motivation-22" id="motivation-22"><h1>Motivation</h1></a>
<p>Using <code>new Ember.Handlebars.SafeString()</code> is slated for deprecation. Many people are currently using the following snippet as
a mechanism of type checking: <code>value instanceof Ember.Handlebars.SafeString</code>. Providing <code>isHtmlSafe</code> offers a
cleaner method of detection. Beyond that, the aforementioned test is a bit leaky. It requires the developer to understand
<code>htmlSafe</code> returns a <code>Ember.Handlerbars.SafeString</code> instance and thus limits Ember's ability to change
<code>htmlSafe</code> without further breaking it's API.</p>
<p>Based on our app at Batterii and some research on Github, I see two valid use cases for introducing this API.</p>
<p>First, and most commonly, is to make it possible to test addon helpers that are expected to return a safe string. I believe this test on ember-i18n says it all: <a href="https://github.com/jamesarosen/ember-i18n/blob/master/tests/unit/utils/i18n/default-compiler-test.js#L56-L59">&quot;returns HTML-safe string&quot;</a>.</p>
<p>The second use case is to do type checking. In our app, we have an <code>isString</code> utility that is effectively:</p>
<pre><code class="language-javascript">import Ember from 'ember';

export default function(value) {
  return typeof value === 'string' || value instanceof Ember.Handlebars.SafeString;
}
</code></pre>
<p>Newer versions of ember-i18n, doing <code>this.get('i18n').t('someTranslatedValue')</code> will return a safe string. Thus our <code>isString</code> utility has to consider that.</p>
<a class="header" href="print.html#detailed-design-19" id="detailed-design-19"><h1>Detailed design</h1></a>
<p><code>isHtmlSafe</code> will be added to the <code>Ember.String</code> module. The implementation will basically be:</p>
<pre><code class="language-javascript">function isHtmlSafe(str) {
  return str &amp;&amp; typeof str.toHTML === 'function';
}
</code></pre>
<p>It will be used as follows:</p>
<pre><code class="language-javascript">if (Ember.String.isHtmlSafe(str)) {
  str = str.toString();
}
</code></pre>
<a class="header" href="print.html#transition-path-2" id="transition-path-2"><h1>Transition Path</h1></a>
<p>As part of landing <code>isHtmlSafe</code> we will simultaneously re-deprecate <code>Ember.Handlebars.SafeString</code>. This deprecation will
take care to ensure that <code>str instanceof Ember.Handlebars.SafeString</code> still passes so that we can continue to
maintain backwards compatibility.</p>
<p>Additionally, a polyfill will be implemented to help provide forward compatibility for addon maintainers and others
looking to get a head while still on older versions of Ember. Similar to <a href="https://github.com/rwjblue/ember-getowner-polyfill">ember-getowner-polyfill</a>.</p>
<a class="header" href="print.html#how-we-teach-this-3" id="how-we-teach-this-3"><h1>How We Teach This</h1></a>
<p>I think we'll continue to refer to these strings as &quot;html safe strings&quot;. This RFC does not
introduce any new concepts, rather it builds on an existing concept.</p>
<p>I don't believe this feature will require guide discussion. I think API Docs will suffice.</p>
<p>The concept of type checking is a pretty common programming idiom. It should be relatively self
explanatory.</p>
<a class="header" href="print.html#drawbacks-21" id="drawbacks-21"><h1>Drawbacks</h1></a>
<p>The only drawback I see is that it expands the surface of the API and it takes a step
towards prompting &quot;html safe string&quot; as a thing.</p>
<a class="header" href="print.html#alternatives-21" id="alternatives-21"><h1>Alternatives</h1></a>
<p>An alternative would be to expose <code>Ember.Handlerbars.SafeString</code> publicly once again. Users
could revert back to using <code>instanceof</code> as their type checking mechanism.</p>
<a class="header" href="print.html#unresolved-questions-18" id="unresolved-questions-18"><h1>Unresolved questions</h1></a>
<p>There are no unresolved questions at this time.</p>
<ul>
<li>Start Date: 2016-05-09</li>
<li>RFC PR: https://github.com/emberjs/rfcs/pull/143</li>
<li>Ember Issue: https://github.com/emberjs/ember.js/issues/14882</li>
</ul>
<blockquote>
<p>Note: This RFC replaces the closely related RFC for <a href="https://github.com/emberjs/rfcs/pull/124">Module
Normalization</a>. As discussed in the
<a href="print.html#alternatives">Alternatives</a> section below, many concepts are shared between
the two proposals, but there is also a fundamental difference.</p>
</blockquote>
<a class="header" href="print.html#summary-22" id="summary-22"><h1>Summary</h1></a>
<p>Create a unified pattern for organizing and naming modules in Ember projects
that is deterministic, extensible, and ergonomic.</p>
<a class="header" href="print.html#motivation-23" id="motivation-23"><h1>Motivation</h1></a>
<p>Ember CLI's conventions for project layouts and file naming are central to every
Ember developer's experience. It's crucial to get both the technical and
ergonomic details right.</p>
<p>The existing conventions used by Ember CLI have evolved gradually and
organically over the years. Ember CLI and its predecessor Ember App Kit were
early adopters of ES modules and have always leveraged strong conventions to
deduce an understanding of modules based on their locations. Ember CLI's
resolver encodes those conventions to enable run-time module resolutions.</p>
<p>The current system works fairly well, but has some complexities and
inconsistencies that both steepen its learning curve and limit its technical
potential.</p>
<p>Drawbacks include:</p>
<ul>
<li>
<p>Confusion over which of two orthogonal approaches to use for organizing
modules:</p>
<ul>
<li>
<p>classic - modules are organized at the top-level by &quot;type&quot;
(<code>components</code>, <code>templates</code>, etc.) and then by namespace and name.</p>
</li>
<li>
<p>pods - modules are organized by namespace, then name, then type.</p>
</li>
</ul>
</li>
<li>
<p>Addons define modules to be merged into an application through a special <code>app</code>
directory. These public modules are typically private modules that are
imported and re-exported, which introduces an extra module per export and an
extra level of abstraction to learn.</p>
</li>
<li>
<p>Because addons' modules are mixed into an application, there's the possibility
of naming collisions between two addons or an addon and its consuming
application.</p>
</li>
<li>
<p>Modules don't have a clear sense of &quot;locality&quot;, which prevents the ability to
declare modules that are available only in a &quot;local&quot; namespace (this as-yet
unsupported feature has been called &quot;local lookup&quot;).</p>
</li>
<li>
<p>Resolution rules that are declared only in JavaScript are difficult to
analyze and optimize.</p>
</li>
<li>
<p>Module resolution is inefficient due to the number of potential places to
lookup a particular module by name.</p>
</li>
</ul>
<p>Recognizing these drawbacks, the Core Team compiled a set of
<a href="https://github.com/emberjs/core-notes/blob/master/ember.js/2016-01/january-22.md#summary-of-pods-design-constraints">design constraints</a>
for a rethink of Ember's approach to modules:</p>
<ol>
<li>Reasonable branching factor. Users should see a reasonable number of items at any given level in their hierarchy. Flattening out too much results in an unreasonably large number of items.</li>
<li>No slashes in component names. The existing system allows this, but we don't want to support invocation of nested components in Glimmer Components.</li>
<li>Addons need to participate in the naming scheme, most likely with namespace prefix and double-colon separator.</li>
<li>Subtrees should be relocatable. If you move a directory to a new place in the tree, its internal structure should all still work.</li>
<li>There should be no cognitive overhead when adding a new thing. The right way should be obvious and not impose unnecessary decisions.</li>
<li>We need clean separation between the namespace of the user's own components, helpers, routes, etc and the framework's own type names (&quot;component&quot;, &quot;helper&quot;, etc) so that we can disambiguate them and add future ones.</li>
<li>Ideally we will have a place to put tests and styles alongside corresponding components.</li>
<li>Local relative lookup for components and helpers needs to work.</li>
<li>Avoid the &quot;titlebar problem&quot;, in which many files are all named &quot;component.js&quot; and you can't tell them apart in your editor.</li>
<li>The resolver should be configured via declarative rules, not imperative
JavaScript. In addition to enforcing consistency, this allows addons to
augment the system with their own types in a predictable way.</li>
<li>Module structures must be statically analyzable at build time to enable
efficiency optimizations.</li>
<li>Module classifications must be extensible and allow for customizations by
apps, engines, and addons.</li>
</ol>
<blockquote>
<p>Note: Constraints &gt; 9 were added based on discussions subsequent to the
initial meeting.</p>
</blockquote>
<p>This proposal attempts to address these constraints with a single consistent
approach to modules that will make Ember easier to use and learn <em>and</em> improve
the efficiency of Ember's resolver at run-time.</p>
<a class="header" href="print.html#detailed-design-20" id="detailed-design-20"><h1>Detailed Design</h1></a>
<p>This proposal introduces a new top-level directory, <code>src</code>, and establishes
conventions for organizing modules within it. Also proposed is a refactor of the
Ember resolver to enable efficient and flexible resolutions based upon the new
module conventions.</p>
<p>The <code>src</code> directory will be used to contain the core ES modules within an Ember
CLI project, whether that project contains an application, addon, or engine. To
maintain backward compatibility, the <code>src</code> directory will be allowed to
co-exist alongside existing <code>app</code> and/or <code>addon</code> directories, although these
directories should eventually be deprecated.</p>
<a class="header" href="print.html#examples" id="examples"><h2>Examples</h2></a>
<p>Let's start by taking a look at some examples of Ember projects organized
according to the proposed conventions.</p>
<a class="header" href="print.html#example-application" id="example-application"><h3>Example Application</h3></a>
<p>A simple blogging application could be structured as follows:</p>
<pre><code>src
 data
    models
       comment
          adapter.js
          model.js
          serializer.js
       post
          adapter.js
          model.js
          serializer.js
       author.js
    transforms
        date.js
 init
    initializers
       i18n.js
    instance-initializers
        auth.js
 services
    auth.js
 ui
    components
       date-picker
          component.js
          template.hbs
       list-paginator
           paginator-control
              component.js
              template.hbs
           component.js
           template.js
    partials
       footer.hbs
    routes
       application
          template.hbs
       index
          controller.js
          route.js
          template.hbs
       posts
           -components
              -utils
                 strings.js
              capitalize.js
              titleize.js
           post
              -components
                 post-viewer
                     component.js
                     template.hbs
              edit
                 -components
                    post-editor
                       post-editor-button
                          component.js
                          template.hbs
                       calculate-post-title.js
                       component.js
                       template.hbs
                    route.js
                    template.hbs
                 route.js
                 template.hbs
              route.js
              template.hbs
           route.js
           template.hbs
    styles
       app.scss
    index.html
 utils
    md5.js
 main.js
 router.js
</code></pre>
<a class="header" href="print.html#example-engine" id="example-engine"><h3>Example Engine</h3></a>
<p>An engine could provide the same blogging functionality with almost entirely the
same module structure as the example blog application. Only the following
notable changes would be needed:</p>
<ul>
<li>An engine should declare its routes in <code>src/routes.js</code> instead of <code>src/router.js</code></li>
<li>An engine would require a <code>dummy</code> app within <code>tests</code></li>
<li>An engine should export an <code>Engine</code> instead of an <code>Application</code> from <code>src/main.js</code></li>
</ul>
<a class="header" href="print.html#example-addon" id="example-addon"><h3>Example Addon</h3></a>
<p>Here's how the
<a href="https://github.com/cibernox/ember-power-select">ember-power-select</a> addon could
be restructured:</p>
<pre><code>src
 styles
  ember-power-select.scss
 ui
  components
      main
       before-options
        component.js
        template.hbs
       options
        component.js
        template.hbs
       trigger
        component.js
        template.hbs
       component.js
       template.hbs
      multiple
       trigger
        component.js
        template.hbs
       component.js
       template.hbs
      is-selected.js
 main.js
</code></pre>
<a class="header" href="print.html#migration-tool" id="migration-tool"><h3>Migration Tool</h3></a>
<p>As a proof of concept for the module layout described in this RFC, Robert
Jackson has created a <a href="https://github.com/rwjblue/ember-module-migrator">migration
tool</a> and used it to migrate
the following repos:</p>
<ul>
<li><a href="https://github.com/rwjblue/--ghost-modules-sample/tree/grouped-collections/src">Ghost admin client</a></li>
<li><a href="https://github.com/rwjblue/--travis-modules-sample/tree/modules/src">Travis client</a></li>
<li><a href="https://github.com/rwjblue/--new-app-blueprint/tree/modules/src"><code>ember new my-app</code></a></li>
</ul>
<p>You can also use Robert's migration tool on your own projects to gain a feel for
how this RFC will affect your work.</p>
<a class="header" href="print.html#es-modules" id="es-modules"><h2>ES Modules</h2></a>
<p>It's important to understand how ES module paths are mapped from the file
system so that you can import modules from elsewhere in your project and its
associated dependencies.</p>
<p>ES module paths will be formed from a project's package name followed by a
direct mapping of file paths from the project root. The file's final extension
(e.g. <code>js</code> or <code>hbs</code>) will be excluded because all ES modules will of course be
compiled into JavaScript from their original format.</p>
<p>For example, the file <code>src/ui/components/date-picker.js</code> in the
<code>my-calendar</code> app will be exported with the module path
<code>my-calendar/src/ui/components/date-picker</code>.</p>
<p>An application and its associated addons and engines will all be merged into the
same ES module space, as is done today. Any module can import from any other
module within this space, although cross-package imports should be done with
care.</p>
<a class="header" href="print.html#module-naming-and-organization" id="module-naming-and-organization"><h2>Module Naming and Organization</h2></a>
<p>This section describes the conventions proposed for naming and organizing a
project's modules within <code>src</code>. These conventions will allow Ember CLI's
resolver to determine the purpose of each module at run-time. They will also
enable static analysis of modules to lint against errors and to prepare a
normalized map for efficient resolutions.</p>
<p>Every resolvable module must have both a <code>name</code> and a <code>type</code>. The <code>type</code>
typically corresponds to the base class of the module's default export (e.g.
<code>route</code>, <code>template</code>, etc.).</p>
<p>Modules can be grouped together with other modules of related types in
&quot;collections&quot;. Collections are directories with type-aware resolution rules
which allow related modules to share a namespace. For example, the <code>models</code>
collection contains models, adapters, and serializers.</p>
<p>Collections that are related to each other can be further organized in &quot;group&quot;
directories. For example, the <code>ui</code> group contains the <code>components</code>, <code>partials</code>,
and <code>routes</code> collections.</p>
<p>Ember CLI will have a build step that normalizes modules to a common form and
builds a mapping between that form and the ES module path described above.
While building this normalized map, the build must error and provide useful
messages if any module naming errors are detected. Unregistered collections and
types should not be allowed. Also, the same normalized module path must not be
repeated through alternative naming forms.</p>
<a class="header" href="print.html#module-type" id="module-type"><h3>Module Type</h3></a>
<p>The type of a module can be determined through the following file naming and
module export rules:</p>
<ol>
<li><code>src/${type}</code> - typed modules named <code>main</code> (explained further below), in
which default exports match the type specified by the file name.</li>
<li><code>src/${collection}/${namespace}/${name}/${type}</code> - expanded collection
modules, in which default exports match the type specified by the file name.</li>
<li><code>src/${collection}/${namespace}/${name}</code> - in which type can be inferred
based on the module's exports. Default exports must match the default
type for the collection. If there is no default export, named exports will
be scanned for a matching type allowed in the collection.</li>
</ol>
<p>Note that template precompilers will need to use default vs. named exports
appropriately in order to satisfy the expectations of Rules 2 and 3.</p>
<p>Here are a few example applications of the module type determination rules:</p>
<pre><code>// Rule 1

src/router (with `export default Ember.Router.extend()`)
=&gt; name: 'main',
   type: 'router'

// Rule 2

src/ui/routes/posts/post/route.js (with `export default Ember.Route.extend()`)
=&gt; collection: 'ui/routes',
   namespace: 'posts',
   name: 'post',
   type: 'route'

src/ui/routes/posts/post/template (with `export default Ember.HTMLBars.template(COMPILED)`)
=&gt; collection: 'ui/routes',
   namespace: 'posts',
   name: 'post',
   type: 'template'

// Rule 3

src/data/models/author (with `export default DS.Model.extend()`)
=&gt; collection: 'data/models',
   name: 'author',
   type: 'model' (the default type for the models collection)

src/ui/components/titleize (with `export let helper = Ember.Helper.helper(function() { })`)
=&gt; collection: 'ui/components',
   name: 'titleize',
   type: 'helper'

src/ui/components/show-title (with `export let template = Ember.HTMLBars.template(COMPILED)`)
=&gt; collection: 'ui/components',
   name: 'show-title',
   type: 'template'
</code></pre>
<a class="header" href="print.html#main-modules" id="main-modules"><h3>Main Modules</h3></a>
<p>Every project must have a &quot;main&quot; module, named <code>src/main.js</code>, that
serves as an entry point into the project.</p>
<p>The main module must export an <code>Application</code>, <code>Engine</code>, or (new) <code>Addon</code> class.
This class must define a <code>modulePrefix</code>, which must match the node package name
for the project.</p>
<p>The main module also declares other properties that help the Ember resolver
understand relationships between projects. For instance, the main module can
declare which modules in an addon are available to a consuming app's resolver.</p>
<p>The main module of an addon can also declare a <code>rootName</code>, which is used by the
resolver to lookup main modules. Initially, the <code>rootName</code> will be a read-only
property that equals the <code>modulePrefix</code> with any <code>ember-</code> and  <code>ember-cli-</code>
prefixes stripped (e.g. <code>ember-power-select</code> becomes <code>power-select</code>). It's
possible that we may allow overrides / aliases in the future.</p>
<p>Modules that appear alongside <code>main.js</code> in <code>src</code> are also considered <code>main</code>
modules for their respective <code>type</code>. For instance, <code>src/router.js</code> is registered
with a <code>name</code> of <code>main</code> and a <code>type</code> of <code>router</code>.</p>
<a class="header" href="print.html#module-collections" id="module-collections"><h3>Module Collections</h3></a>
<p>Top-level namespaces within <code>src</code> serve to group modules into
type-aware &quot;collections&quot;.</p>
<p>The following rules apply to module collections and types:</p>
<ol>
<li>Each collection can contain one or more types. The types allowed
in a particular collection MUST be explicitly declared.</li>
<li>Each type MAY exist in any number of collections.</li>
<li>Each type MUST have only one &quot;definitive collection&quot;, which is the
collection the resolver will use for resolutions if a module can't be found
in the local (i.e. originating) collection.</li>
<li>Each collection MAY have a single &quot;default type&quot;. If a module does not
indicate its type through its file name, then its default export should
align with the default type for its collection.</li>
<li>Each collection can allow &quot;private collections&quot; to be defined at a namespace.
Private collections are localized additions to a top-level collection,
available only from the namespace at which they're defined.</li>
<li>Top-level collections may be grouped for organization purposes. No
resolvable modules must be placed in a group directory.</li>
<li>A collection can appear only once in a project (i.e. it can not be
contained in multiple group directories, or in a group as well as at the
top-level).</li>
</ol>
<p>The following collections and allowed types (rules 1 &amp; 2) are proposed:</p>
<ul>
<li><code>components</code> - COMPONENT, HELPER, template</li>
<li><code>initializers</code> - INITIALIZER</li>
<li><code>instance-initializers</code> - INSTANCE-INITIALIZER</li>
<li><code>models</code> - MODEL, ADAPTER, SERIALIZER</li>
<li><code>partials</code> - PARTIAL</li>
<li><code>routes</code> - ROUTE, CONTROLLER, template</li>
<li><code>services</code> - SERVICE</li>
<li><code>transforms</code> - TRANSFORM</li>
<li><code>utils</code> - UTIL</li>
</ul>
<blockquote>
<p>Note: ALL CAPS indicates which collections are definitive (rule 3) for a type.</p>
</blockquote>
<p>The following default types are proposed for collections (rule 4):</p>
<ul>
<li><code>components</code> - component</li>
<li><code>initializer</code> - initializer</li>
<li><code>instance-initializers</code> - instance-initializer</li>
<li><code>models</code> - model</li>
<li><code>partials</code> - partial</li>
<li><code>routes</code> - route</li>
<li><code>services</code> - service</li>
<li><code>transforms</code> - transform</li>
<li><code>utils</code> - util</li>
</ul>
<p>The following private collections are allowed within collections (rule 5):</p>
<ul>
<li><code>components</code> - utils</li>
<li><code>models</code> - utils</li>
<li><code>initializers</code> - utils</li>
<li><code>instance-initializers</code> - utils</li>
<li><code>routes</code> - components, utils</li>
<li><code>services</code> - utils</li>
<li><code>transforms</code> - utils</li>
</ul>
<p>The following groups are proposed for collections (rule 6):</p>
<ul>
<li><code>data</code> - models, transforms</li>
<li><code>init</code> - initializers, instance-initializers</li>
<li><code>ui</code> - components, partials, routes</li>
</ul>
<p>The collection and type system is designed to be extensible, so that addons can
contribute their own collections and types. The <code>data</code> collection and its
corresponding types should be defined in ember-data. Liquid-fire might want to
define an <code>animations</code> collection and a <code>transition</code> type, and expand <code>routes</code>
to allow <code>animations</code> as a private collection.</p>
<p>The specific format of collection and type declarations for addons is TBD.</p>
<a class="header" href="print.html#components-collection" id="components-collection"><h4>&quot;Components&quot; Collection</h4></a>
<p>This proposal broadens the scope of the term &quot;component&quot; to include all
template-invocable parts of Ember. This includes today's components and helpers,
and the future implementation of &quot;glimmer components&quot; (with angle brackets) and
element modifiers.</p>
<p>Grouping template-invocable elements together in a single collection recognizes
that they already coexist in the same namespace. After all, only one helper OR
component can be invoked as <code>{{foo-bar}}</code>. Using a common collection will not
only simplify file management and searching, it will also provide implicit
linting against creating a helper and class-based component of the same name.</p>
<a class="header" href="print.html#private-collections" id="private-collections"><h4>Private Collections</h4></a>
<p>You may wish to make a component available in a particular template without
polluting the top-level <code>components</code> collection with a more local concern.
Private collections allow you to augment a top-level collection's contents for
use at a particular namespace.</p>
<p>Private collections are declared as a directory sharing the name of the
top-level collection, prefixed with a <code>-</code>. So the top-level <code>routes</code>
collection could be augmented via a private <code>-components</code> collection.</p>
<p>Say that you want to define a <code>post-viewer</code> component to be available only from
within <code>src/ui/routes/posts/post/template.hbs</code>. You could achieve this by
creating your component module in
<code>src/ui/routes/posts/post/-components/post-viewer.js</code>.</p>
<a class="header" href="print.html#non-resolved-files" id="non-resolved-files"><h4>Non-resolved Files</h4></a>
<p>The rules above apply to modules that are resolved, namely <code>*.js</code> and <code>*.hbs</code>
files. Other files that are used for documenting code, such as <code>*.md</code> and
<code>*.html</code> files, can be freely co-located in any directories.</p>
<p>Conventions will still be used for non-resolved files that have significance
within an Ember project, including:</p>
<ul>
<li><code>src/ui/styles</code> - A project's stylesheets.</li>
<li><code>src/ui/index.html</code> - A project's html container.</li>
</ul>
<a class="header" href="print.html#packages" id="packages"><h3>Packages</h3></a>
<p>In-repo addons (including engines) will be placed in a new top-level <code>packages</code>
directory (a sibling of <code>src</code>). We can begin to use the term &quot;packages&quot; instead
of the rather clumsy &quot;in-repo addons&quot;. This differentiation will emphasize that
packages are internal and addons are external to a project. Packages should be
seen as a lightweight way to add new namespacing within a project without the
overhead of a full addon.</p>
<p>The <code>packages</code> directory will provide a separate space away from other library
modules that might be kept in <code>lib</code>, the current directory used for in-repo
addons. Introducing a new top-level directory will allow a clear migration path
for in-repo addons, in the same way that there's a clear migration path from
<code>app</code> to <code>src</code>.</p>
<p>Inside <code>packages</code>, packages should be grouped by name. Each package can have
its own <code>index.js</code>, <code>package.json</code>, and <code>src</code> directory.</p>
<a class="header" href="print.html#ember-resolver-refactor" id="ember-resolver-refactor"><h2>Ember Resolver Refactor</h2></a>
<p>The Ember resolver must be refactored significantly to be made aware of the
new <code>src</code> and <code>packages</code> directories and associated conventions.</p>
<a class="header" href="print.html#module-normalization" id="module-normalization"><h3>Module Normalization</h3></a>
<p>As discussed above, Ember CLI will perform a normalization process for all the
modules in a project and its associated projects. The normalization step will
involve the construction of a map from each module's normalized form to its
corresponding ES module path. If any conflicts are detected, the process should
error and notify the developer.</p>
<p>The Ember resolver will only look up modules in their normalized form, utilizing
the pre-built normalization map to resolve the actual module path.</p>
<a class="header" href="print.html#addon-modules" id="addon-modules"><h3>Addon modules</h3></a>
<p>A resolver will only implicitly consider an addon's top-level modules named
<code>main</code> (e.g. a <code>main</code> component) to be public and available for resolution. More
explicit control over an addon's public modules can be declared in the addon's
<code>main</code> module (details TBD). An addon's public modules will all be resolvable at
the <code>rootName</code> of the addon (see above).</p>
<p>Public components and helpers can be invoked in templates using the <code>rootName</code>
as a namespace. For modules named <code>main</code>, the bare root name will suffice.</p>
<p>Let's say that the <code>ember-power-select</code> addon has a <code>rootName</code> of <code>power-select</code>
and a top-level <code>main</code> component declared in <code>src/ui/components/main.js</code>. An
app could invoke this component in a template as <code>{{power-select::main}}</code> or
more simply as <code>{{power-select}}</code>.</p>
<p>Addons should use the same namespacing that will be used by consuming apps when
invoking their own components and helpers from templates. For instance, if the
<code>ember-power-select</code> addon has a <code>date-picker</code> component that invokes multiple
<code>main</code> components, it should also invoke them in a template as
<code>{{power-select::main}}</code> or more simply as <code>{{power-select}}</code>.</p>
<a class="header" href="print.html#module-resolutions" id="module-resolutions"><h3>Module Resolutions</h3></a>
<p>Module resolution rules must account for the following:</p>
<ul>
<li>The requested module's <code>type</code>, <code>name</code>, and (potentially) <code>namespace</code>.</li>
<li>(Optional) A &quot;source&quot; <code>rootName</code>, collection, and namespace from which the
lookup originates.</li>
<li>(Optional) An &quot;associated type&quot; for lookups that should start in a collection
that is not definitive for the requested <code>type</code>.</li>
</ul>
<p>Module resolutions occur in the following order:</p>
<ol>
<li>Local - If a source module is specified and the requested type is allowed in
the source module's collection, look in a namespace based on the source
module's namespace + name.</li>
<li>Private - If a source module is specified, look in a private collection at
the source module's namespace, if one exists that is definitive for the
requested type.</li>
<li>Associated - If an associated type is specified, look in the definitive
collection for that associated type. Only resolve if the collection can
contain the requested type.</li>
<li>Top-level - In the definitive collection for the requested type, defined at
its top-level.</li>
</ol>
<p>The resolver must maintain mappings of modules at multiple levels to make these
resolutions efficient. A lookup tree can be pre-built for production builds.</p>
<a class="header" href="print.html#example-resolutions" id="example-resolutions"><h4>Example Resolutions</h4></a>
<p>Let's walk through some example resolutions from the above blogging app paired
with the <code>ember-power-select</code> addon. We'll assume that the package name for
the app is <code>blogmeister</code>, and the package name for the addon is
<code>ember-power-select</code>. The addon has a <code>rootName</code> of <code>power-select</code> for cleaner
references.</p>
<hr />
<p>From <code>blogmeister/src/ui/components/list-paginator/template</code>:</p>
<p><code>{{paginator-control}}</code> resolves to <code>blogmeister/src/ui/components/list-paginator/paginator-control/component</code></p>
<p><code>{{date-picker}}</code> resolves to <code>blogmeister/src/ui/components/date-picker/component</code></p>
<p><code>{{power-select}}</code> resolves to <code>ember-power-select/src/ui/components/main/component</code></p>
<p><code>{{power-select::multiple}}</code> resolves to <code>ember-power-select/src/ui/components/multiple/component</code></p>
<hr />
<p>From <code>blogmeister/src/routes/posts/post/template</code>:</p>
<p><code>{{post-viewer}}</code> resolves to <code>blogmeister/src/ui/routes/posts/post/-components/post-viewer/component</code></p>
<p><code>{{date-picker}}</code> resolves to <code>blogmeister/src/ui/components/date-picker/component</code></p>
<p><code>{{power-select}}</code> resolves to <code>ember-power-select/src/ui/components/main/component</code></p>
<a class="header" href="print.html#other-refactorings" id="other-refactorings"><h2>Other Refactorings</h2></a>
<a class="header" href="print.html#generators-and-blueprints" id="generators-and-blueprints"><h3>Generators and Blueprints</h3></a>
<p>Generators and blueprints will need to be made aware of the new module
conventions.</p>
<p>Let's take a look at the files that some generators will create (note: tests
have been left out of these examples for now):</p>
<p><code>ember g component date-picker</code>:</p>
<ul>
<li><code>src/ui/components/date-picker/component.js</code></li>
<li><code>src/ui/components/date-picker/template.hbs</code></li>
</ul>
<p><code>ember g component ui/routes/posts/post-editor</code>:</p>
<ul>
<li><code>src/ui/routes/posts/-components/post-editor/component.js</code></li>
<li><code>src/ui/routes/posts/-components/post-editor/template.hbs</code></li>
</ul>
<p><code>ember g helper titleize</code>:</p>
<ul>
<li><code>src/ui/components/titleize.js</code></li>
</ul>
<a class="header" href="print.html#how-we-teach-this-4" id="how-we-teach-this-4"><h1>How We Teach This</h1></a>
<p>The Ember guides will need to be updated significantly to reflect the new
conventions.</p>
<a class="header" href="print.html#teaching-conventions-through-tooling" id="teaching-conventions-through-tooling"><h2>Teaching Conventions through Tooling</h2></a>
<p>As discussed above, generators and blueprints will be made aware of the new
module conventions. This will help new projects start on track and stay on
track as modules are added.</p>
<p>Developers with existing projects will be able to use Robert Jackson's
<a href="https://github.com/rwjblue/ember-module-migrator">migration tool</a> to move their
projects over to use the new conventions. This tool is a WIP and will continue
to be refined to work well with both the classic and pods structures. It's
possible these migration capabilities will eventually be rolled into Ember
Watson.</p>
<p>Furthermore, the Ember Inspector should be enhanced to understand the new
conventions and become more type and collection aware.</p>
<a class="header" href="print.html#new-concepts" id="new-concepts"><h2>New Concepts</h2></a>
<p>It will be important for both new and experienced Ember developers to
understand some core concepts that are proposed in this RFC.</p>
<a class="header" href="print.html#collections-and-types" id="collections-and-types"><h3>Collections and Types</h3></a>
<p>This proposal's concept of collections and types should feel familiar enough to
users of both the classic and pods layouts to enable a smooth transition. In
many ways, this proposal merges the classic and pods layouts into a single
uniform layout.</p>
<p>The core driver to collections is to store &quot;like with like&quot;. However, instead of
the classic layout's narrow definition of &quot;like&quot; to be of a <em>single</em> type, this
proposal takes the pods approach that <em>multiple</em> types can be related. A good
test of whether multiple module types should be stored together is whether they
should be considered to share a common namespace. Routes, controllers, and
templates are a good example, as are models, adapters, and serializers.</p>
<p>A related concept to understand about collections is the notion of a default
type. Every top-level module within a collection can be considered to match its
default type (unless named exports are used in those modules to represent types
other than the default). Within a collection's namespaces, every module must be
either that default type or related to it. It's helpful to consider that every
namespace within a collection represents a set of named module exports, and that
the default type represents the default export for that collection.</p>
<p>Here's an illustration of exports from a collection:</p>
<pre><code>src
  data
    models
      author.js &lt;- exports an Author `model`, the default type in the `models` collection
      comment
        adapter.js     &lt;- exports a Comment `adapter`
        model.js       &lt;- exports a Comment `model`
        serializer.js  &lt;- exports a Comment `serializer`
</code></pre>
<a class="header" href="print.html#components" id="components"><h4>Components</h4></a>
<p>The term &quot;component&quot; has been widely adopted across most front-end frameworks
to describe a broad swath of UI concerns. Using the same term for the collection
of template-invocable UI elements will lower the learning curve for developers
who are new to Ember, while allowing for a useful set of specialized terms to
flourish to describe particular <em>types</em> of components.</p>
<p>We've already started down the road of component specialization by introducing
the concept of &quot;routable components&quot;. Once we start actually using &quot;routable
components&quot; in practice, it will become necessary to refer to plain old
components as something more specific, like &quot;template components&quot;. And this
distinction will probably lead to plain old helpers being referred to as
&quot;template helpers&quot;. Other concepts, such as &quot;Glimmer components&quot; and &quot;template
component modifiers&quot; will soon be mixed in. We will end up with a multi-faceted
toolbox available at the template layer which deserves a simple name that
matches developer expectations. The general term &quot;components&quot; seems a good fit.</p>
<a class="header" href="print.html#scope" id="scope"><h3>Scope</h3></a>
<p>Developers should understand the available levels of module scope, as well as
when each is appropriate to use. Scope should be considered when modules are
generated, and developers should feel free to move modules if they expand or
contract in scope.</p>
<p>The following levels of scope should be understood:</p>
<ul>
<li>
<p>Private - private collections should be used when a component or utility
function is needed from a single namespace.</p>
</li>
<li>
<p>Project - top-level, project-wide collections should be used for modules that
are needed throughout a project.</p>
</li>
<li>
<p>Local package - namespaced collections can be useful to group a common set of
cross-cutting concerns within a project.</p>
</li>
<li>
<p>Local engine - a type of local package that encapsulates a set of
functionality that benefits from run-time isolation and strict dependency
sharing.</p>
</li>
</ul>
<a class="header" href="print.html#testing" id="testing"><h3>Testing</h3></a>
<p>Unit, integration, and some acceptance tests can now be co-located with their
associated modules. Co-location should be encouraged because it makes test
modules easier to locate in the file system, and easier to move if a module's
scope changes.</p>
<p>Robert Jackson plans to adapt the
<a href="https://github.com/emberjs/rfcs/pull/119">Grand Testing Unification RFC</a>
to illustrate test co-location and to introduce module types for tests.</p>
<a class="header" href="print.html#drawbacks-22" id="drawbacks-22"><h1>Drawbacks</h1></a>
<p>Any change to a pattern as fundamental as file naming will incur some mental
friction for developers who are accustomed to the current conventions. It is
hoped that tooling like Robert's migrator and Ember Watson can lessen this
friction by automating transitions, and that updated guides, generators, and
blueprints can make these conventions easy to follow.</p>
<p>Of course, we won't prevent usage of the currently used patterns for some time,
but they will eventually be deprecated. Some efficiencies, especially in the
resolver, may not be fully realized until the new patterns are used throughout
a project.</p>
<a class="header" href="print.html#alternatives-22" id="alternatives-22"><h1>Alternatives</h1></a>
<a class="header" href="print.html#the-module-normalization-rfc" id="the-module-normalization-rfc"><h2>The Module Normalization RFC</h2></a>
<p>Perhaps the most prominent alternative that has been explored is the
<a href="https://github.com/emberjs/rfcs/pull/124">Module Normalization RFC</a>. Module
Unification shares many aspects with Module Normalization, but with one
fundamental difference: buckets in Module Normalization are normalized away
for the resolver, while collections in Module Unification play an important
role in module resolution.</p>
<p>The Ember Core Team decided that the sleight of hand required to allow buckets
to be used for organization only, and not for resolution, could create
confusion. Essentially, modules could conflict across buckets, because they
could have matching namespaces, names, and types. This kind of conflict could
not be allowed, so developers would need to understand too much about the
resolution strategy to make it ergonomic.</p>
<a class="header" href="print.html#other-alternatives" id="other-alternatives"><h2>Other Alternatives</h2></a>
<p><a href="https://gist.github.com/dgeb/396fed953184acb04f4f">A large number of other alternatives have been explored</a>
before settling on this recommendation. Feel free to explore the history of any
of the linked gists to understand some of the subtle alternatives.</p>
<p>Of course, one alternative is to simply not change anything and accept the
drawbacks discussed in the Motivation section above. However, even if we accept
inefficiencies in our resolver and confusion over divergent file structuring
strategies, we still need to solve the &quot;local lookup&quot; problem, which does not
have a clean solution in today's module system.</p>
<a class="header" href="print.html#unresolved-questions-19" id="unresolved-questions-19"><h1>Unresolved questions</h1></a>
<a class="header" href="print.html#how-should-tests-be-co-located-in-src" id="how-should-tests-be-co-located-in-src"><h2>How should tests be co-located in <code>src</code>?</h2></a>
<p>Should tests be allowed within <code>src</code> via <code>*-test</code> types (e.g.
<code>component-integration-test</code>, <code>component-unit-test</code>, etc.) within respective
collections?</p>
<p>If this RFC is approved, then Robert Jackson plans to adapt the
<a href="https://github.com/emberjs/rfcs/pull/119">Grand Testing Unification RFC</a> to
propose answers to these questions.</p>
<a class="header" href="print.html#what-about-routable-components" id="what-about-routable-components"><h2>What about routable components?</h2></a>
<p>Should routable components have a type that's unique from other components?</p>
<p>Should they exist alongside <code>route</code> and <code>template</code> types in the <code>routes</code>
collection?</p>
<p>It seems plausible that routable components could simply use the <code>component</code>
type, and that we could lint against allowing template-invocable components
alongside routes.</p>
<a class="header" href="print.html#how-should-configuration-declarations-be-made-in-the-main-module" id="how-should-configuration-declarations-be-made-in-the-main-module"><h2>How should configuration declarations be made in the <code>main</code> module?</h2></a>
<p>For example:</p>
<ul>
<li>How should resolvable exports be declared from addons?</li>
<li>Can apps override the root names of addons? For example, if
<code>ember-power-select</code> has a root name of <code>power-select</code>, could a consuming app
override this?</li>
<li>How do addons and apps declare their collection and type exports? For example,
how could liquid-fire allow for a <code>transition</code> type and an <code>animations</code>
collection?</li>
</ul>
<a class="header" href="print.html#should-we-allow-collection-groups" id="should-we-allow-collection-groups"><h2>Should we allow collection groups?</h2></a>
<p>Do the organizational benefits of collection groups outweigh the potential
confusion over where lines are drawn between a group/collection/namespace
when viewing a project structure.</p>
<ul>
<li>Start Date: 2016-06-11</li>
<li>RFC PR: <a href="https://github.com/emberjs/rfcs/pull/150">#150</a></li>
<li>Ember Issue: <a href="https://github.com/emberjs/ember.js/pull/14360">#14360</a></li>
</ul>
<a class="header" href="print.html#summary-23" id="summary-23"><h1>Summary</h1></a>
<p>With the goal of making significant performance improvements and of adding
public API to support use cases long-served by a private API, a new API of
<code>factoryFor</code> will be added to <code>ApplicationInstance</code> instances.</p>
<a class="header" href="print.html#motivation-24" id="motivation-24"><h1>Motivation</h1></a>
<p>Ember's dependency injection container has long supported fetching a factory
that will be created with any injections present. Using the private API that
provided this support allows an instance of the factory to be created
with initial values passed via <code>create</code>. For example:</p>
<pre><code class="language-js">// app/logger/main.js
import Ember from 'ember';

export default Ember.Logger.extend({
  someService: Ember.inject.service()
});
</code></pre>
<pre><code class="language-js">import Ember from 'ember';
const { Component, getOwner } = Ember;

export default Component.extend(
  init() {
    this._super(...arguments);
    let Factory = getOwner(this)._lookupFactory('logger:main');
    this.logger = Factory.create({ level: 'low' });
  }
});
</code></pre>
<p>In this API, the <code>Factory</code> is actually a subclass the original main logger
class. When <code>_lookupFactory</code> is called, an additional <code>extend</code> takes place
to add any injections (such as <code>someService</code> above). The class/object setup
looks like this:</p>
<ul>
<li>In the module: <code>MyClass = Ember.Object.extend(</code></li>
<li>In <code>_lookupFactory</code>: <code>MyFactoryWithInjections = MyClass.extend(</code></li>
<li>And when used: <code>MyFactoryWithInjections.create(</code></li>
</ul>
<p>The second call to <code>extend</code> implements Ember's owner/DI
framework and permits <code>someService</code> to be resolved later. The &quot;owner&quot; object
is merged into the new <code>MyFactoryWithInjections</code> class along with any
registered injections.</p>
<p>This &quot;double extend&quot; (once at define time, once at <code>_lookupFactory</code> time)
takes a toll on performance booting an app. This design flaw has motivated
a desire to keep <code>_lookupFactory</code> private.</p>
<p>The <code>MyFactoryWithInjections</code> class also features as a cache. Because it is
attached to the owner/container, it is cleared between test runs or
application instances. To illustrate, this flow-chart shows how
<code>MyFactoryWithInjections</code> diverges between tests:</p>
<pre><code>               +-------------------------------+
               |                               |
               |      /app/models/foo.js       |
               |                               |
               +-------------------------------+
                               |
              first test run   |    nth test run
              +----------------+---------------+
              |                                |
              v                                v
   +---------------------+          +--------------------+
   |resolve('model:foo') |   ===    |resolve('model:foo')|
   +---------------------+          +--------------------+
              |                                |
              |                                |
              v                                v

     extend(injections)               extend(injections)

              |                                |
              |                                |
              |                                |
              v                                v
+--------------------------+     +---------------------------+
|lookupFactory('model:foo')| !== |lookupFactory('model:foo') |
+--------------------------+     +---------------------------+
</code></pre>
<p>Despite the design flaws in this API, it does fill a meaningful role in
Ember's DI solution. Use of the private API is common. Some examples:</p>
<ul>
<li><a href="https://github.com/DockYard/ember-cart">ember-cart</a> uses the functionality to create model objects without
tying them to the store <a href="https://github.com/DockYard/ember-cart/blob/c01eb22eaf2e97f8c80481c3174d4be917e476a9/tests/dummy/app/controllers/application.js#L16">example a</a>,
<a href="https://github.com/DockYard/ember-cart/blob/c01eb22eaf2e97f8c80481c3174d4be917e476a9/tests/dummy/app/models/dog.js#L11">example b</a></li>
<li>Ember-Data's <a href="https://github.com/emberjs/data/blob/54ea432b1cbb0d1231d9a0454b09d3b3a0bc2533/addon/-private/system/store.js#L1868"><code>modelFactoryFor</code></a></li>
</ul>
<p>The goal of this RFC is to create a public API for fetching factories with
better performance characteristics than <code>_lookupFactory</code>.</p>
<a class="header" href="print.html#detailed-design-21" id="detailed-design-21"><h1>Detailed design</h1></a>
<p>Throughout this document I reference Ember 2.12 as it is the next LTS at writing. This
proposal may ship for 2.12-LTS or be bumped to the next LTS.</p>
<p>This feature will be added in these steps.</p>
<ol>
<li>In Ember introduce a <code>ApplicationInstance#factoryFor</code> based on
<code>_lookupFactory</code>. It should be documented that certain behaviors
inherent to &quot;double extend&quot; are not supported. In development builds
and supporting browsers, wrap return values in a Proxy. The proxy should
throw an error when any property besides <code>create</code> or <code>class</code> is accessed.
<code>class</code> must return the registered factory, not the double extended factory.</li>
<li>In the same release add a deprecation message to usage of <code>_lookupFactory</code>.
As this API is intimate it must be maintained through at least one LTS
release (2.12 at this writing).</li>
<li>In 2.13 drop <code>_lookupFactory</code> and migrate the <code>factoryFor</code> implementation to avoid
&quot;double-extend&quot; entirely.</li>
</ol>
<p>Additionally, a polyfill will be released for this feature supporting prior
versions of Ember.</p>
<a class="header" href="print.html#design-of-applicationinstancefactoryfor" id="design-of-applicationinstancefactoryfor"><h4>Design of <code>ApplicationInstance#factoryFor</code></h4></a>
<p>A new API will be introduced. This API will return both the original base
class registered into or resolved by the container, and will also return a function
to generate a dependency-injected instance. For example:</p>
<pre><code class="language-js">import Ember from 'ember';
const { Component, getOwner } = Ember;

export default Component.extend(
  init() {
    this._super(...arguments);
    let factory = getOwner(this).factoryFor('logger:main');
    this.logger = factory.create({ level: 'low' });
  }
});
</code></pre>
<p>Unlike <code>_lookupFactory</code>, <code>factoryFor</code> will not return an extended class with
DI applied. Instead it will return a factory object with two properties:</p>
<pre><code class="language-js">// factoryFor returns:
let {

  // a function taking an argument of initial properties passed to the object
  // and returning an instance
  create,

  // The class registered into (or resolved by) the container
  class

} = owner.factoryFor('type:name');
</code></pre>
<p>This API should meet two requirements of the use-cases described in
&quot;Motivation&quot;:</p>
<ul>
<li>Because <code>factoryFor</code> only returns a <code>create</code> method and reference to the
original class, its internal implementation can diverge away from the
&quot;double extend&quot;. A side-effect of this is that the
class of an object instantiated via <code>_lookupFactory(name).create()</code>
and <code>factoryFor(name).create()</code> may not be the same, given the
same original factory.</li>
<li>The presence of <code>class</code> will make it easy to identify the base class of the
factory at runtime.</li>
</ul>
<p>For example today's <code>_lookupFactory</code> creates an inheritance structure like
the following:</p>
<pre><code>                    Current:
       +-------------------------------+
       |                               |
       |      /app/models/foo.js       |
       |                               |
       +-------------------------------+
                       |
                       |
                       |
                       v
            +--------------------+
            |  Class[model/Foo]  |
            +--------------------+
                       |
                       |
                       |
       first test run  |   nth test run
           +-----------+----------+
           |                      |
           |                      |
           |                      |
           v                      v
+--------------------+ +--------------------+
|     subclass of    | |     subclass of    |
|  Class[model/Foo]  | |  Class[model/Foo]  |
+--------------------+ +--------------------+
</code></pre>
<p>Between test runs 2 instances of <code>model:foo</code> will have a common
shared ancestor the grandparent <code>Class[model/Foo]</code>.</p>
<p>This implementation of <code>factoryFor</code> proposes to remove the intermediate
subclass and instead have a generic
factory object which holds the injections and allows for injected instances
to be created. The resulting object graph would look something like this:</p>
<pre><code>                  Proposed:
      +-------------------------------+
      |                               |
      |      /app/models/foo.js       |
      |                               |
      +-------------------------------+
                      |
                      |
                      |
                      v
           +--------------------+
           |  Class[model/Foo]  |
           +--------------------+
                      |
                      |
                      |
      first test run  |   nth test run
           +----------+-----------+
           |                      |
           |                      |
           |                      |
           v                      v
+--------------------+ +--------------------+
|     Factory of     | |     Factory of     |
|  Class[model/Foo]  | |  Class[model/Foo]  |
+--------------------+ +--------------------+
</code></pre>
<p>With <code>factoryFor</code> instances of <code>model:foo</code> will share a common constructor.
Any state stored on the constructor would of course leak between the tests.</p>
<p>An example implementation of <code>factoryFor</code> can be reviewed <a href="https://github.com/emberjs/rfcs/issues/125#issuecomment-193827658">on this GitHub
comment</a>.</p>
<a class="header" href="print.html#implications-for-ownerregister" id="implications-for-ownerregister"><h5>Implications for <code>owner.register</code></h5></a>
<p>Currently, factories registered into Ember's DI system are required to
provide an <code>extend</code> method. Removing support for extend-based DI in <code>_lookupFactory</code>
will permit factories without <code>extend</code> to be registered. Instead factories
must only provide a <code>create</code> method. For example:</p>
<pre><code class="language-js">let factory = {
  create(options={}) {
    /* Some implementation of `create` */
    return Object.create({});
  }
};
owner.register('my-type:a-factory', factory);
let factoryWithDI = owner.factoryFor('my-type:a-factory');

factoryWithDI.class === factory;
</code></pre>
<a class="header" href="print.html#development-mode-proxy" id="development-mode-proxy"><h5>Development-mode Proxy</h5></a>
<p>Because many developers will simply re-write <code>_lookupFactory</code> to <code>factoryFor</code>,
it is important to provide some aid and ensure they actually complete the
migration completely (they they avoid setting state on the factory). A proxy
wrapping the return value of <code>factoryFor</code> and raising assertions when any
property besides <code>create</code> or <code>class</code> is accessed will be added in development.</p>
<p>Additionally, using <code>instanceof</code> on the result of <code>factoryFor</code> should be
disallowed, causing an exception to be raised.</p>
<p>A good rule of thumb is that, in development, using anything besides <code>class</code> or
<code>create</code> on the return value of <code>factoryFor</code> should fail with a helpful message.</p>
<a class="header" href="print.html#releasing-a-polyfill" id="releasing-a-polyfill"><h5>Releasing a polyfill</h5></a>
<p>A polyfill addon, similar to <a href="https://github.com/rwjblue/ember-getowner-polyfill">ember-getowner-polyfill</a>
will be released for this feature. This polyfill will provide the <code>factoryFor</code>
API going back to at least 2.8, provide the API and silence the deprecation
in versions before <code>factoryFor</code> is available, and be a no-op in versions where
<code>factoryFor</code> is available.</p>
<a class="header" href="print.html#how-we-teach-this-5" id="how-we-teach-this-5"><h1>How We Teach This</h1></a>
<p>This feature should be introduced along side <code>lookup</code> in the
<a href="https://guides.emberjs.com/v2.6.0/applications/dependency-injection/">relevant guide</a>.
The return value of <code>factoryFor</code> should be taught as a POJO and not as
an extended class.</p>
<a class="header" href="print.html#example-deprecation-guide-migrating-from-_lookupfactory-to-factoryfor" id="example-deprecation-guide-migrating-from-_lookupfactory-to-factoryfor"><h4>Example deprecation guide: Migrating from <code>_lookupFactory</code> to <code>factoryFor</code></h4></a>
<p>Ember owner objects have long provided an intimate API used to
fetch a factory with dependency injections. This API, <code>_lookupFactory</code>, is deprecated
in Ember 2.12 and will be removed in Ember 2.13. To ease the transition to this
new public API, a polyfill is provided with support back to at least Ember 2.8.</p>
<p><code>_lookupFactory</code> returned the class of resolved factory extended with
a mixin containing its injections. For example:</p>
<pre><code class="language-js">let factory = Ember.Object.extend();
owner.register('my-type:a-name', factory);
let klass = owner._lookupFactory('my-type:a-name');
klass.constructor.superclass === factory; // true
let instance = klass.create();
</code></pre>
<p><code>factoryFor</code> instead returns an object with two properties: <code>create</code> and <code>class</code>.
For example:</p>
<pre><code class="language-js">let factory = Ember.Object.extend();
owner.register('my-type:a-name', factory);
let klass = owner.factoryFor('my-type:a-name');
klass.class === factory; // true
let instance = klass.create();
</code></pre>
<p>A common use-case for <code>_lookupFactory</code> was to fetch an factory with
specific needs in mind:</p>
<ul>
<li>The factory needs to be created with initial values (which cannot be
provided at create-time via <code>lookup</code>.</li>
<li>The instances of that factory need access to Ember's DI framework (injections,
registered dependencies).</li>
</ul>
<p>For example:</p>
<pre><code class="language-js">// app/widgets/slow.js
import Ember from 'ember';

export default Ember.Object.extend({
  // this instance requires access to Ember's DI framework
  store: Ember.inject.service(),

  convertToModel() {
    this.get('store').createRecord('widget', {
      widgetType: 'slow',
      name, canWobble
    });
  }

});
</code></pre>
<pre><code class="language-js">// app/services/widget-manager.js
import Ember from 'ember';

export default Ember.Service.extend({

  init() {
    this.set('widgets', []);
  },

  /*
   * Create a widget of a type, and add it to the widgets array.
   */
  addWidget(type, name, canWobble) {
    let owner = Ember.getOwner(this);
    // Use `_lookupFactory` so the `store` is accessible on instances.
    let WidgetFactory = owner._lookupFactory(`widget:${type}`);
    let widget = WidgetFactory.create({name, canWobble});
    this.get('widgets').pushObject(widget);
    return widget;
  }

});
</code></pre>
<p>For these common cases where only <code>create</code> is called on the factory, migration
to <code>factoryFor</code> is mechanical. Change <code>_lookupFactory</code> to <code>factoryFor</code> in the
above examples, and the migration would be complete.</p>
<a class="header" href="print.html#migration-of-static-method-calls" id="migration-of-static-method-calls"><h5>Migration of static method calls</h5></a>
<p>Factories may have had static methods or properties that were being accessed
after resolving a factory with <code>_lookupFactory</code>. For example:</p>
<pre><code class="language-js">// app/widgets/slow.js
import Ember from 'ember';

const SlowWidget = Ember.Object.extend();
SlowWidget.reopenClass({
  SPEEDS: [
    'slow',
    'verySlow'
  ],
  hasSpeed(speed) {
    return this.SPEEDS.contains(speed);
  }
});

export default SlowWidget;
</code></pre>
<pre><code class="language-js">let factory = owner._lookupFactory('widget:slow');
factory.SPEEDS.length; // 2
factory.hasSpeed('slow'); // true
</code></pre>
<p>With <code>factoryFor</code>, access to these methods or properties should be done via
the <code>class</code> property:</p>
<pre><code class="language-js">let factory = owner.factoryFor('widget:slow');
let klass = factory.class;
klass.SPEEDS.length; // 2
klass.hasSpeed('slow'); // true
</code></pre>
<a class="header" href="print.html#drawbacks-23" id="drawbacks-23"><h1>Drawbacks</h1></a>
<p>The main drawback to this solution is the removal of double extend. Double
extend is a performance troll, however it also means if a single class is registered
multiple times each <code>_lookupFactory</code> returns a unique factory. It is plausible
that some use-case relying on this behavior would get trolled in the migration
to <code>factoryFor</code>, however it is unlikely.</p>
<p>For example these cases where state is stored on the factory would no
longer be scope to one instance of the owner (like one test). Instead, setting
a value on the class would set it on the registered class.</p>
<p>Some real-world examples of setting state on the factory class:</p>
<ul>
<li>ember-model
<ul>
<li>https://github.com/ebryn/ember-model/blob/master/packages/ember-model/lib/model.js#L404 and https://github.com/ebryn/ember-model/blob/master/packages/ember-model/lib/model.js#L457
with <code>factoryFor</code> will increment a shared counter across application and
container instances.</li>
<li>https://github.com/ebryn/ember-model/blob/master/packages/ember-model/lib/model.js#L723-L725
would also set properties on the base <code>Ember.Model</code> factory instead of
an extension of that class.</li>
</ul>
</li>
<li>ember-data
<ul>
<li>If attrs change between test runs (seems very unlikely) then https://github.com/emberjs/data/blob/387630db5e7daec6aac7ef8c6172358a3bd6394c/addon/-private/system/model/attr.js#L57
would be affected. The CP of <code>attributes</code> will have a value cached on the
factory, and where with <code>_lookupFactory</code>'s double-extend the cache would be
on the extended class, in <code>factoryFor</code> that CP cache will be on the
class registered as a factory.</li>
</ul>
</li>
<li>Any other of the following:
<ul>
<li><code>lookupFactory(x).reopen</code> / <code>reopenClass</code> at runtime (or test time to monkey patch code)</li>
<li><code>lookupFactory(x).something = value</code></li>
</ul>
</li>
</ul>
<a class="header" href="print.html#alternatives-23" id="alternatives-23"><h1>Alternatives</h1></a>
<p>More aggressive timelines have been considered for this change.</p>
<p>However we have considered the possibility that removing <code>_lookupFactory</code> in 2.13
(something LTS technically permits) would be too aggressive for the
community of addons. Providing a polyfill is part of the strategy to handle
this change.</p>
<a class="header" href="print.html#unresolved-questions-20" id="unresolved-questions-20"><h1>Unresolved questions</h1></a>
<p>Are there any use-cases for the double extend not considered?</p>
<ul>
<li>Start Date: 2016-11-05</li>
<li>RFC PR: https://github.com/emberjs/rfcs/pull/176</li>
<li>Ember Issue: (leave this empty)</li>
</ul>
<a class="header" href="print.html#summary-24" id="summary-24"><h1>Summary</h1></a>
<p>Make Ember feel less overwhelming to new users, and make Ember applications
start faster, by replacing the <code>Ember</code> global with a first-class system for
importing just the parts of the framework you need.</p>
<a class="header" href="print.html#motivation-25" id="motivation-25"><h1>Motivation</h1></a>
<p>ECMAScript 2015 (also known as ES2015 or ES6) introduced a syntax for importing
and exporting values from modules. Ember aggressively adopted modules, and if
you've used Ember before, you're probably familiar with this syntax:</p>
<pre><code class="language-js">import Ember from &quot;ember&quot;;
import Analytics from &quot;../mixins/analytics&quot;;

export default Ember.Component.extend(Analytics, {
  // ...
});
</code></pre>
<p>One thing to notice is that the entire Ember framework is imported as a single
package. Rather than importing <code>Component</code> directly, for example, you import
<code>Ember</code> and subclass <code>Ember.Component</code>. (And this example still works even if
you forget the import, because we also create a global variable called
<code>Ember</code>.)</p>
<p>Using Ember via a monolithic package or global object is not ideal for several
reasons:</p>
<ul>
<li>It's overwhelming for learners. There's a giant list of classes and functions
with no hints about how they're related. The API documentation reflects this.</li>
<li>Experienced developers who don't want all of Ember's features feel like
they're adding unnecessary and inescapable bloat to their application.</li>
<li>The <code>Ember</code> object must be built at boot time, requiring that we ship the
entire framework to the browser. This has two major costs:
<ol>
<li>Increased download time, particularly noticeable on slower connections.</li>
<li>Increased parsing/evaluation cost, which still must be paid even when
assets are cached. On some browsers/devices, this can far exceed the cost of the
download itself.</li>
</ol>
</li>
</ul>
<p>Defining a public API for importing parts of Ember via JavaScript modules helps
us lay the groundwork for solving all of these problems.</p>
<a class="header" href="print.html#reducing-load-time" id="reducing-load-time"><h4>Reducing Load Time</h4></a>
<p>Modules help us eliminate unneeded code. The module syntax is <em>statically
analyzable</em>, meaning that a tool like Ember CLI can analyze an application's
source code and reliably determine which files, in both the framework and the
application, are actually needed. Anything that's not needed is omitted from the
final build.</p>
<p>This allows us to provide the file size benefits of a &quot;small modules&quot; approach
to building web applications while retaining the productivity benefits of a
complete, opinionated framework.</p>
<p>For example, if your application never used the <code>Ember.computed.union</code> computed
property helper, Ember could detect this and remove its code when you build your
application. This technique for slimming down the payload automatically is often
referred to as <em>tree shaking</em> or <em>dead code elimination</em>.</p>
<p>Building the module graph doesn't just mean we get a list of files used by the application
we also know which files are used <em>route-by-route</em>.</p>
<p>We can use this knowledge to optimize boot time even more, by prioritizing
sending only the JavaScript needed for the requested route, rather than the
entire application.</p>
<p>For example, if the user requests the URL
<code>https://app.example.com/articles/123</code>, the server could first send the code for
<code>ArticlesRoute</code>, the <code>Article</code> model, the <code>articles</code> template, and any
components and framework code used in the route. Only after the route is
rendered would we start to send the remainder of the application and framework
code in the background.</p>
<a class="header" href="print.html#guiding-learners" id="guiding-learners"><h4>Guiding Learners</h4></a>
<p>We can group framework classes and utilities by functionality, making it clear
what things are related and how they should work together. People can feel
confident they are getting only what they need at that moment, not an entire
framework that they're not sure they're benefiting from.</p>
<a class="header" href="print.html#modernizing-ember" id="modernizing-ember"><h4>Modernizing Ember</h4></a>
<p>Lastly, developers are growing increasingly accustomed to using JavaScript
modules to import libaries. If we don't adapt to modules, Ember will feel clunky
and antiquated compared to modern alternatives.</p>
<a class="header" href="print.html#prior-art" id="prior-art"><h3>Prior Art</h3></a>
<p>Initial efforts to define a module API for Ember began with the
<a href="https://github.com/ember-cli/ember-cli-shims"><code>ember-cli-shims</code></a> addon. This addon provides a set of &quot;shim&quot; modules
that re-export a value off the global <code>Ember</code>. While this setup doesn't offer
the benefits of true modules, it did allow us to rapidly experiment with a
module API without making changes to Ember core.</p>
<p>Common feedback from shim users was that, while they were a net improvement,
they introduced too much verbosity and were hard for beginners to remember.</p>
<p>An oft-cited example of this verbosity is that implementing an object and using
<code>Ember.get</code> and <code>Ember.set</code> requires three different imports:</p>
<pre><code class="language-js">import EmberObject from &quot;ember-object&quot;;
import get from &quot;ember-metal/get&quot;;
import set from &quot;ember-metal/set&quot;;
</code></pre>
<p>In fact, one of the principles outlined in this RFC is designed to correct this
verbosity; namely, that <a href="print.html#utility-functions-are-named-exports">utility functions and the class they are related to
should share a module</a>.</p>
<p>For those who have already adopted modules via the <code>ember-cli-shims</code> package, we
will provide a migration tool to rewrite shim modules into the final module API.
The static nature of the import syntax makes this even easier and more reliable
than migrating globals-based apps. The upgrade process should take no more than
a few minutes (see <a href="print.html#migration">Migration</a>).</p>
<p>This RFC also builds significantly on <a href="https://github.com/zeppelin">@zeppelin's</a>
previous <a href="https://github.com/emberjs/rfcs/pull/68">ES6 modules RFC</a>, which drove
initial discussion, including the idea to use scoped packages.</p>
<a class="header" href="print.html#detailed-design-22" id="detailed-design-22"><h1>Detailed Design</h1></a>
<a class="header" href="print.html#terminology" id="terminology"><h2>Terminology</h2></a>
<ul>
<li><strong>Package</strong> - a bundle of JavaScript addressable by npm and other package
managers, it may contain many modules (but has a default module, usually
called <code>index.js</code>).</li>
<li><strong>Scoped Package</strong> - a namespaced package whose name starts with an <code>@</code>, like
<code>import Thing from &quot;@scope/thing&quot;</code>.</li>
<li><strong>Module</strong> - a JavaScript file with at least one default export or named
export.</li>
<li><strong>Top-Level Module</strong> - the module provided by importing a package directly,
like <code>import Component from &quot;@ember/component&quot;</code>.</li>
<li><strong>Nested Module</strong> - a module provided at a path <em>inside</em> a package, like
<code>import { addObserver } from &quot;@ember/object/observers&quot;</code>.</li>
</ul>
<a class="header" href="print.html#module-naming--organization" id="module-naming--organization"><h2>Module Naming &amp; Organization</h2></a>
<p>Because our goal is to eliminate the <code>Ember</code> global object, any public classes,
functions or properties that currently exist on the global need an equivalent
module that can be imported.</p>
<p>Given how fundamental modules are to the development process, how we organize
and name them impacts new learners and seasoned veterans alike. Thus we must try
to find a balance between predictability for new and intermediate users, and
terseness for experienced developers with large apps.</p>
<p>There is another goal at play: we would like to help dispel the misconception
that Ember is a monolithic framework. Ideally, module names help us tell a story
about Ember's layered features. Rather than inheriting the entire framework at
once, you can pull in just the pieces you need.</p>
<p>For that reason, package names should assist the developer in understanding what
capabilities are added by bringing in that new package. We should pick
meaningful names, not let our public API be a by-product of how Ember's
internals are organized.</p>
<p>A full table of proposed mappings from global to module is available in
<a href="print.html#addendum-1---table-of-module-names-and-exports-by-global">Addendum 1 - Table of Module Names and Exports by
Global</a> and <a href="print.html#addendum-2---table-of-module-names-and-exports-by-package">Addendum
2 - Table of Module Names and Exports by
Package</a>. Because
there is some implicit functionality that you get when loading Ember that is not
encapsulated in a global property (for example, automatically adding prototype
extensions), there is also <a href="print.html#addendum-3---table-of-modules-with-side-effects">Addendum 3 - Table of Modules with Side
Effects</a>.</p>
<p>Before diving in to these tables, however, it may be helpful to understand some
of the thinking that guided this proposal. And keep in mind, this RFC specifies
a <em>baseline</em> module API. Nothing here precludes adding additional models in the
future, as we discover missing pieces.</p>
<a class="header" href="print.html#use-scoped-packages" id="use-scoped-packages"><h3>Use Scoped Packages</h3></a>
<p>Last year, <a href="http://blog.npmjs.org/post/116936804365/solving-npms-hard-problem-naming-packages">npm introduced support for scoped packages</a>. Scopes
are similar to organizations on GitHub. They allow us to use any package name,
even if it's already in use on npm, by namespacing it inside a scope.</p>
<p>For example, the <a href="https://www.npmjs.com/package/component"><code>component</code></a> package is already reserved by an
unmaintained tool; we couldn't use <code>component</code> as a package name even if we
wanted to.</p>
<p>However, scopes allow us to create a package named <code>component</code> that lives under
the <code>@ember</code> scope: <code>import Component from &quot;@ember/component&quot;</code>.</p>
<p>The advantages of using scoped packages, as this proposal does, are two-fold:</p>
<ol>
<li>&quot;Official&quot; packages are clearly differentiated from community packages.</li>
<li>There is no risk of naming conflicts with existing community packages.</li>
</ol>
<p>Note that actually publishing packages to npm may not be immediately necessary
to implement this RFC. We should still design around this constraint so that we
have the option available to us in the future. For more discussion, see the
<a href="print.html#distribution">Distribution unresolved question</a>.</p>
<a class="header" href="print.html#prefer-common-terminology" id="prefer-common-terminology"><h3>Prefer Common Terminology</h3></a>
<p>Module names should use terms people are more likely to be familiar with. For
example, instead of the ambiguous <code>platform</code>, polyfills should be in a module
called <code>polyfill</code>.</p>
<p>Similarly, the vast majority of advanced Ember developers couldn't crisply
articulate the difference between <code>ember-metal</code> and <code>ember-runtime</code>. Instead, we
should prefer <code>ember-object</code>, to match how people actually talk about these
features: the Ember object model.</p>
<a class="header" href="print.html#organize-by-mental-model" id="organize-by-mental-model"><h3>Organize by Mental Model</h3></a>
<p>One of the biggest barriers to learning is the fact that short-term memory is
limited. To understand a complex system like a modern web application, the
learner must hold in their head many different conceptsmore concepts than most
people can reason about at once.</p>
<p><a href="https://en.wikipedia.org/wiki/Chunking_(psychology)">Chunking</a> is a strategy for dealing with this. It means that you
present concepts that are conceptually related together. When the learner needs
to reason about the overall system, in their mind they can replace a group of
related concepts with a single, overarching concept.</p>
<p>For example, if you tell someone that in order to build an Ember app, they will
need to understand computed properties, actions (bubbling and closure),
components, containers, registries, routes, helpers (stateful and stateless),
dependent keys, controllers, route maps, observers, transitions, mixins,
computed property macros, injected properties, the run loop, and array
proxiesthey will rightfully feel like Ember is an overwhelming, overcomplicated
framework. Most people (your RFC author included) simply cannot keep this many
discrete concepts in their head at once.</p>
<p>The day-to-day reality of building an Ember app, of course, is not nearly so
complex. For those developers who stick through the learning curve, they end up
with a greatly simplified mental model.</p>
<p>This proposal attempts to re-align module naming with that simplified mental
model, placing everything into packages based on the chunk of functionality they
provide:</p>
<ul>
<li><code>@ember/application</code> - Application-level concerns, like bootstrapping,
initializers, and dependency injection.</li>
<li><code>@ember/component</code> - Classes and utilities related to UI components.</li>
<li><code>@ember/routing</code> - Classes used for multi-page routing.</li>
<li><code>@ember/service</code> - Classes and utilities for cross-cutting services.</li>
<li><code>@ember/controller</code> - Classes and utilities related to controllers.</li>
<li><code>@ember/object</code> - Classes and utilities related to Ember's object model,
including <code>Ember.Object</code>, computed properties and observers.</li>
<li><code>@ember/runloop</code> - Methods for scheduling behavior on to the run loop.</li>
</ul>
<p>It includes a few other packages that, over time, your author hopes become
either unneeded or can be moved outside of core into standalone packages:</p>
<ul>
<li><code>@ember/array</code> - Array utilities and observation. Ideally these can be replaced
with a combination of ES2015+ features and array diffing in Glimmer.</li>
<li><code>@ember/enumerable</code> - Replaced by iterables in ES2015.</li>
<li><code>@ember/string</code> - String formatting utilities (dasherize, camelize, etc.).</li>
<li><code>@ember/map</code> - Replaced by <code>Map</code> and <code>WeakMap</code> in ES2015.</li>
<li><code>@ember/polyfills</code> - Polyfills for <code>Object.keys</code>, <code>Object.assign</code> and <code>Object.create</code>.</li>
<li><code>@ember/utils</code> - Grab bag of utilities that could likely be replaced with
something like lodash.</li>
</ul>
<p>And finally, some packages that may be used by internals, extensions, or addons
but are not used day-to-day by app developers:</p>
<ul>
<li><code>@ember/instrumentation</code> - Instrumentation hooks for measuring performance.</li>
<li><code>@ember/debug</code> - Utility functions for debugging, and hooks used by debugger tools like Ember Inspector.</li>
</ul>
<a class="header" href="print.html#classes-are-default-exports" id="classes-are-default-exports"><h3>Classes are Default Exports</h3></a>
<p>Classes that the user is supposed to import and subclass are always the default
export, never a named export. In the case where a package has more than one primary class,
those classes live in a nested module.</p>
<p>This rule ensures there is no ambiguity about whether something is a named
export or a default export: classes are always default exports. In tandem with
the following rule (<a href="print.html#utility-functions-are-named-exports">Utility Functions are Named
Exports</a>), this also means that classes
and the functions that act on them are grouped into the same <code>import</code> line.</p>
<a class="header" href="print.html#examples-1" id="examples-1"><h4>Examples</h4></a>
<p>Primary class only:</p>
<pre><code class="language-js">import EmberObject from &quot;@ember/object&quot;;
</code></pre>
<p>Primary class plus secondary classes:</p>
<pre><code class="language-js">import Component from &quot;@ember/component&quot;;
import Checkbox from &quot;@ember/component/checkbox&quot;;

import Map from &quot;@ember/map&quot;;
import MapWithDefault from &quot;@ember/map/with-default&quot;;
</code></pre>
<p>Multiple primary classes:</p>
<pre><code class="language-js">import Router from &quot;@ember/routing/router&quot;;
import Route from &quot;@ember/routing/route&quot;;
</code></pre>
<a class="header" href="print.html#utility-functions-are-named-exports" id="utility-functions-are-named-exports"><h3>Utility Functions are Named Exports</h3></a>
<p>Functions that are only useful with a particular class, or are used most frequently with
that class, are named exports from the package that exports the class.</p>
<a class="header" href="print.html#examples-2" id="examples-2"><h4>Examples</h4></a>
<pre><code class="language-js">import Service, { inject } from &quot;@ember/service&quot;;
import EmberObject, { get, set } from &quot;@ember/object&quot;;
</code></pre>
<p>In cases where there are many utility functions associated with a class, they can be further subdivided into
nested packages but remain named exports:</p>
<pre><code class="language-js">import EmberObject, { get, set } from &quot;@ember/object&quot;;
import { addObserver } from &quot;@ember/object/observers&quot;;
import { addListener } from &quot;@ember/object/events&quot;;
</code></pre>
<p>In the future, <a href="http://tc39.github.io/proposal-decorators/">decorators</a> would be included under this rule as
well. In fact, designing with an eye towards decorators was a large driver
behind this principle. For more discussion, see the <a href="print.html#everything-is-a-named-export">Everything is a Named
Export alternative</a>.</p>
<a class="header" href="print.html#one-level-deep" id="one-level-deep"><h3>One Level Deep</h3></a>
<p>To avoid deep directory hierarchies with mostly-empty directories, this proposal
limits nesting inside a top-level package to a single level. Deep nesting like
this can add additional time to navigating the hierarchy without adding much
benefit.</p>
<p>Java packages often have this problem due to their URL-based namespacing; see
e.g. <a href="https://github.com/elvishew/xLog/tree/fbfb60f9472e32723436b3d6bdd6c1878a5afb37/library/src">this Java
library</a>
where you end up with deeply nested directories, like
<code>xLog/library/src/test/java/com/elvishew/xlog/printer/AndroidPrinterTest.java</code>.</p>
<p>This rule leads to including the type in the name of the module in some cases
where it might otherwise be grouped instead. For example, instead of
<code>@ember/routing/locations/none</code>, we prefer <code>@ember/routing/none-location</code> to
avoid the second level of nesting.</p>
<a class="header" href="print.html#no-non-module-namespaces" id="no-non-module-namespaces"><h3>No Non-Module Namespaces</h3></a>
<p>The global version of Ember includes several functions that also act as a
namespace to group related functionality.</p>
<p>For example, <code>Ember.run</code> can be used to run some code inside a run loop, while
<code>Ember.run.scheduleOnce</code> is used to schedule a function onto the run loop once.</p>
<p>Similarly, <code>Ember.computed</code> can be used to indicate a method should be treated as
a computed property, but computed property macros also live on <code>Ember.computed</code>, like
<code>Ember.computed.alias</code>.</p>
<p>When consumed via modules, these functions no longer act as a namespace. That's
because tacking these secondary functions on to the main function requires us to
eagerly evaluate them (not to mention the potential deoptimizations in
JavaScript VMs by adding properties to a function object).</p>
<p>In practice, that means that this won't work:</p>
<pre><code class="language-js">// Won't work!
import { run } from &quot;@ember/runloop&quot;;
run.scheduleOnce(function() {
  // ...
});
</code></pre>
<p>Instead, you'd have to do this:</p>
<pre><code class="language-js">import { scheduleOnce } from &quot;@ember/runloop&quot;;
scheduleOnce(function() {
  // ...
});
</code></pre>
<p>The <a href="print.html#migration">migration tool</a>, described below, is designed to detect these
cases and migrate them correctly.</p>
<a class="header" href="print.html#prototype-extensions-and-other-code-with-side-effects" id="prototype-extensions-and-other-code-with-side-effects"><h3>Prototype Extensions and Other Code with Side Effects</h3></a>
<p>Some parts of Ember change global objects rather than exporting classes or
functions. For example, Ember (by default) installs additional methods on
<code>String.prototype</code>, like the <code>camelize()</code> method.</p>
<p>Any code that has side effects lives in a module without any exports; importing
the module is enough to produce the desired side effects. For example, if I
wanted to make the string extensions available to the application, I could
write:</p>
<pre><code class="language-js">import &quot;@ember/extensions/string&quot;
</code></pre>
<p>Generally speaking, modules that have side effects are harder to debug and can
cause compatibility issues, and should be avoided if possible.</p>
<a class="header" href="print.html#migration-1" id="migration-1"><h2>Migration</h2></a>
<p>To assist in assessing this RFC in real-world applications, and to help upgrade
apps should this RFC be accepted and implemented, your author has provided an
automatic migration utility, or &quot;codemod&quot;:</p>
<p><a href="https://github.com/tomdale/ember-modules-codemod">ember-modules-codemod</a></p>
<p>To run the codemod, <code>cd</code> into an existing Ember app and run the following commands.</p>
<pre><code class="language-sh">npm install ember-modules-codemod -g
ember-modules-codemod
</code></pre>
<p><strong>Note</strong>: The codemod currently requires Node 6 or later to run.</p>
<p>This codemod uses <a href="https://github.com/facebook/jscodeshift"><code>jscodeshift</code></a> to
update an Ember application in-place to the module syntax proposed in this RFC.
It can update apps that use the global <code>Ember</code>, and will eventually also support
apps using <a href="https://github.com/ember-cli/ember-cli-shims">ember-cli-shims</a>.</p>
<p><strong>Make sure you save any changes in your app before running the codemod, because
it modifies files in place. Obviously, because this RFC is speculative, your app
will not function after applying this codemod. For now, the codemod is only
useful for assessing how this proposal looks in real-world applications.</strong></p>
<p>For example, it will rewrite code that looks like this:</p>
<pre><code class="language-js">import Ember from 'ember';

export default Ember.Component.extend({
  isAnimal: Ember.computed.or('isDog', 'isCat')
});
</code></pre>
<p>Into this:</p>
<pre><code class="language-js">import Component from '@ember/component';
import { or } from '@ember/object/computed';

export default Component.extend({
  isAnimal: or('isDog', 'isCat')
});
</code></pre>
<p>For more information, see the <a href="https://github.com/tomdale/ember-modules-codemod">README</a>.</p>
<a class="header" href="print.html#how-we-teach-this-6" id="how-we-teach-this-6"><h1>How We Teach This</h1></a>
<p>This RFC makes changes to one of the most foundational (and historically stable)
concepts in Ember: how you access framework code. Because of that, it is hard to
overstate the impact these changes will have. We need to proceed carefully to
avoid confusion and churn.</p>
<p>It is possible that the work required to update the documentation and other
learning materials will be significantly more than the work required to do the
actual implementation. That means we need to start getting ready <em>now</em>, so that
when the code changes are ready, it is not blocked by a big documentation
effort.</p>
<p>That said, we do have the advantage of the new modules being &quot;just JavaScript.&quot;
We can lean heavily on the greater JavaScript community's learning materials,
and any teaching we do has the benefit of being transferable and not an
&quot;Ember-only&quot; skill.</p>
<a class="header" href="print.html#documentation-examples" id="documentation-examples"><h2>Documentation Examples</h2></a>
<p>Examples in the Getting Started tutorial, guides and API docs will need to be
updated to the new module syntax.</p>
<p>Probably the most efficient and least painful way to do this would be to write a
tool that can extract code snippets from Markdown files and run the
<a href="print.html#migration">migrator</a> on them, then replace the extracted code with the updated
version. For the API docs, this tool would need to be able to handle Markdown embedded
in JSDoc-style documentation.</p>
<p>The benefit of this approach is that, once we have verified the script works
reliably, we can wait until the last possible moment to make the switch. If we
attempt to update everything by hand, the duration and tediousness of that
process will likely take out an effective &quot;lock&quot; on the documentation code base,
where people will put off making big changes because of the potential for merge
conflicts.</p>
<a class="header" href="print.html#generators" id="generators"><h2>Generators</h2></a>
<p>Generators are used by new users to help them get a handle on the framework, and
by experienced users to avoid typing repetitive boilerplate. We need to ensure
that the generators that ship with Ember are updated to use modules as soon as
they are ready. The recent work by the Ember CLI team to ship generators with
the Ember package itself, rather than Ember CLI, should make this relatively
painless.</p>
<a class="header" href="print.html#api-documentation" id="api-documentation"><h2>API Documentation</h2></a>
<p>Our API documentation has long been a source of frustration, because the laundry
list of (often rarely used or internal) classes makes Ember feel far more
overwhelming than it really is.</p>
<p>The shift to modules gives us a good opportunity to rethink the presentation of
our API documentation. Instead of the imposing mono-list, we should group the
API documentation by packagewhich, conveniently in this proposal, means they
will also be grouped by area of functionality.</p>
<p>We should investigate the broader ecosystem to see if there is a good tool that
generates package-oriented documentation for JavaScript projects. If not, we may
wish to adapt an existing tool to do so.</p>
<a class="header" href="print.html#explaining-the-migration" id="explaining-the-migration"><h2>Explaining the Migration</h2></a>
<p>Once the guides and API documentation are updated, modules should be
straightforward for new learnersindeed, more and more new learners are starting
with JavaScript modules as the baseline.</p>
<p>The most challenging aspect of teaching the new modules API, counterintuitively,
will likely be <em>existing</em> users. In particular, for changes that touch nearly
every file, most teams working on large apps cannot pause work for a week to
implement the change.</p>
<p>Our focus needs to be:</p>
<ul>
<li>Communicating clearly that the existing global build will work for the
foreseeable future.</li>
<li>Making clear the file size benefits of moving to modules.</li>
<li>Building robust tooling that allows even large apps to migrate in a day or
two, not a week.</li>
</ul>
<p>It is important to frame the module transition as a carrot, not a stick. We
should avoid dire warnings or deprecation notices. Instead, we should provide
good reporting when doing Ember CLI builds. If an app is compiled in globals
mode, we can offer suggestions for how to reduce the file size, providing a
helpful pointer to the modules migration guide. This will make the transition
feel less like churn and more like an optimization opportunity that developers
can take advantage of when they have the time or resources.</p>
<a class="header" href="print.html#addons" id="addons"><h3>Addons</h3></a>
<p>One pitfall is that a <em>single</em> use of the <code>Ember</code> global means we have to
include the entire framework. That means that a developer could migrate their
entire app to modules, but a single old addon that uses the Ember globals will
negate the benefits.</p>
<p>This requires a two-pronged strategy:</p>
<ul>
<li>Tight integration into Ember CLI
<ul>
<li>Good reporting to make it obvious when a fallback to globals mode
occurs, and which addons/files are causing it.</li>
<li>An opt-in mode to prohibit globals mode. Installing an incompatible addon
would produce an error.</li>
</ul>
</li>
<li>Community outreach and pull requests to help authors update addons.</li>
</ul>
<a class="header" href="print.html#drawbacks-24" id="drawbacks-24"><h1>Drawbacks</h1></a>
<a class="header" href="print.html#complexity" id="complexity"><h2>Complexity</h2></a>
<p>There is something elegantly simple about a single <code>Ember</code> global that contains
everything. Introducing multiple packages means you don't just have to know what
you needyou also need to know where to import it from.</p>
<p>JavaScript module syntax is also something not everyone will be familiar with,
given its newness. However, this is something we must deal with anyway because
module syntax is already in use within apps.</p>
<a class="header" href="print.html#module-churn" id="module-churn"><h2>Module Churn</h2></a>
<p>The <code>ember-cli-shims</code> package is already included by default in new Ember apps,
and is in fairly common usage. Many developers are already familiar with its
API. This drawback can be at least partially mitigated by <a href="print.html#migration">the automated
migration process</a>, which will be easily applied to existing shimmed
apps.</p>
<a class="header" href="print.html#scoped-packages-are-an-unknown-quantity" id="scoped-packages-are-an-unknown-quantity"><h2>Scoped Packages Are an Unknown Quantity</h2></a>
<p>This proposal relies on scoped packages. Despite being released over a year ago,
scoped packages are not always well supported.</p>
<p>For example, <a href="https://github.com/yarnpkg/yarn/issues?utf8=%E2%9C%93&amp;q=is%3Aissue%20is%3Aopen%20scoped%20packages">scoped packages currently wreak havoc on Yarn</a>. Until very
recently, the <a href="https://npmjs.com">npmjs.com</a> search did not include scoped
packages. Generally speaking, there will be a long-tail of tools in the
ecosystem that will choke on scoped packages.</p>
<p>That said, Angular 2 is distributed under the <code>@angular</code> scope, and TypeScript
recently adopted the <code>@types</code> scope for publishing TypeScript typings to npm.
The popularity of both of these should drive compatibility. Despite this, we can
expect <a href="https://github.com/angular/angular/issues/8422">similar compatibility issues</a> for some time.</p>
<a class="header" href="print.html#nested-modules" id="nested-modules"><h2>Nested Modules</h2></a>
<p>To satisfy the <a href="print.html#classes-are-default-exports">Classes are Default Exports</a> rule,
this RFC proposes the use of nested modules. That is, a module name may contain
an additional path segment beyond the package name. For example,
<code>@ember/object/observers</code> is a nested module, while <code>@ember/object</code> is not.</p>
<p>In the Node/CommonJS world, nested modules are unusual but not unheard of. For
example, Lodash offers a <a href="https://github.com/lodash/lodash/wiki/FP-Guide">functional programming
style</a> accessed by calling
<code>require('lodash/fp')</code>.</p>
<p>There are two drawbacks associated with nested modules:</p>
<ol>
<li>Because they are uncommon, developers may be confused by the syntax.</li>
<li>Because they allow you to &quot;reach in&quot; to the package for an
arbitrary file, encouraging the end user to use nested modules may
inadvertently <em>also</em> encourage them to access private modules, thinking they are
public.</li>
</ol>
<p>The first issue is surmountable with education, good reference documentation,
and good tools to help guide developers in the right direction. That this style
is uncommon in the Node ecosystem seems to be more a <a href="http://blog.izs.me/post/44149270867/why-no-directorieslib-in-node-the-less-snarky">function of
dogma</a>
than any technical shortcoming of nested modules.</p>
<p>To ensure that developers don't inadvertently access private modules, we have
two good options:</p>
<ol>
<li>Package modules in such a way that private modules <em>cannot</em> be accessed.</li>
<li>Take a page from Ember Data and put all private modules in a <code>-private</code>
directory, hopefully making it clear accessing this module is not playing by
the rules.</li>
</ol>
<p>We could avoid using this uncommon style by hoisting nested modules up to their
own package. For example, <code>@ember/object/observers</code> could become
<code>@ember/observers</code> or <code>@ember/object-observers</code>. However, because I could not
find a strong technical reason against it, and because having more packages is
in tension with the explicit goal to <a href="print.html#organize-by-mental-model">make Ember feel less
overwhelming</a>, I decided it was worth the small cost.</p>
<a class="header" href="print.html#alternatives-24" id="alternatives-24"><h1>Alternatives</h1></a>
<a class="header" href="print.html#ember--prefix" id="ember--prefix"><h3><code>ember-</code> prefix</h3></a>
<p>One alternative to the <code>@ember</code> scope is to use the <code>ember-</code> prefix. This avoids
the drawbacks around scoped packages described above. However, they would be
indistinguishable from the large number of community packages that begin with
<code>ember-</code>.</p>
<a class="header" href="print.html#everything-is-a-named-export" id="everything-is-a-named-export"><h3>Everything is a Named Export</h3></a>
<p>This proposal argues that classes should be a module's default export, and any
utility functions should be a named export. That means you can never have more
than one class per module, and <em>that</em> means, inherently, more <code>import</code>
statements than a system where multiple classes can live in one module.</p>
<p>Additionally, in cases where there is not a clear &quot;primary&quot; class, this can feel
a little awkward:</p>
<pre><code class="language-js">import Route from &quot;@ember/routing/route&quot;;
import Router from &quot;@ember/routing/router&quot;;
</code></pre>
<p>One commonly proposed alternative is to say that classes become named exports,
and default exports are not used at all. The above example would become:</p>
<pre><code class="language-js">import { Route, Router } from &quot;@ember/routing&quot;;
</code></pre>
<p>In this case, classes are distinguished by being capitalized, rather than by
being a default export.</p>
<p>There is one major change coming to JavaScript and Ember that, your author
believes, deals a fatal blow to this approach: decorators.</p>
<p>If you're unfamiliar with decorators, see <a href="http://tc39.github.io/proposal-decorators/">Addy Osmani's great
overview</a>. Decorators provide a mechanism for adding declarative
annotations to classes, methods, properties and functions.</p>
<p>For example, Robert Jackson has an <a href="https://github.com/rwjblue/ember-computed-decorators">experimental library for using decorators to
annotate computed properties in a class</a>. Something
like this will probably make its way into Ember in the future:</p>
<pre><code class="language-js">import EmberObject, { computed } from &quot;@ember/object&quot;;

export default class Cat extends EmberObject {
  @computed(&quot;hairLength&quot;)
  isDomesticShortHair(hairLength) {
    return hairLength &lt; 3;
  }
}
</code></pre>
<p>Most decorators are tightly coupled to a particular class because they configure
some aspect of behavior that is only relevant to that class. If every decorator
and every class share a namespace, it is hard to identify which go with each
other.</p>
<pre><code class="language-js">import { Router, Route, resource, model, location, inject, queryParam } from &quot;@ember/routing&quot;;
</code></pre>
<p>Can you tell me which of these decorators goes with which class?</p>
<p>And this import is getting so long, you'd probably be tempted to break it up
into multiple lines <em>anyway</em>, so it's not clear that it's actually a win over
separate imports.</p>
<p>Contrast this with the same thing expressed using the rules in
this RFC:</p>
<pre><code class="language-js">import Router, { resource, location } from &quot;@ember/routing/router&quot;;
import Route, { model, inject, queryParam } from &quot;@ember/routing/route&quot;;
</code></pre>
<p>Here, the decorators are clearly tied to their class. And it's far nicer from a
refactoring perspective: if you delete a class from a file, you then delete a
single line from your imports.</p>
<p>Contrast that with making fiddly edits to a long list of named exports unrelated
to each other.</p>
<a class="header" href="print.html#unresolved-questions-21" id="unresolved-questions-21"><h1>Unresolved Questions</h1></a>
<a class="header" href="print.html#intimate-apis" id="intimate-apis"><h3>Intimate APIs</h3></a>
<p>How much do we want to provide module API for so-called &quot;intimate
APIs&quot;technically private, but in widespread use?</p>
<a class="header" href="print.html#backwards-compatibility-for-addons" id="backwards-compatibility-for-addons"><h3>Backwards Compatibility for Addons</h3></a>
<p>How do we provide an API for addons to use modules but fall back to globals mode
in older versions of Ember? We should ensure that, at minimum, addons can
continue to support LTS releases. At the same time, it's critical that adding an
addon doesn't opt your entire application back in to the entire framework.</p>
<p>Because there is a lot of implementation-specific detail to get right here, and
because it doesn't otherwise block landing this module naming RFC, the final
design of API for addon authors should be broken out into a separate RFC.</p>
<a class="header" href="print.html#distribution" id="distribution"><h3>Distribution</h3></a>
<p>In practice, how do we ship this code to end users of Ember CLI?</p>
<p>When building client-side apps, it's very important to avoid duplicate
dependencies, which can quickly cause file size to balloon out of control.</p>
<p>Unfortunately, npm@3's de-duping is so nave that it's likely that users would
end up in dependency hell if we shipped the framework as separate npm packages.
There's no good way to ship dependencies in version lockstep and feel confident
that they will reliably be de-duped.</p>
<p>Until Yarn usage is more widespread, and to eliminate significant complexity in
the first iteration, it probably makes sense for the first phase of
implementation to continue shipping a single npm package that Ember CLI apps can
depend on. This gives us atomic updates and makes sure you never have one piece
of the framework interacting with a different piece that is inadvertently three
versions old.</p>
<p>What this means is that, rather than shipping <code>@ember/object</code> on npm, we'd ship
a single <code>ember-source</code> (or something) package that includes the entire
framework. At build time, the Ember build process would virtually map the
<code>@ember/object</code> package to the right file inside <code>ember-source</code>. In essence, all
of the benefits of smaller bundles without the boiling hellbroth of managing
dependencies.</p>
<p>That said, because this RFC is designed with an eye towards eventually
publishing each package to npm individually, we will have that option available
to us in the future once we determine that we can do so without causing lots of
pain.</p>
<a class="header" href="print.html#addenda" id="addenda"><h1>Addenda</h1></a>
<p><em>(Ed. note: These tables are automatically generated from the scripts in the <a href="https://github.com/tomdale/ember-modules-codemod">codemod</a> repository.)</em></p>
<a class="header" href="print.html#addendum-1---table-of-module-names-and-exports-by-global" id="addendum-1---table-of-module-names-and-exports-by-global"><h2>Addendum 1 - Table of Module Names and Exports by Global</h2></a>
<table><thead><tr><th> Before                                </th><th> After                                                                      </th></tr></thead><tbody>
<tr><td> <code>Ember.$</code>                             </td><td> <code>import $ from &quot;jquery&quot;</code>                                                   </td></tr>
<tr><td> <code>Ember.A</code>                             </td><td> <code>import { A } from &quot;@ember/array&quot;</code>                                         </td></tr>
<tr><td> <code>Ember.Application</code>                   </td><td> <code>import Application from &quot;@ember/application&quot;</code>                             </td></tr>
<tr><td> <code>Ember.Array</code>                         </td><td> <code>import EmberArray from &quot;@ember/array&quot;</code>                                    </td></tr>
<tr><td> <code>Ember.ArrayProxy</code>                    </td><td> <code>import ArrayProxy from &quot;@ember/array/proxy&quot;</code>                              </td></tr>
<tr><td> <code>Ember.AutoLocation</code>                  </td><td> <code>import AutoLocation from &quot;@ember/routing/auto-location&quot;</code>                  </td></tr>
<tr><td> <code>Ember.Checkbox</code>                      </td><td> <code>import Checkbox from &quot;@ember/component/checkbox&quot;</code>                         </td></tr>
<tr><td> <code>Ember.Component</code>                     </td><td> <code>import Component from &quot;@ember/component&quot;</code>                                 </td></tr>
<tr><td> <code>Ember.ContainerDebugAdapter</code>         </td><td> <code>import ContainerDebugAdapter from &quot;@ember/debug/container-debug-adapter&quot;</code> </td></tr>
<tr><td> <code>Ember.Controller</code>                    </td><td> <code>import Controller from &quot;@ember/controller&quot;</code>                               </td></tr>
<tr><td> <code>Ember.DataAdapter</code>                   </td><td> <code>import DataAdapter from &quot;@ember/debug/data-adapter&quot;</code>                      </td></tr>
<tr><td> <code>Ember.DefaultResolver</code>               </td><td> <code>import GlobalsResolver from &quot;@ember/application/globals-resolver&quot;</code>        </td></tr>
<tr><td> <code>Ember.Enumerable</code>                    </td><td> <code>import Enumerable from &quot;@ember/enumerable&quot;</code>                               </td></tr>
<tr><td> <code>Ember.Evented</code>                       </td><td> <code>import Evented from &quot;@ember/object/evented&quot;</code>                              </td></tr>
<tr><td> <code>Ember.HashLocation</code>                  </td><td> <code>import HashLocation from &quot;@ember/routing/hash-location&quot;</code>                  </td></tr>
<tr><td> <code>Ember.Helper</code>                        </td><td> <code>import Helper from &quot;@ember/component/helper&quot;</code>                             </td></tr>
<tr><td> <code>Ember.Helper.helper</code>                 </td><td> <code>import { helper } from &quot;@ember/component/helper&quot;</code>                         </td></tr>
<tr><td> <code>Ember.HistoryLocation</code>               </td><td> <code>import HistoryLocation from &quot;@ember/routing/history-location&quot;</code>            </td></tr>
<tr><td> <code>Ember.LinkComponent</code>                 </td><td> <code>import LinkComponent from &quot;@ember/routing/link-component&quot;</code>                </td></tr>
<tr><td> <code>Ember.Location</code>                      </td><td> <code>import Location from &quot;@ember/routing/location&quot;</code>                           </td></tr>
<tr><td> <code>Ember.Map</code>                           </td><td> <code>import EmberMap from &quot;@ember/map&quot;</code>                                        </td></tr>
<tr><td> <code>Ember.MapWithDefault</code>                </td><td> <code>import MapWithDefault from &quot;@ember/map/with-default&quot;</code>                     </td></tr>
<tr><td> <code>Ember.Mixin</code>                         </td><td> <code>import Mixin from &quot;@ember/object/mixin&quot;</code>                                  </td></tr>
<tr><td> <code>Ember.MutableArray</code>                  </td><td> <code>import MutableArray from &quot;@ember/array/mutable&quot;</code>                          </td></tr>
<tr><td> <code>Ember.NoneLocation</code>                  </td><td> <code>import NoneLocation from &quot;@ember/routing/none-location&quot;</code>                  </td></tr>
<tr><td> <code>Ember.Object</code>                        </td><td> <code>import EmberObject from &quot;@ember/object&quot;</code>                                  </td></tr>
<tr><td> <code>Ember.RSVP</code>                          </td><td> <code>import RSVP from &quot;rsvp&quot;</code>                                                  </td></tr>
<tr><td> <code>Ember.Resolver</code>                      </td><td> <code>import Resolver from &quot;@ember/application/resolver&quot;</code>                       </td></tr>
<tr><td> <code>Ember.Route</code>                         </td><td> <code>import Route from &quot;@ember/routing/route&quot;</code>                                 </td></tr>
<tr><td> <code>Ember.Router</code>                        </td><td> <code>import Router from &quot;@ember/routing/router&quot;</code>                               </td></tr>
<tr><td> <code>Ember.Service</code>                       </td><td> <code>import Service from &quot;@ember/service&quot;</code>                                     </td></tr>
<tr><td> <code>Ember.String.camelize</code>               </td><td> <code>import { camelize } from &quot;@ember/string&quot;</code>                                 </td></tr>
<tr><td> <code>Ember.String.capitalize</code>             </td><td> <code>import { capitalize } from &quot;@ember/string&quot;</code>                               </td></tr>
<tr><td> <code>Ember.String.classify</code>               </td><td> <code>import { classify } from &quot;@ember/string&quot;</code>                                 </td></tr>
<tr><td> <code>Ember.String.dasherize</code>              </td><td> <code>import { dasherize } from &quot;@ember/string&quot;</code>                                </td></tr>
<tr><td> <code>Ember.String.decamelize</code>             </td><td> <code>import { decamelize } from &quot;@ember/string&quot;</code>                               </td></tr>
<tr><td> <code>Ember.String.fmt</code>                    </td><td> <code>import { fmt } from &quot;@ember/string&quot;</code>                                      </td></tr>
<tr><td> <code>Ember.String.htmlSafe</code>               </td><td> <code>import { htmlSafe } from &quot;@ember/string&quot;</code>                                 </td></tr>
<tr><td> <code>Ember.String.loc</code>                    </td><td> <code>import { loc } from &quot;@ember/string&quot;</code>                                      </td></tr>
<tr><td> <code>Ember.String.underscore</code>             </td><td> <code>import { underscore } from &quot;@ember/string&quot;</code>                               </td></tr>
<tr><td> <code>Ember.String.w</code>                      </td><td> <code>import { w } from &quot;@ember/string&quot;</code>                                        </td></tr>
<tr><td> <code>Ember.TextArea</code>                      </td><td> <code>import TextArea from &quot;@ember/component/text-area&quot;</code>                        </td></tr>
<tr><td> <code>Ember.TextField</code>                     </td><td> <code>import TextField from &quot;@ember/component/text-field&quot;</code>                      </td></tr>
<tr><td> <code>Ember.addListener</code>                   </td><td> <code>import { addListener } from &quot;@ember/object/events&quot;</code>                       </td></tr>
<tr><td> <code>Ember.addObserver</code>                   </td><td> <code>import { addObserver } from &quot;@ember/object/observers&quot;</code>                    </td></tr>
<tr><td> <code>Ember.aliasMethod</code>                   </td><td> <code>import { aliasMethod } from &quot;@ember/object&quot;</code>                              </td></tr>
<tr><td> <code>Ember.assert</code>                        </td><td> <code>import { assert } from &quot;@ember/debug&quot;</code>                                    </td></tr>
<tr><td> <code>Ember.assign</code>                        </td><td> <code>import { assign } from &quot;@ember/polyfills&quot;</code>                                </td></tr>
<tr><td> <code>Ember.cacheFor</code>                      </td><td> <code>import { cacheFor } from &quot;@ember/object/internals&quot;</code>                       </td></tr>
<tr><td> <code>Ember.compare</code>                       </td><td> <code>import { compare } from &quot;@ember/utils&quot;</code>                                   </td></tr>
<tr><td> <code>Ember.computed</code>                      </td><td> <code>import { computed } from &quot;@ember/object&quot;</code>                                 </td></tr>
<tr><td> <code>Ember.computed.alias</code>                </td><td> <code>import { alias } from &quot;@ember/object/computed&quot;</code>                           </td></tr>
<tr><td> <code>Ember.computed.and</code>                  </td><td> <code>import { and } from &quot;@ember/object/computed&quot;</code>                             </td></tr>
<tr><td> <code>Ember.computed.bool</code>                 </td><td> <code>import { bool } from &quot;@ember/object/computed&quot;</code>                            </td></tr>
<tr><td> <code>Ember.computed.collect</code>              </td><td> <code>import { collect } from &quot;@ember/object/computed&quot;</code>                         </td></tr>
<tr><td> <code>Ember.computed.deprecatingAlias</code>     </td><td> <code>import { deprecatingAlias } from &quot;@ember/object/computed&quot;</code>                </td></tr>
<tr><td> <code>Ember.computed.empty</code>                </td><td> <code>import { empty } from &quot;@ember/object/computed&quot;</code>                           </td></tr>
<tr><td> <code>Ember.computed.equal</code>                </td><td> <code>import { equal } from &quot;@ember/object/computed&quot;</code>                           </td></tr>
<tr><td> <code>Ember.computed.filter</code>               </td><td> <code>import { filter } from &quot;@ember/object/computed&quot;</code>                          </td></tr>
<tr><td> <code>Ember.computed.filterBy</code>             </td><td> <code>import { filterBy } from &quot;@ember/object/computed&quot;</code>                        </td></tr>
<tr><td> <code>Ember.computed.filterProperty</code>       </td><td> <code>import { filterProperty } from &quot;@ember/object/computed&quot;</code>                  </td></tr>
<tr><td> <code>Ember.computed.gt</code>                   </td><td> <code>import { gt } from &quot;@ember/object/computed&quot;</code>                              </td></tr>
<tr><td> <code>Ember.computed.gte</code>                  </td><td> <code>import { gte } from &quot;@ember/object/computed&quot;</code>                             </td></tr>
<tr><td> <code>Ember.computed.intersect</code>            </td><td> <code>import { intersect } from &quot;@ember/object/computed&quot;</code>                       </td></tr>
<tr><td> <code>Ember.computed.lt</code>                   </td><td> <code>import { lt } from &quot;@ember/object/computed&quot;</code>                              </td></tr>
<tr><td> <code>Ember.computed.lte</code>                  </td><td> <code>import { lte } from &quot;@ember/object/computed&quot;</code>                             </td></tr>
<tr><td> <code>Ember.computed.map</code>                  </td><td> <code>import { map } from &quot;@ember/object/computed&quot;</code>                             </td></tr>
<tr><td> <code>Ember.computed.mapBy</code>                </td><td> <code>import { mapBy } from &quot;@ember/object/computed&quot;</code>                           </td></tr>
<tr><td> <code>Ember.computed.mapProperty</code>          </td><td> <code>import { mapProperty } from &quot;@ember/object/computed&quot;</code>                     </td></tr>
<tr><td> <code>Ember.computed.match</code>                </td><td> <code>import { match } from &quot;@ember/object/computed&quot;</code>                           </td></tr>
<tr><td> <code>Ember.computed.max</code>                  </td><td> <code>import { max } from &quot;@ember/object/computed&quot;</code>                             </td></tr>
<tr><td> <code>Ember.computed.min</code>                  </td><td> <code>import { min } from &quot;@ember/object/computed&quot;</code>                             </td></tr>
<tr><td> <code>Ember.computed.none</code>                 </td><td> <code>import { none } from &quot;@ember/object/computed&quot;</code>                            </td></tr>
<tr><td> <code>Ember.computed.not</code>                  </td><td> <code>import { not } from &quot;@ember/object/computed&quot;</code>                             </td></tr>
<tr><td> <code>Ember.computed.notEmpty</code>             </td><td> <code>import { notEmpty } from &quot;@ember/object/computed&quot;</code>                        </td></tr>
<tr><td> <code>Ember.computed.oneWay</code>               </td><td> <code>import { oneWay } from &quot;@ember/object/computed&quot;</code>                          </td></tr>
<tr><td> <code>Ember.computed.or</code>                   </td><td> <code>import { or } from &quot;@ember/object/computed&quot;</code>                              </td></tr>
<tr><td> <code>Ember.computed.readOnly</code>             </td><td> <code>import { readOnly } from &quot;@ember/object/computed&quot;</code>                        </td></tr>
<tr><td> <code>Ember.computed.reads</code>                </td><td> <code>import { reads } from &quot;@ember/object/computed&quot;</code>                           </td></tr>
<tr><td> <code>Ember.computed.setDiff</code>              </td><td> <code>import { setDiff } from &quot;@ember/object/computed&quot;</code>                         </td></tr>
<tr><td> <code>Ember.computed.sort</code>                 </td><td> <code>import { sort } from &quot;@ember/object/computed&quot;</code>                            </td></tr>
<tr><td> <code>Ember.computed.sum</code>                  </td><td> <code>import { sum } from &quot;@ember/object/computed&quot;</code>                             </td></tr>
<tr><td> <code>Ember.computed.union</code>                </td><td> <code>import { union } from &quot;@ember/object/computed&quot;</code>                           </td></tr>
<tr><td> <code>Ember.computed.uniq</code>                 </td><td> <code>import { uniq } from &quot;@ember/object/computed&quot;</code>                            </td></tr>
<tr><td> <code>Ember.copy</code>                          </td><td> <code>import { copy } from &quot;@ember/object/internals&quot;</code>                           </td></tr>
<tr><td> <code>Ember.create</code>                        </td><td> <code>import { create } from &quot;@ember/polyfills&quot;</code>                                </td></tr>
<tr><td> <code>Ember.debug</code>                         </td><td> <code>import { debug } from &quot;@ember/debug&quot;</code>                                     </td></tr>
<tr><td> <code>Ember.deprecate</code>                     </td><td> <code>import { deprecate } from &quot;@ember/application/deprecations&quot;</code>              </td></tr>
<tr><td> <code>Ember.deprecateFunc</code>                 </td><td> <code>import { deprecateFunc } from &quot;@ember/application/deprecations&quot;</code>          </td></tr>
<tr><td> <code>Ember.get</code>                           </td><td> <code>import { get } from &quot;@ember/object&quot;</code>                                      </td></tr>
<tr><td> <code>Ember.getOwner</code>                      </td><td> <code>import { getOwner } from &quot;@ember/application&quot;</code>                            </td></tr>
<tr><td> <code>Ember.getProperties</code>                 </td><td> <code>import { getProperties } from &quot;@ember/object&quot;</code>                            </td></tr>
<tr><td> <code>Ember.guidFor</code>                       </td><td> <code>import { guidFor } from &quot;@ember/object/internals&quot;</code>                        </td></tr>
<tr><td> <code>Ember.inject.controller</code>             </td><td> <code>import { inject } from &quot;@ember/controller&quot;</code>                               </td></tr>
<tr><td> <code>Ember.inject.service</code>                </td><td> <code>import { inject } from &quot;@ember/service&quot;</code>                                  </td></tr>
<tr><td> <code>Ember.inspect</code>                       </td><td> <code>import { inspect } from &quot;@ember/debug&quot;</code>                                   </td></tr>
<tr><td> <code>Ember.instrument</code>                    </td><td> <code>import { instrument } from &quot;@ember/instrumentation&quot;</code>                      </td></tr>
<tr><td> <code>Ember.isArray</code>                       </td><td> <code>import { isArray } from &quot;@ember/array&quot;</code>                                   </td></tr>
<tr><td> <code>Ember.isBlank</code>                       </td><td> <code>import { isBlank } from &quot;@ember/utils&quot;</code>                                   </td></tr>
<tr><td> <code>Ember.isEmpty</code>                       </td><td> <code>import { isEmpty } from &quot;@ember/utils&quot;</code>                                   </td></tr>
<tr><td> <code>Ember.isEqual</code>                       </td><td> <code>import { isEqual } from &quot;@ember/utils&quot;</code>                                   </td></tr>
<tr><td> <code>Ember.isNone</code>                        </td><td> <code>import { isNone } from &quot;@ember/utils&quot;</code>                                    </td></tr>
<tr><td> <code>Ember.isPresent</code>                     </td><td> <code>import { isPresent } from &quot;@ember/utils&quot;</code>                                 </td></tr>
<tr><td> <code>Ember.keys</code>                          </td><td> <code>import { keys } from &quot;@ember/polyfills&quot;</code>                                  </td></tr>
<tr><td> <code>Ember.makeArray</code>                     </td><td> <code>import { makeArray } from &quot;@ember/array&quot;</code>                                 </td></tr>
<tr><td> <code>Ember.observer</code>                      </td><td> <code>import { observer } from &quot;@ember/object&quot;</code>                                 </td></tr>
<tr><td> <code>Ember.on</code>                            </td><td> <code>import { on } from &quot;@ember/object/evented&quot;</code>                               </td></tr>
<tr><td> <code>Ember.onLoad</code>                        </td><td> <code>import { onLoad } from &quot;@ember/application&quot;</code>                              </td></tr>
<tr><td> <code>Ember.platform.defineProperty</code>       </td><td> <code>import { defineProperty } from &quot;@ember/polyfills&quot;</code>                        </td></tr>
<tr><td> <code>Ember.platform.hasPropertyAccessors</code> </td><td> <code>import { hasPropertyAccessors } from &quot;@ember/polyfills&quot;</code>                  </td></tr>
<tr><td> <code>Ember.removeListener</code>                </td><td> <code>import { removeListener } from &quot;@ember/object/events&quot;</code>                    </td></tr>
<tr><td> <code>Ember.removeObserver</code>                </td><td> <code>import { removeObserver } from &quot;@ember/object/observers&quot;</code>                 </td></tr>
<tr><td> <code>Ember.reset</code>                         </td><td> <code>import { reset } from &quot;@ember/instrumentation&quot;</code>                           </td></tr>
<tr><td> <code>Ember.run</code>                           </td><td> <code>import { run } from &quot;@ember/runloop&quot;</code>                                     </td></tr>
<tr><td> <code>Ember.run.begin</code>                     </td><td> <code>import { begin } from &quot;@ember/runloop&quot;</code>                                   </td></tr>
<tr><td> <code>Ember.run.bind</code>                      </td><td> <code>import { bind } from &quot;@ember/runloop&quot;</code>                                    </td></tr>
<tr><td> <code>Ember.run.cancel</code>                    </td><td> <code>import { cancel } from &quot;@ember/runloop&quot;</code>                                  </td></tr>
<tr><td> <code>Ember.run.debounce</code>                  </td><td> <code>import { debounce } from &quot;@ember/runloop&quot;</code>                                </td></tr>
<tr><td> <code>Ember.run.end</code>                       </td><td> <code>import { end } from &quot;@ember/runloop&quot;</code>                                     </td></tr>
<tr><td> <code>Ember.run.join</code>                      </td><td> <code>import { join } from &quot;@ember/runloop&quot;</code>                                    </td></tr>
<tr><td> <code>Ember.run.later</code>                     </td><td> <code>import { later } from &quot;@ember/runloop&quot;</code>                                   </td></tr>
<tr><td> <code>Ember.run.next</code>                      </td><td> <code>import { next } from &quot;@ember/runloop&quot;</code>                                    </td></tr>
<tr><td> <code>Ember.run.once</code>                      </td><td> <code>import { once } from &quot;@ember/runloop&quot;</code>                                    </td></tr>
<tr><td> <code>Ember.run.schedule</code>                  </td><td> <code>import { schedule } from &quot;@ember/runloop&quot;</code>                                </td></tr>
<tr><td> <code>Ember.run.scheduleOnce</code>              </td><td> <code>import { scheduleOnce } from &quot;@ember/runloop&quot;</code>                            </td></tr>
<tr><td> <code>Ember.run.throttle</code>                  </td><td> <code>import { throttle } from &quot;@ember/runloop&quot;</code>                                </td></tr>
<tr><td> <code>Ember.runInDebug</code>                    </td><td> <code>import { runInDebug } from &quot;@ember/debug&quot;</code>                                </td></tr>
<tr><td> <code>Ember.runLoadHooks</code>                  </td><td> <code>import { runLoadHooks } from &quot;@ember/application&quot;</code>                        </td></tr>
<tr><td> <code>Ember.sendEvent</code>                     </td><td> <code>import { sendEvent } from &quot;@ember/object/events&quot;</code>                         </td></tr>
<tr><td> <code>Ember.set</code>                           </td><td> <code>import { set } from &quot;@ember/object&quot;</code>                                      </td></tr>
<tr><td> <code>Ember.setOwner</code>                      </td><td> <code>import { setOwner } from &quot;@ember/application&quot;</code>                            </td></tr>
<tr><td> <code>Ember.setProperties</code>                 </td><td> <code>import { setProperties } from &quot;@ember/object&quot;</code>                            </td></tr>
<tr><td> <code>Ember.subscribe</code>                     </td><td> <code>import { subscribe } from &quot;@ember/instrumentation&quot;</code>                       </td></tr>
<tr><td> <code>Ember.tryInvoke</code>                     </td><td> <code>import { tryInvoke } from &quot;@ember/utils&quot;</code>                                 </td></tr>
<tr><td> <code>Ember.trySet</code>                        </td><td> <code>import { trySet } from &quot;@ember/object&quot;</code>                                   </td></tr>
<tr><td> <code>Ember.typeOf</code>                        </td><td> <code>import { typeOf } from &quot;@ember/utils&quot;</code>                                    </td></tr>
<tr><td> <code>Ember.unsubscribe</code>                   </td><td> <code>import { unsubscribe } from &quot;@ember/instrumentation&quot;</code>                     </td></tr>
<tr><td> <code>Ember.warn</code>                          </td><td> <code>import { warn } from &quot;@ember/debug&quot;</code>                                      </td></tr>
</tbody></table>
<a class="header" href="print.html#addendum-2---table-of-module-names-and-exports-by-package" id="addendum-2---table-of-module-names-and-exports-by-package"><h2>Addendum 2 - Table of Module Names and Exports by Package</h2></a>
<p>Each package is sorted by module name, then export name.</p>
<a class="header" href="print.html#emberapplication" id="emberapplication"><h3><code>@ember/application</code></h3></a>
<table><thead><tr><th> Module                                                              </th><th> Global                  </th></tr></thead><tbody>
<tr><td> <code>import Application from &quot;@ember/application&quot;</code>                      </td><td> <code>Ember.Application</code>     </td></tr>
<tr><td> <code>import { getOwner } from &quot;@ember/application&quot;</code>                     </td><td> <code>Ember.getOwner</code>        </td></tr>
<tr><td> <code>import { onLoad } from &quot;@ember/application&quot;</code>                       </td><td> <code>Ember.onLoad</code>          </td></tr>
<tr><td> <code>import { runLoadHooks } from &quot;@ember/application&quot;</code>                 </td><td> <code>Ember.runLoadHooks</code>    </td></tr>
<tr><td> <code>import { setOwner } from &quot;@ember/application&quot;</code>                     </td><td> <code>Ember.setOwner</code>        </td></tr>
<tr><td> <code>import { deprecate } from &quot;@ember/application/deprecations&quot;</code>       </td><td> <code>Ember.deprecate</code>       </td></tr>
<tr><td> <code>import { deprecateFunc } from &quot;@ember/application/deprecations&quot;</code>   </td><td> <code>Ember.deprecateFunc</code>   </td></tr>
<tr><td> <code>import GlobalsResolver from &quot;@ember/application/globals-resolver&quot;</code> </td><td> <code>Ember.DefaultResolver</code> </td></tr>
<tr><td> <code>import Resolver from &quot;@ember/application/resolver&quot;</code>                </td><td> <code>Ember.Resolver</code>        </td></tr>
</tbody></table>
<a class="header" href="print.html#emberarray" id="emberarray"><h3><code>@ember/array</code></h3></a>
<table><thead><tr><th> Module                                            </th><th> Global               </th></tr></thead><tbody>
<tr><td> <code>import EmberArray from &quot;@ember/array&quot;</code>           </td><td> <code>Ember.Array</code>        </td></tr>
<tr><td> <code>import { A } from &quot;@ember/array&quot;</code>                </td><td> <code>Ember.A</code>            </td></tr>
<tr><td> <code>import { isArray } from &quot;@ember/array&quot;</code>          </td><td> <code>Ember.isArray</code>      </td></tr>
<tr><td> <code>import { makeArray } from &quot;@ember/array&quot;</code>        </td><td> <code>Ember.makeArray</code>    </td></tr>
<tr><td> <code>import MutableArray from &quot;@ember/array/mutable&quot;</code> </td><td> <code>Ember.MutableArray</code> </td></tr>
<tr><td> <code>import ArrayProxy from &quot;@ember/array/proxy&quot;</code>     </td><td> <code>Ember.ArrayProxy</code>   </td></tr>
</tbody></table>
<a class="header" href="print.html#embercomponent" id="embercomponent"><h3><code>@ember/component</code></h3></a>
<table><thead><tr><th> Module                                                </th><th> Global                </th></tr></thead><tbody>
<tr><td> <code>import Component from &quot;@ember/component&quot;</code>            </td><td> <code>Ember.Component</code>     </td></tr>
<tr><td> <code>import Checkbox from &quot;@ember/component/checkbox&quot;</code>    </td><td> <code>Ember.Checkbox</code>      </td></tr>
<tr><td> <code>import Helper from &quot;@ember/component/helper&quot;</code>        </td><td> <code>Ember.Helper</code>        </td></tr>
<tr><td> <code>import { helper } from &quot;@ember/component/helper&quot;</code>    </td><td> <code>Ember.Helper.helper</code> </td></tr>
<tr><td> <code>import TextArea from &quot;@ember/component/text-area&quot;</code>   </td><td> <code>Ember.TextArea</code>      </td></tr>
<tr><td> <code>import TextField from &quot;@ember/component/text-field&quot;</code> </td><td> <code>Ember.TextField</code>     </td></tr>
</tbody></table>
<a class="header" href="print.html#embercontroller" id="embercontroller"><h3><code>@ember/controller</code></h3></a>
<table><thead><tr><th> Module                                       </th><th> Global                    </th></tr></thead><tbody>
<tr><td> <code>import Controller from &quot;@ember/controller&quot;</code> </td><td> <code>Ember.Controller</code>        </td></tr>
<tr><td> <code>import { inject } from &quot;@ember/controller&quot;</code> </td><td> <code>Ember.inject.controller</code> </td></tr>
</tbody></table>
<a class="header" href="print.html#emberdebug" id="emberdebug"><h3><code>@ember/debug</code></h3></a>
<table><thead><tr><th> Module                                                                     </th><th> Global                        </th></tr></thead><tbody>
<tr><td> <code>import { assert } from &quot;@ember/debug&quot;</code>                                    </td><td> <code>Ember.assert</code>                </td></tr>
<tr><td> <code>import { debug } from &quot;@ember/debug&quot;</code>                                     </td><td> <code>Ember.debug</code>                 </td></tr>
<tr><td> <code>import { inspect } from &quot;@ember/debug&quot;</code>                                   </td><td> <code>Ember.inspect</code>               </td></tr>
<tr><td> <code>import { runInDebug } from &quot;@ember/debug&quot;</code>                                </td><td> <code>Ember.runInDebug</code>            </td></tr>
<tr><td> <code>import { warn } from &quot;@ember/debug&quot;</code>                                      </td><td> <code>Ember.warn</code>                  </td></tr>
<tr><td> <code>import ContainerDebugAdapter from &quot;@ember/debug/container-debug-adapter&quot;</code> </td><td> <code>Ember.ContainerDebugAdapter</code> </td></tr>
<tr><td> <code>import DataAdapter from &quot;@ember/debug/data-adapter&quot;</code>                      </td><td> <code>Ember.DataAdapter</code>           </td></tr>
</tbody></table>
<a class="header" href="print.html#emberenumerable" id="emberenumerable"><h3><code>@ember/enumerable</code></h3></a>
<table><thead><tr><th> Module                                       </th><th> Global             </th></tr></thead><tbody>
<tr><td> <code>import Enumerable from &quot;@ember/enumerable&quot;</code> </td><td> <code>Ember.Enumerable</code> </td></tr>
</tbody></table>
<a class="header" href="print.html#emberinstrumentation" id="emberinstrumentation"><h3><code>@ember/instrumentation</code></h3></a>
<table><thead><tr><th> Module                                                 </th><th> Global              </th></tr></thead><tbody>
<tr><td> <code>import { instrument } from &quot;@ember/instrumentation&quot;</code>  </td><td> <code>Ember.instrument</code>  </td></tr>
<tr><td> <code>import { reset } from &quot;@ember/instrumentation&quot;</code>       </td><td> <code>Ember.reset</code>       </td></tr>
<tr><td> <code>import { subscribe } from &quot;@ember/instrumentation&quot;</code>   </td><td> <code>Ember.subscribe</code>   </td></tr>
<tr><td> <code>import { unsubscribe } from &quot;@ember/instrumentation&quot;</code> </td><td> <code>Ember.unsubscribe</code> </td></tr>
</tbody></table>
<a class="header" href="print.html#embermap" id="embermap"><h3><code>@ember/map</code></h3></a>
<table><thead><tr><th> Module                                                 </th><th> Global                 </th></tr></thead><tbody>
<tr><td> <code>import EmberMap from &quot;@ember/map&quot;</code>                    </td><td> <code>Ember.Map</code>            </td></tr>
<tr><td> <code>import MapWithDefault from &quot;@ember/map/with-default&quot;</code> </td><td> <code>Ember.MapWithDefault</code> </td></tr>
</tbody></table>
<a class="header" href="print.html#emberobject" id="emberobject"><h3><code>@ember/object</code></h3></a>
<table><thead><tr><th> Module                                                      </th><th> Global                            </th></tr></thead><tbody>
<tr><td> <code>import EmberObject from &quot;@ember/object&quot;</code>                   </td><td> <code>Ember.Object</code>                    </td></tr>
<tr><td> <code>import { aliasMethod } from &quot;@ember/object&quot;</code>               </td><td> <code>Ember.aliasMethod</code>               </td></tr>
<tr><td> <code>import { computed } from &quot;@ember/object&quot;</code>                  </td><td> <code>Ember.computed</code>                  </td></tr>
<tr><td> <code>import { get } from &quot;@ember/object&quot;</code>                       </td><td> <code>Ember.get</code>                       </td></tr>
<tr><td> <code>import { getProperties } from &quot;@ember/object&quot;</code>             </td><td> <code>Ember.getProperties</code>             </td></tr>
<tr><td> <code>import { observer } from &quot;@ember/object&quot;</code>                  </td><td> <code>Ember.observer</code>                  </td></tr>
<tr><td> <code>import { set } from &quot;@ember/object&quot;</code>                       </td><td> <code>Ember.set</code>                       </td></tr>
<tr><td> <code>import { setProperties } from &quot;@ember/object&quot;</code>             </td><td> <code>Ember.setProperties</code>             </td></tr>
<tr><td> <code>import { trySet } from &quot;@ember/object&quot;</code>                    </td><td> <code>Ember.trySet</code>                    </td></tr>
<tr><td> <code>import { alias } from &quot;@ember/object/computed&quot;</code>            </td><td> <code>Ember.computed.alias</code>            </td></tr>
<tr><td> <code>import { and } from &quot;@ember/object/computed&quot;</code>              </td><td> <code>Ember.computed.and</code>              </td></tr>
<tr><td> <code>import { bool } from &quot;@ember/object/computed&quot;</code>             </td><td> <code>Ember.computed.bool</code>             </td></tr>
<tr><td> <code>import { collect } from &quot;@ember/object/computed&quot;</code>          </td><td> <code>Ember.computed.collect</code>          </td></tr>
<tr><td> <code>import { deprecatingAlias } from &quot;@ember/object/computed&quot;</code> </td><td> <code>Ember.computed.deprecatingAlias</code> </td></tr>
<tr><td> <code>import { empty } from &quot;@ember/object/computed&quot;</code>            </td><td> <code>Ember.computed.empty</code>            </td></tr>
<tr><td> <code>import { equal } from &quot;@ember/object/computed&quot;</code>            </td><td> <code>Ember.computed.equal</code>            </td></tr>
<tr><td> <code>import { filter } from &quot;@ember/object/computed&quot;</code>           </td><td> <code>Ember.computed.filter</code>           </td></tr>
<tr><td> <code>import { filterBy } from &quot;@ember/object/computed&quot;</code>         </td><td> <code>Ember.computed.filterBy</code>         </td></tr>
<tr><td> <code>import { filterProperty } from &quot;@ember/object/computed&quot;</code>   </td><td> <code>Ember.computed.filterProperty</code>   </td></tr>
<tr><td> <code>import { gt } from &quot;@ember/object/computed&quot;</code>               </td><td> <code>Ember.computed.gt</code>               </td></tr>
<tr><td> <code>import { gte } from &quot;@ember/object/computed&quot;</code>              </td><td> <code>Ember.computed.gte</code>              </td></tr>
<tr><td> <code>import { intersect } from &quot;@ember/object/computed&quot;</code>        </td><td> <code>Ember.computed.intersect</code>        </td></tr>
<tr><td> <code>import { lt } from &quot;@ember/object/computed&quot;</code>               </td><td> <code>Ember.computed.lt</code>               </td></tr>
<tr><td> <code>import { lte } from &quot;@ember/object/computed&quot;</code>              </td><td> <code>Ember.computed.lte</code>              </td></tr>
<tr><td> <code>import { map } from &quot;@ember/object/computed&quot;</code>              </td><td> <code>Ember.computed.map</code>              </td></tr>
<tr><td> <code>import { mapBy } from &quot;@ember/object/computed&quot;</code>            </td><td> <code>Ember.computed.mapBy</code>            </td></tr>
<tr><td> <code>import { mapProperty } from &quot;@ember/object/computed&quot;</code>      </td><td> <code>Ember.computed.mapProperty</code>      </td></tr>
<tr><td> <code>import { match } from &quot;@ember/object/computed&quot;</code>            </td><td> <code>Ember.computed.match</code>            </td></tr>
<tr><td> <code>import { max } from &quot;@ember/object/computed&quot;</code>              </td><td> <code>Ember.computed.max</code>              </td></tr>
<tr><td> <code>import { min } from &quot;@ember/object/computed&quot;</code>              </td><td> <code>Ember.computed.min</code>              </td></tr>
<tr><td> <code>import { none } from &quot;@ember/object/computed&quot;</code>             </td><td> <code>Ember.computed.none</code>             </td></tr>
<tr><td> <code>import { not } from &quot;@ember/object/computed&quot;</code>              </td><td> <code>Ember.computed.not</code>              </td></tr>
<tr><td> <code>import { notEmpty } from &quot;@ember/object/computed&quot;</code>         </td><td> <code>Ember.computed.notEmpty</code>         </td></tr>
<tr><td> <code>import { oneWay } from &quot;@ember/object/computed&quot;</code>           </td><td> <code>Ember.computed.oneWay</code>           </td></tr>
<tr><td> <code>import { or } from &quot;@ember/object/computed&quot;</code>               </td><td> <code>Ember.computed.or</code>               </td></tr>
<tr><td> <code>import { readOnly } from &quot;@ember/object/computed&quot;</code>         </td><td> <code>Ember.computed.readOnly</code>         </td></tr>
<tr><td> <code>import { reads } from &quot;@ember/object/computed&quot;</code>            </td><td> <code>Ember.computed.reads</code>            </td></tr>
<tr><td> <code>import { setDiff } from &quot;@ember/object/computed&quot;</code>          </td><td> <code>Ember.computed.setDiff</code>          </td></tr>
<tr><td> <code>import { sort } from &quot;@ember/object/computed&quot;</code>             </td><td> <code>Ember.computed.sort</code>             </td></tr>
<tr><td> <code>import { sum } from &quot;@ember/object/computed&quot;</code>              </td><td> <code>Ember.computed.sum</code>              </td></tr>
<tr><td> <code>import { union } from &quot;@ember/object/computed&quot;</code>            </td><td> <code>Ember.computed.union</code>            </td></tr>
<tr><td> <code>import { uniq } from &quot;@ember/object/computed&quot;</code>             </td><td> <code>Ember.computed.uniq</code>             </td></tr>
<tr><td> <code>import Evented from &quot;@ember/object/evented&quot;</code>               </td><td> <code>Ember.Evented</code>                   </td></tr>
<tr><td> <code>import { on } from &quot;@ember/object/evented&quot;</code>                </td><td> <code>Ember.on</code>                        </td></tr>
<tr><td> <code>import { addListener } from &quot;@ember/object/events&quot;</code>        </td><td> <code>Ember.addListener</code>               </td></tr>
<tr><td> <code>import { removeListener } from &quot;@ember/object/events&quot;</code>     </td><td> <code>Ember.removeListener</code>            </td></tr>
<tr><td> <code>import { sendEvent } from &quot;@ember/object/events&quot;</code>          </td><td> <code>Ember.sendEvent</code>                 </td></tr>
<tr><td> <code>import { cacheFor } from &quot;@ember/object/internals&quot;</code>        </td><td> <code>Ember.cacheFor</code>                  </td></tr>
<tr><td> <code>import { copy } from &quot;@ember/object/internals&quot;</code>            </td><td> <code>Ember.copy</code>                      </td></tr>
<tr><td> <code>import { guidFor } from &quot;@ember/object/internals&quot;</code>         </td><td> <code>Ember.guidFor</code>                   </td></tr>
<tr><td> <code>import Mixin from &quot;@ember/object/mixin&quot;</code>                   </td><td> <code>Ember.Mixin</code>                     </td></tr>
<tr><td> <code>import { addObserver } from &quot;@ember/object/observers&quot;</code>     </td><td> <code>Ember.addObserver</code>               </td></tr>
<tr><td> <code>import { removeObserver } from &quot;@ember/object/observers&quot;</code>  </td><td> <code>Ember.removeObserver</code>            </td></tr>
</tbody></table>
<a class="header" href="print.html#emberpolyfills" id="emberpolyfills"><h3><code>@ember/polyfills</code></h3></a>
<table><thead><tr><th> Module                                                    </th><th> Global                                </th></tr></thead><tbody>
<tr><td> <code>import { assign } from &quot;@ember/polyfills&quot;</code>               </td><td> <code>Ember.assign</code>                        </td></tr>
<tr><td> <code>import { create } from &quot;@ember/polyfills&quot;</code>               </td><td> <code>Ember.create</code>                        </td></tr>
<tr><td> <code>import { defineProperty } from &quot;@ember/polyfills&quot;</code>       </td><td> <code>Ember.platform.defineProperty</code>       </td></tr>
<tr><td> <code>import { hasPropertyAccessors } from &quot;@ember/polyfills&quot;</code> </td><td> <code>Ember.platform.hasPropertyAccessors</code> </td></tr>
<tr><td> <code>import { keys } from &quot;@ember/polyfills&quot;</code>                 </td><td> <code>Ember.keys</code>                          </td></tr>
</tbody></table>
<a class="header" href="print.html#emberrouting" id="emberrouting"><h3><code>@ember/routing</code></h3></a>
<table><thead><tr><th> Module                                                          </th><th> Global                  </th></tr></thead><tbody>
<tr><td> <code>import AutoLocation from &quot;@ember/routing/auto-location&quot;</code>       </td><td> <code>Ember.AutoLocation</code>    </td></tr>
<tr><td> <code>import HashLocation from &quot;@ember/routing/hash-location&quot;</code>       </td><td> <code>Ember.HashLocation</code>    </td></tr>
<tr><td> <code>import HistoryLocation from &quot;@ember/routing/history-location&quot;</code> </td><td> <code>Ember.HistoryLocation</code> </td></tr>
<tr><td> <code>import LinkComponent from &quot;@ember/routing/link-component&quot;</code>     </td><td> <code>Ember.LinkComponent</code>   </td></tr>
<tr><td> <code>import Location from &quot;@ember/routing/location&quot;</code>                </td><td> <code>Ember.Location</code>        </td></tr>
<tr><td> <code>import NoneLocation from &quot;@ember/routing/none-location&quot;</code>       </td><td> <code>Ember.NoneLocation</code>    </td></tr>
<tr><td> <code>import Route from &quot;@ember/routing/route&quot;</code>                      </td><td> <code>Ember.Route</code>           </td></tr>
<tr><td> <code>import Router from &quot;@ember/routing/router&quot;</code>                    </td><td> <code>Ember.Router</code>          </td></tr>
</tbody></table>
<a class="header" href="print.html#emberrunloop" id="emberrunloop"><h3><code>@ember/runloop</code></h3></a>
<table><thead><tr><th> Module                                          </th><th> Global                   </th></tr></thead><tbody>
<tr><td> <code>import { begin } from &quot;@ember/runloop&quot;</code>        </td><td> <code>Ember.run.begin</code>        </td></tr>
<tr><td> <code>import { bind } from &quot;@ember/runloop&quot;</code>         </td><td> <code>Ember.run.bind</code>         </td></tr>
<tr><td> <code>import { cancel } from &quot;@ember/runloop&quot;</code>       </td><td> <code>Ember.run.cancel</code>       </td></tr>
<tr><td> <code>import { debounce } from &quot;@ember/runloop&quot;</code>     </td><td> <code>Ember.run.debounce</code>     </td></tr>
<tr><td> <code>import { end } from &quot;@ember/runloop&quot;</code>          </td><td> <code>Ember.run.end</code>          </td></tr>
<tr><td> <code>import { join } from &quot;@ember/runloop&quot;</code>         </td><td> <code>Ember.run.join</code>         </td></tr>
<tr><td> <code>import { later } from &quot;@ember/runloop&quot;</code>        </td><td> <code>Ember.run.later</code>        </td></tr>
<tr><td> <code>import { next } from &quot;@ember/runloop&quot;</code>         </td><td> <code>Ember.run.next</code>         </td></tr>
<tr><td> <code>import { once } from &quot;@ember/runloop&quot;</code>         </td><td> <code>Ember.run.once</code>         </td></tr>
<tr><td> <code>import { run } from &quot;@ember/runloop&quot;</code>          </td><td> <code>Ember.run</code>              </td></tr>
<tr><td> <code>import { schedule } from &quot;@ember/runloop&quot;</code>     </td><td> <code>Ember.run.schedule</code>     </td></tr>
<tr><td> <code>import { scheduleOnce } from &quot;@ember/runloop&quot;</code> </td><td> <code>Ember.run.scheduleOnce</code> </td></tr>
<tr><td> <code>import { throttle } from &quot;@ember/runloop&quot;</code>     </td><td> <code>Ember.run.throttle</code>     </td></tr>
</tbody></table>
<a class="header" href="print.html#emberservice" id="emberservice"><h3><code>@ember/service</code></h3></a>
<table><thead><tr><th> Module                                    </th><th> Global                 </th></tr></thead><tbody>
<tr><td> <code>import Service from &quot;@ember/service&quot;</code>    </td><td> <code>Ember.Service</code>        </td></tr>
<tr><td> <code>import { inject } from &quot;@ember/service&quot;</code> </td><td> <code>Ember.inject.service</code> </td></tr>
</tbody></table>
<a class="header" href="print.html#emberstring" id="emberstring"><h3><code>@ember/string</code></h3></a>
<table><thead><tr><th> Module                                       </th><th> Global                    </th></tr></thead><tbody>
<tr><td> <code>import { camelize } from &quot;@ember/string&quot;</code>   </td><td> <code>Ember.String.camelize</code>   </td></tr>
<tr><td> <code>import { capitalize } from &quot;@ember/string&quot;</code> </td><td> <code>Ember.String.capitalize</code> </td></tr>
<tr><td> <code>import { classify } from &quot;@ember/string&quot;</code>   </td><td> <code>Ember.String.classify</code>   </td></tr>
<tr><td> <code>import { dasherize } from &quot;@ember/string&quot;</code>  </td><td> <code>Ember.String.dasherize</code>  </td></tr>
<tr><td> <code>import { decamelize } from &quot;@ember/string&quot;</code> </td><td> <code>Ember.String.decamelize</code> </td></tr>
<tr><td> <code>import { fmt } from &quot;@ember/string&quot;</code>        </td><td> <code>Ember.String.fmt</code>        </td></tr>
<tr><td> <code>import { htmlSafe } from &quot;@ember/string&quot;</code>   </td><td> <code>Ember.String.htmlSafe</code>   </td></tr>
<tr><td> <code>import { loc } from &quot;@ember/string&quot;</code>        </td><td> <code>Ember.String.loc</code>        </td></tr>
<tr><td> <code>import { underscore } from &quot;@ember/string&quot;</code> </td><td> <code>Ember.String.underscore</code> </td></tr>
<tr><td> <code>import { w } from &quot;@ember/string&quot;</code>          </td><td> <code>Ember.String.w</code>          </td></tr>
</tbody></table>
<a class="header" href="print.html#emberutils" id="emberutils"><h3><code>@ember/utils</code></h3></a>
<table><thead><tr><th> Module                                     </th><th> Global            </th></tr></thead><tbody>
<tr><td> <code>import { compare } from &quot;@ember/utils&quot;</code>   </td><td> <code>Ember.compare</code>   </td></tr>
<tr><td> <code>import { isBlank } from &quot;@ember/utils&quot;</code>   </td><td> <code>Ember.isBlank</code>   </td></tr>
<tr><td> <code>import { isEmpty } from &quot;@ember/utils&quot;</code>   </td><td> <code>Ember.isEmpty</code>   </td></tr>
<tr><td> <code>import { isNone } from &quot;@ember/utils&quot;</code>    </td><td> <code>Ember.isNone</code>    </td></tr>
<tr><td> <code>import { isPresent } from &quot;@ember/utils&quot;</code> </td><td> <code>Ember.isPresent</code> </td></tr>
<tr><td> <code>import { tryInvoke } from &quot;@ember/utils&quot;</code> </td><td> <code>Ember.tryInvoke</code> </td></tr>
<tr><td> <code>import { typeOf } from &quot;@ember/utils&quot;</code>    </td><td> <code>Ember.typeOf</code>    </td></tr>
</tbody></table>
<a class="header" href="print.html#jquery" id="jquery"><h3><code>jquery</code></h3></a>
<table><thead><tr><th> Module                   </th><th> Global    </th></tr></thead><tbody>
<tr><td> <code>import $ from &quot;jquery&quot;</code> </td><td> <code>Ember.$</code> </td></tr>
</tbody></table>
<a class="header" href="print.html#rsvp" id="rsvp"><h3><code>rsvp</code></h3></a>
<table><thead><tr><th> Module                    </th><th> Global       </th></tr></thead><tbody>
<tr><td> <code>import RSVP from &quot;rsvp&quot;</code> </td><td> <code>Ember.RSVP</code> </td></tr>
</tbody></table>
<a class="header" href="print.html#addendum-3---table-of-modules-with-side-effects" id="addendum-3---table-of-modules-with-side-effects"><h2>Addendum 3 - Table of Modules with Side Effects</h2></a>
<table><thead><tr><th> Module                               </th><th> Description                                </th></tr></thead><tbody>
<tr><td> <code>import &quot;@ember/extensions&quot;</code>         </td><td> Adds all of Ember's prototype extensions.  </td></tr>
<tr><td> <code>import &quot;@ember/extensions/string&quot;</code>  </td><td> Adds just <code>String</code> prototype extensions.   </td></tr>
<tr><td> <code>import &quot;@ember/extensions/array&quot;</code>   </td><td> Adds just <code>Array</code> prototype extensions.    </td></tr>
<tr><td> <code>import &quot;@ember/extensions/function&quot;</code></td><td> Adds just <code>Function</code> prototype extensions. </td></tr>
</tbody></table>
<ul>
<li>Start Date: 2016-11-18</li>
<li>RFC PR: <a href="https://github.com/emberjs/rfcs/pull/178">#178</a></li>
<li>Ember Issue: <a href="https://github.com/emberjs/ember.js/issues/14746">#14746</a></li>
</ul>
<a class="header" href="print.html#summary-25" id="summary-25"><h1>Summary</h1></a>
<p>The <code>Ember.K</code> utility function is a low level utility that has lost most of its value today.</p>
<a class="header" href="print.html#motivation-26" id="motivation-26"><h1>Motivation</h1></a>
<p>Let's start explaining what <code>Ember.K</code> is.</p>
<p>It is an utility function to avoid boilerplace code and limit the creation of function instances
in Ember's internals. The source code for this API is the following:</p>
<pre><code class="language-js">Ember.K = function() {
  return this;
}
</code></pre>
<p>In a world of globals, writing <code>somefn: Ember.K</code> was effectively shorter
than writing</p>
<pre><code class="language-js">someFn: function() {
  return this;
}
</code></pre>
<p>and generated fewer function allocations.</p>
<p>However with the introduction of ES6 modules and the modularization of Ember
in process (#176), keeping this feature would require to design an import path for it.</p>
<p>While doable, the transpiled output is actually bigger then defining the functions
inline, specially with the ES6 shorthand method syntax, and the perf difference
of saving a few function allocations is negligible.</p>
<p>The second downside of reusing the same instance in many places is that if for
some reason the VM deoptimizes that function, that deoptimization is spreaded
across all the usages of <code>Ember.K</code>.</p>
<p>Third, the chainable nature of <code>Ember.K</code> tends to surprise the users:</p>
<pre><code class="language-js">let derp = {
  foo: Ember.K,
  bar: Ember.K,
  baz: Ember.K
}

derp.foo().bar().baz(); // O_o
</code></pre>
<p>And lastly but more importantly for simplicity. Consider the following code:</p>
<pre><code class="language-js">export default Component.extend({
  onSubmit() {}
});
</code></pre>
<p>Any JS developer will understand that this is an empty function and will probably understand
that is a placeholder to provide your own function instead. However, JS developers that come
across <code>Ember.K</code> for the first time will se this:</p>
<pre><code class="language-js">export default Component.extend({
  onSubmit: Ember.K
});
</code></pre>
<p>and will think that it is some cryptic Ember magic that they have to learn.</p>
<a class="header" href="print.html#transition-path-3" id="transition-path-3"><h1>Transition Path</h1></a>
<p>The necessary first step is to make sure Ember, Ember Data and other pieces of the
ecosystem don't use <code>Ember.K</code> internally.</p>
<p>Phased approach:</p>
<ul>
<li>Deprecate <code>Ember.K</code>: Use the deprecation API to signal the deprecation, and deprecation guide entry.
Target version will be 3.0, as usual.</li>
<li>Add rule to ember-watson</li>
<li>Do not include export path in https://github.com/emberjs/rfcs/pull/176, but include it until 3.0 in the &quot;globals&quot; build.</li>
</ul>
<a class="header" href="print.html#how-we-teach-this-7" id="how-we-teach-this-7"><h1>How We Teach This</h1></a>
<p>Since it is a very low-level utility,
the amount of people that will have to update their code should be a limited set of developers, working mostly on addons.
This allows us to cover most use cases with the following strategy:</p>
<ul>
<li>Improve the current documentation to help developers finding the API for the first time in the future;</li>
<li>Provide an automated path forward through tooling such as <a href="https://github.com/abuiles/ember-watson">ember-watson</a>. (see Addendum 1)</li>
<li>Introduce the mandatory entry in the deprecations guide referencing the automated tooling.</li>
</ul>
<p>If this RFC is done as part of https://github.com/emberjs/rfcs/pull/176 as suggested,
it will be in the document or blog post announcing the final transition to modules.</p>
<a class="header" href="print.html#drawbacks-25" id="drawbacks-25"><h1>Drawbacks</h1></a>
<p>Although this utility is not very used, there is a chance that is used by some
addons and as a placeholder of a hook that is called a lot and would trigger
hundreds of deprecation warnings.</p>
<a class="header" href="print.html#alternatives-25" id="alternatives-25"><h1>Alternatives</h1></a>
<p>The feature could continue to exist.</p>
<a class="header" href="print.html#addenda-1" id="addenda-1"><h1>Addenda</h1></a>
<a class="header" href="print.html#addendum-1---codemod-to-automatically-remove-all-usages-of-emberk-on-any-project" id="addendum-1---codemod-to-automatically-remove-all-usages-of-emberk-on-any-project"><h2>Addendum 1 - Codemod to automatically remove all usages of <code>Ember.K</code> on any project.</h2></a>
<p>https://github.com/cibernox/ember-k-codemod</p>
<p>To use it you can install it globally and invoke the command on any app or addon.</p>
<p>The commands <strong>requires</strong> the user to decide the approach to replace occurenced of <code>Ember.K</code>. The
possible flags are <code>--empty</code> and <code>--return-this</code>.</p>
<ul>
<li><code>--empty</code> replaces <code>Ember.K</code> with an empty function. This leads to the most idiomatic and
intention-revealing code, but does not allow chaining, like the original <code>Ember.K</code> did.
Despite of that, chaining <code>Ember.K</code> was such an uncommon patterns that we thing virtually
everybody can use this option.</li>
<li><code>--return-this</code> replaces <code>Ember.K</code> with a function that just returns <code>this</code>. This allows chaining
like the original one.</li>
</ul>
<p>Example usage:</p>
<pre><code>npm install -g ember-k-codemod &amp;&amp; ember-k-codemod --empty
</code></pre>
<p>Versions of <a href="https://github.com/abuiles/ember-watson">ember-watson</a> starting in <code>0.8.5</code> wrap this
codemod so you can achieve the same transformation with it:</p>
<pre><code>ember-watson remove-ember-k --empty

// or if installed as an addon

ember watson:remove-ember-k --empty
</code></pre>
<a class="header" href="print.html#addendum-2---emberk-usage-across-published-addons" id="addendum-2---emberk-usage-across-published-addons"><h2>Addendum 2 - <code>Ember.K</code> usage across published addons</h2></a>
<pre><code>ae-select/addon/components/ae-select.js:  action: Ember.K, // action to fire on change
antd-ember/addon/components/io-searchable-select/searchable-select.js:    'on-change': Ember.K,
antd-ember/addon/components/io-searchable-select/searchable-select.js:    'on-add': Ember.K,
antd-ember/addon/components/io-searchable-select/searchable-select.js:    'on-search': Ember.K,
antd-ember/addon/components/io-searchable-select/searchable-select.js:        return this.get('on-add') !== Ember.K;
antd-ember/addon/components/io-searchable-select/searchable-select.js:        return this.get('on-search') === Ember.K;
ella-list-view/addon/views/list-item.coffee:  prepareContent: Ember.K
ella-list-view/addon/views/list-item.coffee:  teardownContent: Ember.K
ella-list-view/addon/views/list.coffee:  arrayWillChange: Ember.K
ella-list-view/addon/views/list.coffee:  didScrollToTop: Ember.K
ella-list-view/addon/views/list.coffee:  didScrollToBottom: Ember.K
ella-list-view/addon/views/list.coffee:  visibleItemsDidChange: Ember.K
ella-sparse-array-controller/addon/controllers/sparse-array.coffee:    if @didRequestRange isnt Ember.K
ella-sparse-array-controller/addon/controllers/sparse-array.coffee:    unless (@didRequestLength is Ember.K) or get(@, 'isRequestingLength')
ella-sparse-array-controller/addon/controllers/sparse-array.coffee:  sparseContentWillChange: Ember.K
ella-sparse-array-controller/addon/controllers/sparse-array.coffee:  sparseContentDidChange: Ember.K
ella-sparse-array-controller/addon/controllers/sparse-array.coffee:  didReplaceSparseArrayItem: Ember.K
ella-sparse-array-controller/addon/controllers/sparse-array.coffee:  didRequestIndex: Ember.K
ella-sparse-array-controller/addon/controllers/sparse-array.coffee:  didRequestRange: Ember.K
ella-sparse-array-controller/addon/controllers/sparse-array.coffee:  didRequestLength: Ember.K
elvis-network/addon/components/visjs-child.js:  didCreateLayer: Ember.K,
elvis-network/addon/components/visjs-child.js:  willDestroyLayer: Ember.K,
ember-animate/ember-animate.js:        willAnimateIn : Ember.K,
ember-animate/ember-animate.js:        willAnimateOut : Ember.K,
ember-animate/ember-animate.js:        didAnimateIn : Ember.K,
ember-animate/ember-animate.js:        didAnimateOut : Ember.K,
ember-animate/ember-animate.js:        _currentViewWillChange : Ember.K,
ember-aupac-typeahead/addon/components/aupac-typeahead.js:  action: Ember.K, //@public
ember-aupac-typeahead/addon/components/aupac-typeahead.js:  source : Ember.K, //@public
ember-autoresize/addon/mixins/autoresize.js:let trim = Ember.K;
ember-bootstrap/addon/components/bs-form-element.js:  setupValidations: Ember.K,
ember-bootstrap/addon/components/bs-select.js:  action: Ember.K, // action to fire on change
ember-bootstrap-components/addon/components/bs-select.js:  action: Ember.K, // action to fire on change
ember-bugsnag/app/instance-initializers/bugsnag.js:  let originalOnError = Ember.onerror || Ember.K;
ember-charts/addon/components/bubble-chart.js:      return Ember.K;
ember-charts/addon/components/bubble-chart.js:      return Ember.K;
ember-charts/addon/components/horizontal-bar-chart.js:      return Ember.K;
ember-charts/addon/components/horizontal-bar-chart.js:      return Ember.K;
ember-charts/addon/components/pie-chart.js:      return Ember.K;
ember-charts/addon/components/pie-chart.js:      return Ember.K;
ember-charts/addon/components/scatter-chart.js:      return Ember.K;
ember-charts/addon/components/scatter-chart.js:      return Ember.K;
ember-charts/addon/components/stacked-vertical-bar-chart.js:      return Ember.K;
ember-charts/addon/components/stacked-vertical-bar-chart.js:      return Ember.K;
ember-charts/addon/components/time-series-chart.js:      return Ember.K;
ember-charts/addon/components/time-series-chart.js:      return Ember.K;
ember-charts/addon/components/vertical-bar-chart.js:      return Ember.K;
ember-charts/addon/components/vertical-bar-chart.js:      return Ember.K;
ember-charts/addon/mixins/legend.js:      return Ember.K;
ember-charts/addon/mixins/legend.js:      return Ember.K;
ember-charts/addon/mixins/resize-handler.js:  onResizeStart: Ember.K,
ember-charts/addon/mixins/resize-handler.js:  onResizeEnd: Ember.K,
ember-charts/addon/mixins/resize-handler.js:  onResize: Ember.K,
ember-charts/dependencies/ember-addepar-mixins/resize_handler.js:  onResizeStart: Ember.K,
ember-charts/dependencies/ember-addepar-mixins/resize_handler.js:  onResizeEnd: Ember.K,
ember-charts/dependencies/ember-addepar-mixins/resize_handler.js:  onResize: Ember.K,
ember-cli-adapter-pattern/tests/dummy/app/starships/starship.js:  _makeItSo: Ember.K
ember-cli-airbrake/README.md:In all cases, an `airbrake` service will be exposed. If airbrake isn't configured the airbrake service uses the Ember.K &quot;no-op&quot; function for its methods. This facilitates the usage of the airbrake service without having to add environment-checking code in your app.
ember-cli-airbrake/README.md:exist, but all its methods will be no-ops (`Ember.K`). This way your tests will still run happily even
ember-cli-airbrake/app/instance-initializers/ember-cli-airbrake.js:  let originalOnError = Ember.onerror || Ember.K;
ember-cli-analytics/addon/integrations/base.js:  trackPage: Ember.K,
ember-cli-analytics/addon/integrations/base.js:  trackEvent: Ember.K,
ember-cli-analytics/addon/integrations/base.js:  trackConversion: Ember.K,
ember-cli-analytics/addon/integrations/base.js:  identify: Ember.K,
ember-cli-analytics/addon/integrations/base.js:  alias: Ember.K
ember-cli-analytics/tests/unit/mixins/trackable-test.js:  const analytics = { trackPage: Ember.K };
ember-cli-aptible-shared/tests/unit/utils/changeset-test.js:      initialValue: Ember.K
ember-cli-aptible-shared/tests/unit/utils/changeset-test.js:      key: Ember.K
ember-cli-bugsnag/app/instance-initializers/bugsnag.js:      const originalDidTransition = router.didTransition || Ember.K;
ember-cli-coreweb/app/initializers/ember-coreweb.js:  initialize: Ember.K
ember-cli-dialog/packages/ember-dialog/lib/ember-initializer.js:// var K = Ember.K;
ember-cli-dimple/addon/components/dimple-chart/component.coffee:  customizeChart: Ember.K
ember-cli-dimple/addon/components/dimple-chart/component.js:  customizeChart: Ember.K,
ember-cli-dimple/addon/mixins/resize.js:  onResizeStart: Ember.K,
ember-cli-dimple/addon/mixins/resize.js:  onResizeEnd: Ember.K,
ember-cli-dimple/addon/mixins/resize.js:  onResize: Ember.K,
ember-cli-dynamic-forms/addon/components/dynamic-form.js:  renderSchema: Ember.K,
ember-cli-erraroo/addon/erraroo.js:    const oldEmberOnerror = Ember.onerror || Ember.K;
ember-cli-fullpagejs-view/addon/initializers/remove-fullpage.js:  initialize: Ember.K
ember-cli-infinite-scroll/addon/mixins/infinite-scroll.js:  beforeInfiniteQuery: Ember.K,
ember-cli-ion-rangeslider/addon/ember-ion-rangeslider.js:          onChange: Ember.K,
ember-cli-ion-rangeslider/addon/ember-ion-rangeslider.js:      options.onFinish = Ember.K;
ember-cli-jsoneditor/addon/components/json-editor.js:  onChange: Ember.K,
ember-cli-jsoneditor/addon/components/json-editor.js:  onError: Ember.K,
ember-cli-jsoneditor/addon/components/json-editor.js:  onModeChange: Ember.K,
ember-cli-jsoneditor/addon/components/json-editor.js:  onEditable: Ember.K,
ember-cli-maskedinput/addon/components/masked-input.js:  'on-change': Ember.K,
ember-cli-nvd3/addon/components/nvd3-chart.js:  beforeSetup: Ember.K,
ember-cli-nvd3/addon/components/nvd3-chart.js:  afterSetup: Ember.K,
ember-cli-nvd3-multichart/addon/components/nvd3-multichart.js:  chartContextFn: Ember.K,
ember-cli-remote-inspector/tests/acceptance.js:    this.ember.kill('SIGINT');
ember-cli-remote-inspector/tests/acceptance.js:    this.ember.kill('SIGINT');
ember-cli-selectize/addon/components/ember-selectize.js:  _groupedContentArrayWillChange: Ember.K,
ember-cli-visjs/addon/components/visjs-child.js:  didCreateLayer: Ember.K,
ember-cli-visjs/addon/components/visjs-child.js:  willDestroyLayer: Ember.K,
ember-collection/addon/components/ember-collection.js:          willChange: Ember.K,
ember-collection/addon/components/ember-collection.js:          willChange: Ember.K,
ember-concurrency/addon/utils.js:      let disposer = typeof maybeDisposer === 'function' ? maybeDisposer : Ember.K;
ember-confirm-dialog/addon/components/confirm-dialog.js:  confirmAction: Ember.K,//optional action executed when user confirms the dialog
ember-confirm-dialog/addon/components/confirm-dialog.js:  cancelAction: Ember.K,//optional action executed when user cancels confirmation dialog
ember-cookie-consent-cnil/app/mixins/click-else-where.js:  onOutsideClick: Ember.K,
ember-data-model-fragments/addon/states.js:  propertyWasReset: Ember.K,
ember-data-model-fragments/addon/states.js:  becomeDirty: Ember.K,
ember-data-model-fragments/addon/states.js:  rolledBack: Ember.K,
ember-data-model-fragments/addon/states.js:      pushedData: Ember.K,
ember-data-model-fragments/addon/states.js:      didCommit: Ember.K,
ember-data-sails/addon/initializers/ember-data-sails.js:      methods[level] = Ember.K;
ember-dev-fixtures/private/utils/dev-fixtures/module.js:      define(this.get('fullPath'), ['exports'], Ember.K);
ember-dp-map/addon/components/_dp-base-map-element.js:  didLoadMap: Ember.K
ember-drag-drop/addon/mixins/droppable.js:  acceptDrop: Ember.K,
ember-drag-drop/addon/mixins/droppable.js:  handleDragOver: Ember.K,
ember-drag-drop/addon/mixins/droppable.js:  handleDragOut: Ember.K,
ember-form-object/tests/unit/forms/model-form-test.js:  }).catch(Ember.K);
ember-froala/addon/components/froala-editor.js:        var buttons = this.get('customButtons') || Ember.K;
ember-google-charts/tests/integration/components/options-change-test.js:    this.on('chartDidRender', Ember.K);
ember-img-cache/app/initializers/ember-img-cache.js:  initialize: Ember.K
ember-img-manager/app/utils/img-manager/img-clone-holder.js:  this.handler = Ember.K;
ember-img-manager/app/utils/img-manager/img-clone-holder.js:      this.handler = Ember.K;
ember-img-manager/app/utils/img-manager/img-clone-holder.js:   * @param {Function} [handler=Ember.K]
ember-img-manager/app/utils/img-manager/img-clone-holder.js:    this.handler = handler || Ember.K;
ember-infinity/tests/unit/mixins/route-test.js:      pushObjects: Ember.K,
ember-infinity/tests/unit/mixins/route-test.js:        pushObjects: Ember.K,
ember-infinity/tests/unit/mixins/route-test.js:        pushObjects: Ember.K,
ember-jsonapi-resources/addon/adapters/application.js:    let cleanup = Ember.K;
ember-jsonapi-resources/tests/unit/adapters/application-test.js:  adapter.serializer = {deserialize: sandbox.spy(), deserializeIncluded: Ember.K};
ember-jsonapi-resources/tests/unit/adapters/application-test.js:  adapter.serializer = { deserialize: sandbox.spy(), deserializeIncluded: Ember.K };
ember-jsonapi-resources/tests/unit/mixins/fetch-test.js:  this.subject.serializer = { deserialize: function(res) { return res.data; }, deserializeIncluded: Ember.K };
ember-jsonapi-resources/tests/unit/mixins/resource-operations-test.js:        trigger: Ember.K
ember-jsonapi-resources/tests/unit/mixins/resource-operations-test.js:      guns: {kind: 'hasMany', mapBy: Ember.K }, // hasMany('guns')
ember-jsonapi-resources/tests/unit/mixins/resource-operations-test.js:      horse: {kind: 'hasOne', get: Ember.K } // hasOne('horse')
ember-jsonapi-resources-form/addon/components/resource-form.js:    if (!action) { return Ember.K; /* fail silently if no action */ }
ember-jsonapi-resources-list/addon/mixins/controllers/jsonapi-list.js:    filtering: Ember.K,
ember-key-responder/app/key-responder.js:    comments for Ember.KeyResponderStack above for more insight.
ember-list-card/addon/components/list-card/header-dropdown-item.js:   onSelect: Ember.K,
ember-list-card/addon/components/list-card/header-dropdown-item.js:   onDeselect: Ember.K,
ember-list-card/addon/components/list-card/header-dropdown.js:  onItemSelect: Ember.K,
ember-list-card/addon/components/list-card/header.js:  onQueryOptionSelect: Ember.K,
ember-material-design/addon/mixins/events.js:    start: Ember.K,
ember-material-design/addon/mixins/events.js:    move: Ember.K,
ember-material-design/addon/mixins/events.js:    end: Ember.K
ember-material-design/addon/mixins/gesture-events.js:    onStart: Ember.K,
ember-material-design/addon/mixins/gesture-events.js:    onMove: Ember.K,
ember-material-design/addon/mixins/gesture-events.js:    onEnd: Ember.K,
ember-material-design/addon/mixins/gesture-events.js:    onCancel: Ember.K,
ember-material-design/app/services/ripple.js:            return Ember.K;
ember-metrics/tests/dummy/app/metrics-adapters/local-dummy-adapter.js:  init: Ember.K,
ember-metrics/tests/dummy/app/metrics-adapters/local-dummy-adapter.js:  willDestroy: Ember.K
ember-mixpanel/addon/mixpanel.js:          return Ember.K;
ember-mixpanel/addon/mixpanel.js:      return Ember.K;
ember-notifyme/addon/objects/notification-message.js:  onClick: Ember.K,
ember-notifyme/addon/objects/notification-message.js:  onClose: Ember.K,
ember-notifyme/addon/services/notification-service.js:           onClick: options.onClick || Ember.K,
ember-notifyme/addon/services/notification-service.js:           onClose: options.onClose || Ember.K,
ember-notifyme/addon/services/notification-service.js:           onCloseTimeout: options.onCloseTimeout || Ember.K,
ember-off-canvas-components/addon/initializers/custom-events.js:  initialize: Ember.K
ember-pardon/addon/mixins/ember-pardon.js:	beforeDestroy: Ember.K,
ember-phoenix-channel/tests/integration/components/socket-message-log-test.js:  on: Ember.K
ember-pikaday/addon/components/pikaday-inputless.js:  onPikadayOpen: Ember.K,
ember-pikaday/addon/components/pikaday-inputless.js:  onPikadayClose: Ember.K,
ember-pikaday/addon/mixins/pikaday.js:  onOpen: Ember.K,
ember-pikaday/addon/mixins/pikaday.js:  onClose: Ember.K,
ember-pikaday/addon/mixins/pikaday.js:  onSelection: Ember.K,
ember-pikaday/addon/mixins/pikaday.js:  onDraw: Ember.K,
ember-pikaday-with-time/addon/components/pikaday-input.js:  onPikadayOpen: Ember.K,
ember-pikaday-with-time/addon/components/pikaday-input.js:  onPikadayRedraw: Ember.K,
ember-processes/addon/utils.js:      let disposer = typeof maybeDisposer === 'function' ? maybeDisposer : Ember.K;
ember-render-stack/addon/route-mixin.js:  renderStack: Ember.K,
ember-restless/dist/ember-restless.js:  var noop = Ember.K;
ember-restless/dist/ember-restless.js:    _onPropertyChange: Ember.K
ember-restless/src/model/read-only-model.js:  _onPropertyChange: Ember.K
ember-restless/src/model/state.js:var noop = Ember.K;
ember-reveal-js/addon/components/reveal-presentation/component.js:      before: Ember.K,
ember-rl-dropdown/addon/mixins/rl-dropdown-component.js:  onOpen: Ember.K,
ember-rl-dropdown/addon/mixins/rl-dropdown-component.js:  onClose: Ember.K,
ember-searchable-select/addon/components/searchable-select.js:  'on-change': Ember.K,
ember-searchable-select/addon/components/searchable-select.js:  'on-add': Ember.K,
ember-searchable-select/addon/components/searchable-select.js:  'on-search': Ember.K,
ember-searchable-select/addon/components/searchable-select.js:  'on-close': Ember.K,
ember-searchable-select/addon/components/searchable-select.js:    return this.get('on-add') !== Ember.K;
ember-searchable-select/addon/components/searchable-select.js:    return this.get('on-search') === Ember.K;
ember-searchable-select/tests/dummy/app/pods/components/options-table/template.hbs:    on-change                 | Specify your own named action to trigger when the selection changes. eg. &lt;code&gt;(action &quot;update&quot;)&lt;/code&gt; &lt;br&gt; For single selection (default behaviour), the selected object is sent as an argument. For multiple selections, an array of options is sent. | Ember action  | Ember.K
ember-searchable-select/tests/dummy/app/pods/components/options-table/template.hbs:    on-add                    | Allow unfound items to be added to the content array by specifying your own named action. eg. `(action &quot;addNew&quot;)` The new item name is sent as an argument. You must handle adding the item to the content array and selecting the new item outside the component. | Ember action  | Ember.K
ember-searchable-select/tests/dummy/app/pods/components/options-table/template.hbs:    provided.     | Ember action    | Ember.K
ember-searchable-select/tests/dummy/app/pods/components/options-table/template.hbs:    on-close                  | Specify your own named action to trigger when the menu closes. Useful hook for clearing out content that was previously passed in with AJAX. | Ember action | Ember.K
ember-select-list/addon/components/select-list.js:  action: Ember.K, // action to fire on change
ember-smart-banner/addon/components/smart-banner.js:      const visitFn = Ember.getWithDefault(this, 'attrs.onvisit', Ember.K);
ember-smart-banner/addon/components/smart-banner.js:      const closeFn = Ember.getWithDefault(this, 'attrs.onclose', Ember.K);
ember-sqlite-adapter/addon/migration.js:  run: Ember.K,
ember-stripe-service/addon/services/stripe.js:      this.card[name] = Ember.K;
ember-table/addon/components/ember-table.js:    addColumn: Ember.K,
ember-table/addon/components/ember-table.js:    sortByColumn: Ember.K
ember-table/addon/mixins/mouse-wheel-handler.js:  onMouseWheel: Ember.K,
ember-table/addon/mixins/resize-handler.js:  onResizeStart: Ember.K,
ember-table/addon/mixins/resize-handler.js:  onResizeEnd: Ember.K,
ember-table/addon/mixins/resize-handler.js:  onResize: Ember.K,
ember-table/addon/mixins/scroll-handler.js:  onScroll: Ember.K,
ember-table/addon/mixins/touch-move-handler.js:  onTouchMove: Ember.K,
ember-table/addon/models/column-definition.js:  setCellContent: Ember.K,
ember-table/addon/views/lazy-item.js:  prepareContent: Ember.K,
ember-table/addon/views/lazy-item.js:  teardownContent: Ember.K,
ember-ted-select/README.md:      &lt;td&gt;&lt;code&gt;Ember.K&lt;/code&gt; (noop)&lt;/td&gt;
ember-ted-select/tests/dummy/app/pods/application/template.hbs:        &lt;td&gt;&lt;code&gt;Ember.K&lt;/code&gt; (noop)&lt;/td&gt;
ember-theater/addon/ember-theater/director/directions/sound.js:  fadeTo(volume, duration, callback = Ember.K) {
ember-to-string/tests/unit/helpers/to-string-test.js:    lookup: Ember.K
ember-ui-components/addon/mixins/click-outside.js:  handleClickOutside: Ember.K,
ember-unauthorized/tests/unit/mixins/access-test.js:  subject.set('authorize', Ember.K);
ember-unauthorized/tests/unit/mixins/access-test.js:  subject.set('authorize', Ember.K);
ember-unauthorized/tests/unit/mixins/route-access-test.js:      transitionTo: Ember.K
ember-watson/tests/fixtures/resource-router-mapping/new-complex-ember-cli-sample.js:    }, Ember.K);
ember-watson/tests/fixtures/resource-router-mapping/old-complex-ember-cli-sample.js:    this.resource('dashboard', Ember.K);
emberx-select/addon/components/x-select.js:  &quot;on-blur&quot;: Ember.K,
emberx-select/addon/components/x-select.js:  &quot;on-click&quot;: Ember.K,
emberx-select/addon/components/x-select.js:  &quot;on-change&quot;: Ember.K,
emberx-select/addon/components/x-select.js:  &quot;on-focus-out&quot;: Ember.K,
fireplace/addon/collections/indexed.js:      then(Ember.K.bind(this));
fireplace/addon/collections/object.js:    const promise = this.listenToFirebase().then(Ember.K.bind(this));
justa-table/addon/components/table-vertical-collection.js:  'on-row-click': Ember.K
list-view/addon/list-view-mixin.js:  _scrollTo: Ember.K,
list-view/addon/list-view-mixin.js:  arrayWillChange: Ember.K,
list-view/addon/reusable-list-item-view.js:  prepareForReuse: Ember.K,
mantel/addon/fireplace/collections/indexed.js:      then(Ember.K.bind(this));
mantel/addon/fireplace/collections/object.js:    var promise = this.listenToFirebase().then(Ember.K.bind(this));
plaid/addon/mixins/dimensions.js:  didMeasureDimensions: Ember.K,
plaid/addon/mixins/global-resize.js:  didResize: Ember.K
spree-ember-paypal-express/addon/services/paypal-express.js:  spree: Ember.K,
torii/addon/services/torii-session.js:  setUnknownProperty: Ember.K,
torii/tests/unit/redirect-handler-test.js:    close: Ember.K
torii/tests/unit/services/popup-test.js:    focus: Ember.K,
torii/tests/unit/services/popup-test.js:    close: Ember.K
</code></pre>
<a class="header" href="print.html#addendum-3---emberk-usage-via-destructuring-across-published-addons" id="addendum-3---emberk-usage-via-destructuring-across-published-addons"><h2>Addendum 3 - <code>Ember.K</code> usage via destructuring across published addons</h2></a>
<pre><code>CogAuth/tests/helpers/flash-message.js:const { K } = Ember;
ember-annotative-models/addon/utils/action.coffee:{K, isBlank, A} = Ember
ember-annotative-models/tests/unit/utils/action-test.coffee:{K} = Ember
ember-cli-airbrake/addon/utils/get-client.js:const { K } = Ember;
ember-cli-flash/blueprints/ember-cli-flash/files/tests/helpers/flash-message.js:const { K } = Ember;
ember-cli-mapkit/addon/components/ui-abstract-map.js:const {isEmpty, computed, on, K, run} = Ember;
ember-cli-pixijs/addon/components/pixi-canvas.js:const { Component, computed, K } = Ember;
ember-click-outside/addon/mixins/click-outside.js:const { computed, K } = Ember;
ember-composable-helpers/addon/-private/create-needle-haystack-helper.js:const { K, isEmpty } = Ember;
ember-composable-helpers/tests/unit/helpers/pipe-test.js:const { RSVP: { resolve, reject }, K } = Ember;
ember-composable-helpers/tests/unit/helpers/queue-test.js:const { RSVP: { resolve, reject }, K } = Ember;
ember-d3-helpers/tests/unit/helpers/d3-line-test.js:const { K } = Ember;
ember-form-object/addon/forms/model-form.js:const { ObjectProxy, computed, computed: { readOnly }, assert, Logger, run, A: createArray, K: noop, String: { camelize } } = Ember;
ember-form-tool/addon/mixins/drag-drop.coffee:{K, Mixin, computed: {equal}} = Ember
ember-functional-helpers/addon/-private/create-needle-haystack-helper.js:const { K, isEmpty } = Ember;
ember-functional-helpers/tests/unit/helpers/pipe-test.js:const { RSVP: { resolve, reject }, K } = Ember;
ember-functional-helpers/tests/unit/helpers/queue-test.js:const { RSVP: { resolve, reject }, K } = Ember;
ember-imdt-magic-crud/tests/helpers/flash-message.js:const { K } = Ember;
ember-keyword-complete/addon/components/keyword-complete.js:const {observer, computed, run, assert, K, $} = Ember;
ember-leaflet/addon/components/base-layer.js:const { assert, computed, Component, run, K, A, String: { classify } } = Ember;
ember-light-table/tests/helpers/responsive.js:const { K, getOwner } = Ember;
ember-metrics/tests/unit/services/metrics-test.js:const { get, set, K } = Ember;
ember-paper/addon/components/paper-autocomplete.js:const { assert, computed, inject, isNone, defineProperty, K: emberNop } = Ember;
ember-paper/addon/mixins/events-mixin.js:const { Mixin, K } = Ember;
ember-redux/app/services/redux.js:const { assert, isArray, K } = Ember;
ember-responsive/blueprints/ember-responsive/files/tests/helpers/responsive.js:const { K, getOwner } = Ember;
ember-select-box/addon/mixins/select-box/select-box/inputtable.js:const { K } = Ember;
ember-shepherd/addon/services/tour.js:const { Evented, K, Service, isPresent, run, $, isEmpty, observer } = Ember;
ember-simple-auth/addon/session-stores/cookie.js:const { RSVP, computed, run: { next, cancel, later, scheduleOnce }, isEmpty, typeOf, testing, isBlank, isPresent, K, A } = Ember;
ember-simple-auth/tests/unit/internal-session-test.js:const { RSVP, K, run: { next } } = Ember;
ember-simple-auth/tests/unit/session-stores/shared/store-behavior.js:const { run: { next }, K } = Ember;
ember-simple-auth-chrome-app/tests/unit/session-stores/shared/store-behavior.js:const { K, run: { next } } = Ember;
ember-sinon-qunit/tests/helpers/assert-sinon-in-test-context.js:const { K: EmptyFunc, typeOf } = Ember;
ember-user-activity/tests/unit/services/user-activity-test.js:const { A: emberArray, K: noOp, typeOf } = Ember;
ui-bootstrap/tests/helpers/flash-message.js:const { K } = Ember;
yes-or-no/tests/helpers/responsive.js:const { K, getOwner } = Ember;
</code></pre>
<ul>
<li>Start Date: 2016-11-22</li>
<li>RFC PR: (leave this empty)</li>
<li>Ember Issue: (leave this empty)</li>
</ul>
<a class="header" href="print.html#summary-26" id="summary-26"><h1>Summary</h1></a>
<p>The goal of this RFC is to remove the <code>data-adapter</code>, <code>injectStore</code>,
<code>transforms</code>, and <code>store</code> Ember application initializers that Ember Data injects
into apps.  The <code>ember-data</code> initializer will not be changed and any code
that previously depended on the ordering of these initializers (via
the <code>before</code> or <code>after</code> properties on an initalizer) can be
changed to use the <code>ember-data</code> initializers for ordering.</p>
<a class="header" href="print.html#motivation-27" id="motivation-27"><h1>Motivation</h1></a>
<p>The initializers <code>data-adapter</code>, <code>injectStore</code>, <code>transforms</code>, and
<code>store</code> have not been used by Ember Data since
<a href="https://github.com/emberjs/data/commit/d25e23f622a3677b8372db535b2ab824ad306a16">Apr 8, 2014</a>. However,
they are still injected into every Ember app that depends on Ember
Data because existing apps may depend on these initializers
for ordering their own initializers to run before or after Ember
Data's setup code.</p>
<p>Removing these initializers will help reduce the amount of code Ember
Data needs to support.</p>
<p>Since these initializers are noop functions that run after the
<code>ember-data</code> initializer, any initializers that depends on one of the
deprecated initializers listed in this rfc can easly be replaced by
depending on the <code>ember-data</code> initializer instead.</p>
<a class="header" href="print.html#detailed-design-23" id="detailed-design-23"><h1>Detailed design</h1></a>
<p>Ember Data's instance initializer will start checking for any
initializers whose <code>before</code> or <code>after</code> properties depend on one of
these deprecated initalizer. If it finds an initalizer that references
one of the deprecated initalizers, Ember Data will then log a
deprecation message that states the name of the offending initalizers
and suggest changing the <code>before</code> or <code>after</code> property (the deprecation
message will refer to the correct property dynamically) to depend on
Ember Data instead.</p>
<p>This deprecation message will continue to appear until Ember Data
3.0.0 when these initalizers and the deprecation code will be finally
removed.</p>
<a class="header" href="print.html#how-we-teach-this-8" id="how-we-teach-this-8"><h1>How We Teach This</h1></a>
<p>This change should have no impact on how we teach Ember or Ember
Data. The initalizers that will be removed have been unused for a long
time and are not mentioned anywhere in today's guides or API docs.</p>
<p>Users who need to run initalizer code before or after Ember Data
injects the store into routes should be taught to use <code>before: 'ember-data'</code>, or <code>after: 'ember-data'</code> on their initializers.</p>
<a class="header" href="print.html#drawbacks-26" id="drawbacks-26"><h1>Drawbacks</h1></a>
<ul>
<li>This change will require users who depend on these deprecated initalizers to update their code.</li>
</ul>
<a class="header" href="print.html#alternatives-26" id="alternatives-26"><h1>Alternatives</h1></a>
<ul>
<li>We could leave the noop initalizers in Ember Data and continue to support them in Ember Data 3.0.0 and beyond.</li>
</ul>
<a class="header" href="print.html#unresolved-questions-22" id="unresolved-questions-22"><h1>Unresolved questions</h1></a>
<p>None</p>
<ul>
<li>Start Date: 2016/12/05</li>
<li>RFC PR: https://github.com/emberjs/rfcs/pull/186</li>
<li>Ember Issue: (leave this empty)</li>
</ul>
<a class="header" href="print.html#summary-27" id="summary-27"><h1>Summary</h1></a>
<p>Track unique history location states</p>
<a class="header" href="print.html#motivation-28" id="motivation-28"><h1>Motivation</h1></a>
<p>The path alone does not provide enough information. For example, if you
visit page A, scroll down, then click on a link to page B, then click on
a link back to page A. Your actual browser history stack is [A, B, A].
Each of those nodes in the history should have their own unique scroll
position. In order to record this position we need a UUID
for each node in the history.</p>
<p>This API will allow other libraries to reflect upon each location to
determine unique state. For example,
<a href="https://github.com/dollarshaveclub/ember-router-scroll">ember-router-scroll</a>
is making use of a <a href="https://github.com/dollarshaveclub/ember-router-scroll/blob/master/addon/locations/router-scroll.js">modified <code>Ember.HistoryLocation</code> object to get this
behavior</a>.</p>
<p>Tracking unique state is required when setting the scroll position
properly based upon where you are in the history stack, as described in
<a href="print.html#motivation">Motivation</a></p>
<a class="header" href="print.html#detailed-design-24" id="detailed-design-24"><h1>Detailed design</h1></a>
<p>Code: <a href="https://github.com/emberjs/ember.js/pull/14011">PR#14011</a></p>
<p>We simply unique identifier (UUID) so we can track uniqueness on two
dimensions. Both <code>path</code> and the generated <code>uuid</code>. A simple UUID
generator such as
https://gist.github.com/lukemelia/9daf074b1b2dfebc0bd87552d0f6a537
should suffice.</p>
<a class="header" href="print.html#how-we-teach-this-9" id="how-we-teach-this-9"><h1>How We Teach This</h1></a>
<p>We could describe what meta data is generated for each location in the
history stack. For example, it could look like:</p>
<pre><code class="language-js">// visit page A

[
  { path: '/', uuid: 1 }
]

// visit page B

[
  { path: '/about', uuid: 2 },
  { path: '/', uuid: 1 }
]

// visit page A

[
  { path: '/', uuid: 3 },
  { path: '/about', uuid: 2 },
  { path: '/', uuid: 1 }
]

// click back button

[
  { path: '/about', uuid: 2 },
  { path: '/', uuid: 1 }
]
</code></pre>
<a class="header" href="print.html#drawbacks-27" id="drawbacks-27"><h1>Drawbacks</h1></a>
<ul>
<li>The property access is writable</li>
</ul>
<a class="header" href="print.html#alternatives-27" id="alternatives-27"><h1>Alternatives</h1></a>
<p>The purpose for this behavior is to enable scroll position libraries.
There are two other solutions in the wild. One is in the guides that
suggests resetting the scroll position to <code>(0, 0)</code> on each new route
entry. The other is
<a href="https://github.com/ef4/memory-scroll">ember-memory-scroll</a> which I
believe is better suited for tracking scroll positions for components
rather than the current page.</p>
<p>However, in both cases neither solution provides the experience that
users have come to expect from server-rendered pages. The browser tracks
scroll position and restores it when you revisit the page in the history
stack. The scroll position is unique even if you have multiple instances
of the same page in the stack.</p>
<a class="header" href="print.html#unresolved-questions-23" id="unresolved-questions-23"><h1>Unresolved questions</h1></a>
<p>None at this time.</p>
<ul>
<li>Start Date: 2016-12-14</li>
<li>RFC PR: <a href="https://github.com/emberjs/rfcs/pull/191">#191</a></li>
<li>Ember Issue: <a href="https://github.com/emberjs/ember.js/pull/14711">#14711</a></li>
</ul>
<a class="header" href="print.html#summary-28" id="summary-28"><h1>Summary</h1></a>
<p>We would like to deprecate and remove the <strong>arguments</strong> passed to the <code>didInitAttrs</code>, <code>didReceiveAttrs</code> and <code>didUpdateAttrs</code> component lifecycle hooks. These arguments are currently undocumented on purpose and considered a private API, imposes an unnecessary performance hit on <em>all</em> components whether they are used or not, and can be easily replicated by the users in cases where they are needed.</p>
<a class="header" href="print.html#motivation-29" id="motivation-29"><h1>Motivation</h1></a>
<p>In the road leading up to Ember.js 2.0, <a href="http://emberjs.com/blog/2015/06/12/ember-1-13-0-released.html#toc_component-lifecycle-hooks">new lifecycle hooks</a> were introduced to components in order to help users shift to a new mental model, dubbed Data Down Actions Up. The hooks were introduced by name, and their semantics explained, but there were no mentions of possible arguments received by them.</p>
<p>This lack of documentation for lifecycle hook arguments was deliberate. The hooks were introduced as an experiment with an eye to the then-upcoming angle bracket components, so the arguments to the hooks were considered private by the framework maintainers, as their design was still ongoing.</p>
<p>However, references to the lifecycle hook arguments started appearing in community resources. Users started betting on these arguments as the way forward, which in conjunction with the lack of an RFC process and clear messaging from the Ember.js maintainers lead to confusion.</p>
<p>This left the core team in a difficult position. Despite no longer endorsing lifecycle hook arguments, trying to communicate such could have the reverse effect by pointing a spotlight at them. The purpose of this RFC is then to clarify that lifecycle hook arguments have no future in the framework, and you should update your code to not make use of them.</p>
<p>The reason to officially deprecate lifecycle hook arguments is not only about messaging, but also because providing these arguments imposes an unnecessary performance penalty to every component in your application even if the arguments are not used.</p>
<p>To provide the arguments to the lifecycle hooks, Ember.js has to eagerly &quot;reify&quot; and save-off any passed-in attributes to allow diffing and construct several wrapper objects. In the few occasions where this logic is actually necessary, developers should be able to use programmatic patterns familiar to them and manually track changes as needed, as exemplified in the Transition Path section below.</p>
<a class="header" href="print.html#transition-path-4" id="transition-path-4"><h1>Transition Path</h1></a>
<p>The transition path followed will be the standard one, which encompasses using the deprecation API to deprecate the feature and the related deprecation guide. While the lifecycle hooks share a deprecation identifier, they will be addressed in turn.</p>
<a class="header" href="print.html#didinitattrs" id="didinitattrs"><h3><code>didInitAttrs</code></h3></a>
<p>Since this lifecycle hook is <a href="http://emberjs.com/deprecations/v2.x/#toc_ember-component-didinitattrs">already deprecated</a>, we suggest taking this chance to address two deprecations at the same time. Imagine you have a component that stores a timestamp when it's initialized for later comparison.</p>
<p>Before:</p>
<pre><code class="language-javascript">Ember.Component.extend({
  didInitAttrs({ attrs }) {
    this.set('initialTimestamp', attrs.timestamp);
  }
});
</code></pre>
<p>After:</p>
<pre><code class="language-javascript">Ember.Component.extend({
  init() {
    this._super(...arguments);

    this.set('initialTimestamp', this.get('timestamp'));
  }
});
</code></pre>
<a class="header" href="print.html#didreceiveattrs" id="didreceiveattrs"><h3><code>didReceiveAttrs</code></h3></a>
<p>Let's say you want to animate a map widget from the old coordinates to the new coordinates.</p>
<p>Before:</p>
<pre><code class="language-javascript">Ember.Component.extend({
  didReceiveAttrs({ oldAttrs, newAttrs }) {
    if (oldAttrs &amp;&amp; oldAttrs.coordinates !== newAttrs.coordinates) {
      this.map.move({ from: oldAttrs.coordinates, to: newAttrs.coordinates });
    }
  }
});
</code></pre>
<p>After:</p>
<pre><code class="language-javascript">Ember.Component.extend({
  didReceiveAttrs() {
    let oldCoordinates = this.get('_previousCoordinates');
    let newCoordinates = this.get('coordinates');

    if (oldCoordinates &amp;&amp; oldCoordinates !== newCoordinates) {
      this.map.move({ from: oldCoordinates, to: newCoordinates });
    }

    this.set('_previousCoordinates', newCoordinates);
  }
});
</code></pre>
<a class="header" href="print.html#didupdateattrs" id="didupdateattrs"><h3><code>didUpdateAttrs</code></h3></a>
<p>This hook is very similar to <code>didReceiveAttrs</code>, except it only runs on re-renders and not the initial render.</p>
<p>Before:</p>
<pre><code class="language-javascript">Ember.Component.extend({
  didUpdateAttrs({ oldAttrs, newAttrs }) {
    if (oldAttrs &amp;&amp; oldAttrs.coordinates !== newAttrs.coordinates) {
      this.map.move({ from: oldAttrs.coordinates, to: newAttrs.coordinates });
    }
  }
});
</code></pre>
<p>After:</p>
<pre><code class="language-javascript">Ember.Component.extend({
  didUpdateAttrs() {
    let oldCoordinates = this.get('_previousCoordinates');
    let newCoordinates = this.get('coordinates');

    if (oldCoordinates &amp;&amp; oldCoordinates !== newCoordinates) {
      this.map.move({ from: oldCoordinates, to: newCoordinates });
    }

    this.set('_previousCoordinates', newCoordinates);
  }
});
</code></pre>
<a class="header" href="print.html#how-we-teach-this-10" id="how-we-teach-this-10"><h1>How We Teach This</h1></a>
<p>Due to the previous undocumented nature of the arguments, there is no official documentation that will require updating deprecated usage.</p>
<p>As required for framework deprecations, there will be a deprecation guide written up and linked from within the deprecation message. This deprecation guide will address the more common usage patterns associated with lifecycle hook arguments, such as the Transition Path example.</p>
<p>Additionally, the usage patterns present in the deprecation guide could also be documented in the component section of the official Guides, as a proactive approach for teaching newcomers.</p>
<a class="header" href="print.html#drawbacks-28" id="drawbacks-28"><h1>Drawbacks</h1></a>
<p>One immediate drawback of this proposal is that due to references to the arguments in community resources, there are uses of them in the wild. Updating deprecated code will have to be done mostly manually, as automation might prove difficult.</p>
<p>Another drawback is that by the very nature of publishing this RFC, attention will be drawn to the arguments. It is our hope that the increased awareness will be a net positive due to the clear guidance gained by users of the framework.</p>
<p>It is then our assessment that these drawbacks are outweighed by the benefits of the change.</p>
<a class="header" href="print.html#alternatives-28" id="alternatives-28"><h1>Alternatives</h1></a>
<p>There are two standout alternatives to the proposal presented here which are doing nothing, or making the arguments public and supporting them going forward, both of which are less than ideal for reasons stated previously.</p>
<p>Doing nothing would perpetuate the confusion surrounding lifecycle hook arguments. While it might be argued that that ship has sailed, we prefer to think that it's never too late to provide users of the framework with clearer messaging regarding usage of certain features.</p>
<p>Making the arguments public and supported would mean supporting APIs that did not go through the RFC process, meaning they do not align with some of the current values of the framework, nor would iteration on them would be possible without introducing breakage. Additionally, there are some performance penalties to supporting these arguments, mentioned in the Motivation section.</p>
<a class="header" href="print.html#unresolved-questions-24" id="unresolved-questions-24"><h1>Unresolved questions</h1></a>
<p>None.</p>
<ul>
<li>Start Date: 2016-12-24</li>
<li>RFC PR: https://github.com/emberjs/rfcs/pull/194</li>
<li>Ember Issue: https://github.com/emberjs/ember.js/issues/14754</li>
</ul>
<a class="header" href="print.html#summary-29" id="summary-29"><h1>Summary</h1></a>
<p>Support for component <code>eventManger</code>s is a seldom used feature and should
be deprecated.</p>
<a class="header" href="print.html#motivation-30" id="motivation-30"><h1>Motivation</h1></a>
<p>We should strive to simplify the Ember API and source code where possible. As
the custom <code>eventManager</code> feature is rarely used in apps, we should deprecate
it.</p>
<a class="header" href="print.html#detailed-design-25" id="detailed-design-25"><h1>Detailed design</h1></a>
<p>We'll introduce a deprecation warning which will be displayed when a component
defines an <code>eventManager</code> property or when <code>canDispatchToEventManager</code> is set to
true on <code>EventDispatcher</code>. The warning will have a target version of <code>3.0</code>.</p>
<p>If required, we can create an addon which extends the <code>EventDispatcher</code> allowing
for opt-in custom <code>eventManager</code>s in Ember apps.</p>
<a class="header" href="print.html#how-we-teach-this-11" id="how-we-teach-this-11"><h1>How We Teach This</h1></a>
<p>As this is a seldom used feature, we can simply note the deprecation in a
future release blog post.</p>
<a class="header" href="print.html#drawbacks-29" id="drawbacks-29"><h1>Drawbacks</h1></a>
<p>This adds a little more churn for apps that rely on this feature.</p>
<a class="header" href="print.html#alternatives-29" id="alternatives-29"><h1>Alternatives</h1></a>
<p>This feature was <a href="https://github.com/emberjs/ember.js/pull/14756">recently made pay-as-you-go</a>,
so the immediate performance concerns have been addressed. We could decide to
leave this in the framework as an opt-in feature.</p>
<ul>
<li>Start Date: 2017-03-13</li>
<li>RFC PR: https://github.com/emberjs/rfcs/pull/213</li>
<li>Ember Issue: https://github.com/emberjs/ember.js/issues/16301</li>
</ul>
<a class="header" href="print.html#summary-30" id="summary-30"><h1>Summary</h1></a>
<p>This RFC aims to expose a <em>low-level primitive</em> for defining <em>custom
components</em>.</p>
<p>This API will allow addon authors to provide special-purpose component base
classes that their users can subclass from in apps. These components are
invokable in templates just like any other Ember components (descendants of
<code>Ember.Component</code>) today.</p>
<a class="header" href="print.html#motivation-31" id="motivation-31"><h1>Motivation</h1></a>
<p>The ability to author reusable, composable components is a core feature of
Ember.js. Despite being a <a href="http://emberjs.com/blog/2013/06/23/ember-1-0-rc6.html">last-minute addition</a>
to Ember 1.0, the <code>Ember.Component</code> API and programming model has proven itself
to be an extremely versatile tool and has aged well over time into the primary
unit of composition in Ember's view layer.</p>
<p>That being said, the current component API (hereinafter &quot;classic components&quot;)
does have some noticeable shortcomings. Over time, classic components have also
accumulated some cruft due to backwards compatibility constraints.</p>
<p>These problems led to the original &quot;angle bracket components&quot; proposal (see RFC
<a href="https://github.com/emberjs/rfcs/blob/master/text/0015-the-road-to-ember-2-0.md">#15</a>
and <a href="https://github.com/emberjs/rfcs/pull/60">#60</a>), which promised to address
these problems via the angle bracket invocation opt-in (i.e. <code>&lt;foo-bar ...&gt;</code>
instead of <code>{{foo-bar ...}}</code>).</p>
<p>Since the transition to the angle bracket invocation syntax was seen as a rare,
once-in-a-lifetime opportunity, it became very tempting to debate every single
shortcomings and missing features in the classic components API in the process
and attempt to design solutions for all of them.</p>
<p>While that discussion was very helpful in capturing constraints and guiding the
overall direction, designing that One True API in the abstract turned out to
be extremely difficult. It also went against our philosophy that framework
features should be extracted from applications and designed iteratively with
feedback from real-world usage.</p>
<p>Since that original proposal, we have rewritten Ember's rendering engine from
the ground up (the &quot;Glimmer 2&quot; project). One of the goals of the Glimmer 2
effort was to build first-class support for Ember's view-layer features into
the rendering engine. As part of the process, we worked to rationalize these
features and to re-think the role of components in Ember.js. This exercise has
brought plenty of new ideas and constraints to the table.</p>
<p>The initial Glimmer 2 integration was completed in <a href="http://emberjs.com/blog/2016/11/30/ember-2-10-released.html">Ember 2.10</a>.
As of that version, classic components have been re-implemented using the new
primitives provided by the rendering engine, and we are very happy with the
results.</p>
<p>This approach yielded a number of very powerful and flexible primitives:
in addition to classic components, we were able to implement Ember's
<code>{{mount}}</code>, <code>{{outlet}}</code> and <code>{{render}}</code> helpers as &quot;components&quot; under the
hood.</p>
<p>Based on our experience, we believe it would be beneficial to open up these new
primitives to the wider community. Specifically, there are at least two clear
benefits that comes to mind:</p>
<p>First, it provides addon authors fine-grained control over the exact behavior
and semantics of their components in cases where the general-purpose components
are a poor fit. For example, a low-overhead component designed to be used in
performance hotspot can opt-out of certain convinence features using this API.</p>
<p>Second, it allows the community to experiment with and iterate on alternative
component APIs outside of the core framework. Following the success of FastBoot
and Engines, we believe the best way to design the new &quot;Glimmer Components&quot; API
is to first stablize the underlying primitives in the core framework and
experiment with the surface API through an addon.</p>
<a class="header" href="print.html#detailed-design-26" id="detailed-design-26"><h1>Detailed design</h1></a>
<p>This RFC introduces the concept of <em>component managers</em>. A component manager is
an object that is responsible for coordinating the lifecycle events that occurs
when invoking, rendering and re-rendering a component.</p>
<a class="header" href="print.html#registering-component-managers" id="registering-component-managers"><h2>Registering component managers</h2></a>
<p>Component managers are registered with the <code>component-manger</code> type in the
application's registry. Similar to services, component managers are singleton
objects (i.e. <code>{ singleton: true, instantiate: true }</code>), meaning that Ember
will create and maintain (at most) one instance of each unique component
manager for every application instance.</p>
<p>To register a component manager, an addon will put it inside its <code>app</code> tree:</p>
<pre><code class="language-js">// ember-basic-component/app/component-managers/basic.js

import EmberObject from '@ember/object';

export default EmberObject.extend({
  // ...
});
</code></pre>
<p>(Typically, the convention is for addons to define classes like this in its
<code>addon</code> tree and then re-export them from the <code>app</code> tree. For brevity, we will
just inline them in the <code>app</code> tree directly for the examples in this RFC.)</p>
<p>This allows the component manager to participate in the DI system  receiving
injections, using services, etc. Alternatively, component managers can also
be registered with imperative API. This could be useful for testing or opt-ing
out of the DI system. For example:</p>
<pre><code class="language-js">// ember-basic-component/app/initializers/register-basic-component-manager.js

const MANAGER = {
  // ...
};

export function initialize(application) {
  // We want to use a POJO here, so we are opt-ing out of instantiation
  application.register('component-manager:basic', MANAGER, { instantiate: false });
}

export default {
  name: 'register-basic-component-manager',
  initialize
};
</code></pre>
<a class="header" href="print.html#determining-which-component-manager-to-use" id="determining-which-component-manager-to-use"><h2>Determining which component manager to use</h2></a>
<p>For the purpose of this section, we will assume components with a JavaScript
file (such as <code>app/components/foo-bar.js</code> or the equivilant in &quot;pods&quot; and
<a href="https://github.com/emberjs/rfcs/blob/master/text/0143-module-unification.md">Module Unification</a>
apps) and optionally a template file (<code>app/templates/components/foo-bar.hbs</code>
or equivilant). The example section has additional information about how this
relates to <a href="https://github.com/emberjs/rfcs/blob/master/text/0278-template-only-components.md">template-only components</a>.</p>
<p>When invoking the component <code>{{foo-bar ...}}</code>, Ember will first resolve the
component class (<code>component:foo-bar</code>, usually the <code>default</code> export from
<code>app/components/foo-bar.js</code>). Next, it will determine the appropiate component
manager to use based on the resolved component class.</p>
<p>Ember will provide a new API to assign the component manager for a component
class:</p>
<pre><code class="language-js">// my-app/app/components/foo-bar.js

import EmberObject from '@ember/object';
import { setComponentManager } from '@ember/component';

export default setComponentManager('awesome', EmberObject.extend({
  // ...
}));
</code></pre>
<p>This tells Ember to use the <code>awesome</code> manager (<code>component-manager:awesome</code>) for
the <code>foo-bar</code> component. <code>setComponentManager</code> function returns the class.</p>
<p>In the future, this function can also be invoked as a decorator:</p>
<pre><code class="language-js">// my-app/app/components/foo-bar.js

import EmberObject from '@ember/object';
import { componentManager } from '@ember/component';

export default @componentManager('awesome') EmberObject.extend({
  // ...
});
</code></pre>
<p>In reality, an app developer would never have to write this in their apps,
since the component manager would already be assigned on a super-class provided
by the framework or an addon. The <code>setComponentManager</code> function is essentially
a low-level API designed for addon authors and not intended to be used by app
developers.</p>
<p>For example, the <code>Ember.Component</code> class would have the <code>classic</code> component
manager pre-assigned, therefore the following code will continue to work as
intended:</p>
<pre><code class="language-js">// my-app/app/components/foo-bar.js

import Component from '@ember/component';

export default Component.extend({
  // ...
});
</code></pre>
<p>Similarly, an addon can provided the following super-class:</p>
<pre><code class="language-js">// ember-basic-component/addon/index.js

import EmberObject from '@ember/object';
import { componentManager } from '@ember/component';

export default setComponentManager('basic', EmberObject.extend({
  // ...
}));
</code></pre>
<p>With this, app developers can simply inherit from this in their app:</p>
<pre><code class="language-js">// my-app/app/components/foo-bar.js

import BasicComponent from 'ember-basic-component';

export default BasicComponent.extend({
  // ...
});
</code></pre>
<p>Here, the <code>foo-bar</code> component would automatically inherit the <code>basic</code> component
manager from its super-class.</p>
<p>It is not advisable to override the component manager assigned by the framework
or an addon. Attempting to reassign the component manager when one is already
assinged on a super-class will be an error. If no component manager is set, it
will also result in a runtime error when invoking the component.</p>
<a class="header" href="print.html#component-lifecycle" id="component-lifecycle"><h2>Component Lifecycle</h2></a>
<p>Back to the <code>{{foo-bar ...}}</code> example.</p>
<p>Once Ember has determined the component manager to use, it will be used to
manage the component's lifecycle.</p>
<a class="header" href="print.html#createcomponent" id="createcomponent"><h3><code>createComponent</code></h3></a>
<p>The first step is to create an instance of the component. Ember will invoke the
component manager's <code>createComponent</code> method:</p>
<pre><code class="language-javascript">// ember-basic-component/app/component-managers/basic.js

import EmberObject from '@ember/object';

export default EmberObject.extend({
  createComponent(factory, args) {
    return factory.create(args.named);
  },

  // ...
});
</code></pre>
<p>The <code>createComponent</code> method on the component manager is responsible for taking
the component's factory and the arguments passed to the component (the <code>...</code> in
<code>{{foo-bar ...}}</code>) and return an instantiated component.</p>
<p>The first argument passed to <code>createComponent</code> is the result returned from the
<a href="https://github.com/emberjs/rfcs/blob/master/text/0150-factory-for.md"><code>factoryFor</code></a>
API. It contains a <code>class</code> property, which gives you the the raw class (the
<code>default</code> export from <code>app/components/foo-bar.js</code>) and a <code>create</code> function that
can be used to instantiate the class with any registered injections, merging
them with any additional properties that are passed.</p>
<p>The second argument is a snapshot of the arguments passed to the component in
the template invocation, given in the following format:</p>
<pre><code class="language-js">{
  positional: [ ... ],
  named: { ... }
}
</code></pre>
<p>For example, given the following invocation:</p>
<pre><code class="language-hbs">{{blog-post (titleize post.title) post.body author=post.author excerpt=true}}
</code></pre>
<p>You will get the following as the second argument:</p>
<pre><code class="language-js">{
  positional: [
    &quot;Rails Is Omakase&quot;,
    &quot;Lorem ipsum dolor sit amet, consectetur adipiscing elit...&quot;
  ],
  named: {
    &quot;author&quot;: #&lt;User name=&quot;David Heinemeier Hansson&quot;, ...&gt;,
    &quot;excerpt&quot;: true
  }
}
</code></pre>
<p>The arguments object should not be mutated (e.g. <code>args.positional.pop()</code> is no
good). In development mode, it might be sealed/frozen to help prevent these
kind of mistakes.</p>
<a class="header" href="print.html#getcontext" id="getcontext"><h3><code>getContext</code></h3></a>
<p>Once the component instance has been created, the next step is for Ember to
determine the <code>this</code> context to use when rendering the component's template by
calling the component manager's <code>getContext</code> method:</p>
<pre><code class="language-js">// ember-basic-component/app/component-managers/basic.js

import EmberObject from '@ember/object';

export default EmberObject.extend({
  createComponent(factory, args) {
    return factory.create(args.named);
  },

  getContext(component) {
    return component;
  },

  // ...
});
</code></pre>
<p>The <code>getContext</code> method gets passed the component instance returned from
<code>createComponent</code> and should return the object that <code>{{this}}</code> should refer to
in the component's template, as well as for any &quot;fallback&quot; property lookups
such as <code>{{foo}}</code> where <code>foo</code> is neither a local variable or a helper (which
resolves to <code>{{this.foo}}</code> where <code>this</code> is here is the object returned by
<code>getContext</code>).</p>
<p>Typically, this method can simpliy return the component instance, as shown in
the example above. The reason this exists as a separate method is to enable the
so-called &quot;state bucket&quot; pattern which allows addon authors to attach extra
book-keeping metadata to the component:</p>
<pre><code class="language-js">// ember-basic-component/app/component-managers/basic.js

import EmberObject from '@ember/object';

export default EmberObject.extend({
  createComponent(factory, args) {
    let metadata = { ... };
    let instance = factory.create(args.named);
    return { metadata, instance, ... };
  },

  getContext(bucket) {
    return bucket.instance;
  },

  // ...
});
</code></pre>
<p>Since the &quot;state bucket&quot;, not the &quot;context&quot;, is passed back to other hooks on
the component manager, this allows the component manager to access the extra
metadata but otherwise hide them from the app developers.</p>
<p>We will see an example that uses this pattern in a later section.</p>
<p>At this point, Ember will have gathered all the information it needs to render
the component's template, which will be rendered with <a href="https://github.com/emberjs/rfcs/blob/master/text/0278-template-only-components.md">&quot;Outer HTML&quot; semantics</a>.</p>
<p>In other words, the content of the template will be rendered as-is, without a
wrapper element (e.g. <code>&lt;div id=&quot;ember1234&quot; class=&quot;ember-view&quot;&gt;...&lt;/div&gt;</code>),
except for subclasses of <code>Ember.Component</code>, which will retain the current
legacy behavior (the internal <code>classic</code> manager uses private capabilities to
achieve that).</p>
<p>This API does not currently provide any way to fine-tune the rendering behavior
(such as dynamically changing the component's template) besides <code>getContext</code>,
but future iterations may introduce extra capabilities.</p>
<a class="header" href="print.html#updatecomponent" id="updatecomponent"><h3><code>updateComponent</code></h3></a>
<p>When it comes time to re-render a component's template (usually because an
argument has changed), Ember will call the manager's <code>updateComponent</code> method
to give the manager an opportunity to reflect those changes on the component
instance, before performing the re-render:</p>
<pre><code class="language-js">// ember-basic-component/app/component-managers/basic.js

import EmberObject from '@ember/object';

export default EmberObject.extend({
  createComponent(factory, args) {
    return factory.create(args.named);
  },

  getContext(component) {
    return component;
  },

  updateComponent(component, args) {
    component.setProperties(args.named);
  },

  // ...
});
</code></pre>
<p>The first argument passed to this method is the component instance returned by
<code>createComponent</code>. As mentioned above, using the &quot;state bucket&quot; pattern will
allow this hook to access the extra metadata:</p>
<pre><code class="language-js">// ember-basic-component/app/component-managers/basic.js

import EmberObject from '@ember/object';

export default EmberObject.extend({
  createComponent(factory, args) {
    let metadata = { ... };
    let instance = factory.create(args.named);
    return { metadata, instance, ... };
  },

  getContext(bucket) {
    return bucket.instance;
  },

  updateComponent(bucket, args) {
    let { metadata, instance } = bucket;
    // do things with metadata
    instance.setProperties(args.named);
  },

  // ...
});
</code></pre>
<p>The second argument is a snapshot of the updated arguments, passed with the
same format as in <code>createComponent</code>. Note that there is no guarentee that
anything in the arguments object has <em>actually</em> changed when this method is
called. For example, given:</p>
<pre><code class="language-hbs">{{blog-post title=(uppercase post.title) ...}}
</code></pre>
<p>Imagine if <code>post.title</code> changed from <code>fOo BaR</code> to <code>FoO bAr</code>. Since the value
is passed through the <code>uppercase</code> helper, the component will see <code>FOO BAR</code> in
both cases.</p>
<p>Generally speaking, Ember does not provide any guarentee on how it determines
whether components need to be re-rendered, and the semantics may vary between
releases  i.e. this method may be called more or less often as the internals
changes. The <em>only</em> guarentee is that if something <em>has</em> changed, this method
will definitely be called.</p>
<p>If it is important to your component's programming model to <em>only</em> notify the
component when there are actual changes, the manager is responsible for doing
the extra book-keeping.</p>
<p>For example:</p>
<pre><code class="language-js">// ember-basic-component/index.js

import EmberObject from '@ember/object';
import { setComponentManager } from '@ember/component';

function NOOP() {}

export default setComponentManager('basic', EmberObject.extend({
  // Users of BasicComponent can override this hook to be notified when an
  // argument will change
  argumentWillChange: NOOP,

  // Users of BasicComponent can override this hook to be notified when an
  // argument will change
  argumentDidChange: NOOP,

  // ...
}));
</code></pre>
<pre><code class="language-js">// ember-basic-component/app/component-managers/basic.js

import EmberObject from '@ember/object';

export default EmberObject.extend({
  createComponent(factory, args) {
    return {
      args: args.named,
      instance: factory.create(args.named)
    };
  },

  getContext(bucket) {
    return bucket.instance;
  },

  updateComponent(bucket, args) {
    let instance = bucket.instance;
    let oldArgs = bucket.args;
    let newArgs = args.named;
    let changed = false;

    // Since the arguments are coming from the template invocation, you can
    // generally assume that they have exactly the same keys. However, future
    // additions such as &quot;splat arguments&quot; in the template layer might change
    // that assumption.
    for (let key in oldArgs) {
      let oldValue = oldArgs[key];
      let newValue = newArgs[key];

      if (oldValue !== newValue) {
        instance.argumentWillChange(key, oldValue, newValue);
        instance.set(key, newValue);
        instance.argumentDidChange(key, oldValue, newValue);
      }
    }

    bucket.args = newArgs;
  },

  // ...
});
</code></pre>
<p>This example also shows when the &quot;state bucket&quot; pattern could be useful.</p>
<p>The return value of the <code>updateComponent</code> is ignored.</p>
<p>After calling the <code>updateComponent</code> method, Ember will update the component's
template to reflect any changes.</p>
<a class="header" href="print.html#capabilities" id="capabilities"><h2>Capabilities</h2></a>
<p>In addition to the methods specified above, component managers are required to
have a <code>capabilities</code> property.  This property must be set to the result of
calling the <code>capabilities</code> function provided by Ember.</p>
<a class="header" href="print.html#versioning" id="versioning"><h3>Versioning</h3></a>
<p>The first, mandatory, argument to the <code>capabilities</code> function is the component
manager API, which is denoted in the <code>${major}.${minor}</code> format, matching the
minimum Ember version this manager is targeting. For example:</p>
<pre><code class="language-js">// ember-basic-component/app/component-managers/basic.js

import { capabilities } from '@ember/component';
import EmberObject from '@ember/object';

export default EmberObject.extend({
  capabilities: capabilities('3.2'),

  createComponent(factory, args) {
    return factory.create(args.named);
  },

  getContext(component) {
    return component;
  },

  updateComponent(component, args) {
    component.setProperties(args.named);
  }
});
</code></pre>
<p>This allows Ember to introduce new capabilities and make improvements to this
API without breaking existing code.</p>
<p>Here is a hypothical scenario for such a change:</p>
<ol>
<li>
<p>Ember 3.2 implemented and shipped the component manager API as described in
this RFC.</p>
</li>
<li>
<p>The <code>ember-basic-component</code> addon released version 1.0 with the component
manager shown above (notably, it declared <code>capabilities('3.2')</code>).</p>
</li>
<li>
<p>In Ember 3.5, we determined that constructing the arguments object passed to
the hooks is a major performance bottleneck, and changes the API to pass a
&quot;proxy&quot; object with getter methods instead (e.g. <code>args.getPositional(0)</code> and
<code>args.getNamed('foo')</code>).</p>
<p>However, since Ember sees that the <code>basic</code> component manager is written to
target the <code>3.2</code> API version, it will retain the old behavior and passes the
old (more expensive) &quot;reified&quot; arguments object instead, to avoid breakage.</p>
</li>
<li>
<p>The <code>ember-basic-component</code> addon author would like to take advantage of
this performance optimization, so it updates its component manager code to
work with the arguments proxy and changes its capabilities declaration to
<code>capabilities('3.5')</code> in version 2.0.</p>
</li>
</ol>
<p>This system allows us to rapidly improve the API and take advantage of
underlying rendering engine features as soon as they become available.</p>
<p>Note that addon authors are not <em>required</em> to update to the newer API.
Concretely, component manager APIs have the following support policy:</p>
<ul>
<li>
<p>API versions will continue to be supported in the same major release of
Ember. As shown in the example above, <code>ember-basic-component</code> 1.0 (which
targets component manager API version 3.2), will continue to work on
Ember 3.5. However, the reverse is not true  component manager API version
3.5 will (somewhat obviously) not work in Ember 3.2.</p>
</li>
<li>
<p>In addition, to ensure a smooth transition path for addon authors and app
developers across major releases, each Ember version will support (at least)
the previous LTS version as of the release was made. For example, if 3.16 is
the last LTS release of the 3.x series, the component manager API version
3.16 will be supported by Ember 4.0 through 4.4, at minimum.</p>
</li>
</ul>
<p>Addon authors can also choose to target multiple versions of the component
manager API using <a href="https://github.com/pzuraq/ember-compatibility-helpers/">ember-compatibility-helpers</a>:</p>
<pre><code class="language-js">// ember-basic-component/app/component-managers/basic.js

import { gte } from 'ember-compatibility-helpers';

let ComponentManager;

if (gte('3.5')) {
  ComponentManager = EmberObject.extend({
    capabilities: capabilities('3.5'),

    // ...
  });
} else {
  ComponentManager = EmberObject.extend({
    capabilities: capabilities('3.2'),

    // ...
  });
}

export default ComponentManager;
</code></pre>
<p>Since the conditionals are resolved at build time, the irrevelant code will be
stripped from production builds, avoiding any deprecation warnings.</p>
<a class="header" href="print.html#optional-features" id="optional-features"><h3>Optional Features</h3></a>
<p>The second, optional, argument to the <code>capabilities</code> function is an object
enumerating the optional features requested by the component manager.</p>
<p>In the hypothical example above, while the &quot;reified&quot; arguments objects may be
a little slower, they are certainly easier to work with, and the performance
may not matter to but the most performance critical components. A component
manager written for Ember 3.5 (again, only hypothically) and above would be
able to explicitly opt back into the old behavior like so:</p>
<pre><code class="language-js">// ember-basic-component/app/component-managers/basic.js

import { capabilities } from '@ember/component';
import EmberObject from '@ember/object';

export default EmberObject.extend({
  capabilities: capabilities('3.5', {
    reifyArguments: true
  }),

  // ...
});
</code></pre>
<p>In general, we will aim to have the defaults set to as bare-bone as possible,
and allow the component managers to opt into the features they need in a PAYGO
(pay-as-you-go) manner, which aligns with the Glimmer VM philosophy. As the
rendering engine evolves, more and more feature will become optional.</p>
<a class="header" href="print.html#optional-capabilities" id="optional-capabilities"><h2>Optional Capabilities</h2></a>
<p>The following optionally capabilities will be available with the first version
of the component manager API. We expect future RFCs to propose additional
capabilities within the framework provided by this initial RFC.</p>
<a class="header" href="print.html#async-lifecycle-callbacks" id="async-lifecycle-callbacks"><h3>Async Lifecycle Callbacks</h3></a>
<p>When the <code>asyncLifecycleCallbacks</code> capability is set to <code>true</code>, the component
manager is expected to implement two additional methods: <code>didCreateComponent</code>
and <code>didUpdateComponent</code>.</p>
<p><code>didCreateComponent</code> will be called after the component has been rendered the
first time, after the whole top-down rendering process is completed. Similarly,
<code>didUpdateComponent</code> will be called after the component has been updated, after
the whole top-down rendering process is completed. This would be the right time
to invoke any user callbacks, such as <code>didInsertElement</code> and <code>didRender</code> in the
classic components API.</p>
<p>These methods will be called with the component instance (the &quot;state bucket&quot;
returned by <code>createComponent</code>) as the only argument. The return value is
ignored.</p>
<p>These callbacks are called if and only if their synchronous APIs were invoked
during rendering. For example, if <code>updateComponent</code> was called on during
rendering (and it completed without errors), <code>didUpdateComponent</code> will always
be called. Conversely, if <code>didUpdateComponent</code> is called, you can infer that
the <code>updateComponent</code> was called on the same component instance during
rendering.</p>
<p>This API provides no guarentee about ordering with respect to siblings or
parent-child relationships.</p>
<a class="header" href="print.html#destructors" id="destructors"><h3>Destructors</h3></a>
<p>When the <code>destructor</code> capability is set to <code>true</code>, the component manager is
expected to implement an additional method: <code>destroyComponent</code>.</p>
<p><code>destroyComponent</code> will be called when the component is no longer needed. This
is intended for performing object-model level cleanup.</p>
<p>Because this RFC does not provide ways to access or observe the component's DOM
tree, the timing relative to DOM teardown is undefined (i.e. whether this is
called before or after the component's DOM tree is removed from the document).</p>
<p>Therefore, this hook is not suitable for invoking user callbacks intended for
performing DOM cleanup, such as <code>willDestroyElement</code> in the classic components
API. We expect a subsequent RFC addressing DOM-related functionalities to
clarify this issues or provide another specialized method for that purpose.</p>
<p>Similar to the other async lifecycle callbacks, this API provides no guarentee
about ordering with respect to siblings or parent-child relationships. Further,
the exact timing of the calls are also undefined. For example, the calls from
several render loops might be batched together and deferred into a browser idle
callback.</p>
<a class="header" href="print.html#examples-3" id="examples-3"><h1>Examples</h1></a>
<a class="header" href="print.html#basic-component-manager" id="basic-component-manager"><h2>Basic Component Manager</h2></a>
<p>Here is the simpliest end-to-end component manager example that uses a plain
<code>Ember.Object</code> super-class (as opposed to <code>Ember.Component</code>) with &quot;Outer HTML&quot;
semantics:</p>
<pre><code class="language-js">// ember-basic-component/app/component-managers/basic.js

import { capabilities } from '@ember/component';
import EmberObject from '@ember/object';

export default EmberObject.extend({
  capabilities: capabilities('3.2', {
    destructor: true
  }),

  createComponent(factory, args) {
    return factory.create(args.named);
  },

  getContext(component) {
    return component;
  },

  updateComponent(component, args) {
    component.setProperties(args.named);
  },

  destroyComponent(component) {
    component.destroy();
  }
});
</code></pre>
<pre><code class="language-js">// ember-basic-component/addon/index.js

import EmberObject from '@ember/object';
import { setComponentManager } from '@ember/component';

export default setComponentManager('basic', EmberObject.extend());
</code></pre>
<a class="header" href="print.html#usage" id="usage"><h3>Usage</h3></a>
<pre><code class="language-js">// my-app/app/components/x-counter.js

import BasicCompoment from 'ember-basic-component';

export default BasicCompoment.extend({
  init() {
    this.count = 0;
  },

  down() {
    this.decrementProperty('count');
  },

  up() {
    this.incrementProperty('count');
  }
});
</code></pre>
<pre><code class="language-hbs">{{!-- my-app/app/templates/components/x-counter.hbs --}}

&lt;div&gt;
  &lt;button {{action this.down}}&gt;&lt;/button&gt;
  {{this.count}}
  &lt;button {{action this.up}}&gt;&lt;/button&gt;
&lt;/div&gt;
</code></pre>
<a class="header" href="print.html#template-only-components" id="template-only-components"><h2>Template-only Components</h2></a>
<p>This example implements a kind of component similar to what was proposed in the
<a href="https://github.com/emberjs/rfcs/blob/master/text/0278-template-only-components.md">template-only components</a>
RFC.</p>
<p>Since the custom components API proposed in this RFC requires a JavaScript
files, we cannot implement true &quot;template-only&quot; components. We will need to
create a component JS file to export a dummy value, for the sole purpose of
indicating the component manager we want to use.</p>
<p>In practice, there is no need for an addon to implement this API, since it is
essentially re-implementing what the &quot;template-only-glimmer-components&quot;
optional feature does. Nevertheless, this example is useful for illustrative
purposes.</p>
<pre><code class="language-js">// ember-template-only-component/app/component-managers/template-only.js

import { capabilities } from '@ember/component';
import EmberObject from '@ember/object';

export default EmberObject.extend({
  capabilities: capabilities('3.2'),

  createComponent() {
    return null
  },

  getContext() {
    return null;
  },

  updateComponent() {
    return;
  }
});
</code></pre>
<pre><code class="language-js">// ember-template-only-component/addon/index.js

import { setComponentManager } from '@ember/component';

// Our `createComponent` method does not actually do anything with the factory,
// so we don't even need to export a class here, `{}` would work just fine.
export default setComponentManager('template-only', {});
</code></pre>
<a class="header" href="print.html#usage-1" id="usage-1"><h3>Usage</h3></a>
<pre><code class="language-js">// my-app/app/components/hello-world.js

import TemplateOnlyComponent from 'ember-template-only-component';

export default TemplateOnlyComponent;
</code></pre>
<pre><code class="language-hbs">Hello world! I have no backing class! {{this}} would be &lt;code&gt;null&lt;/code&gt;.
</code></pre>
<a class="header" href="print.html#recycling-components" id="recycling-components"><h2>Recycling Components</h2></a>
<p>This example implements an API which maintain a pool of recycled component
instances to avoid allocation costs.</p>
<p>This example also make use of the &quot;state bucket&quot; pattern.</p>
<pre><code class="language-js">// ember-component-pool/app/component-managers/pooled.js

import { capabilities } from '@ember/component';
import EmberObject from '@ember/object';

// How many instances to keep (per type/factory)
const LIMIT = 10;

export default EmberObject.extend({
  capabilities: capabilities('3.2', {
    destructor: true
  }),

  init() {
    this.pool = new Map();
  },

  createComponent(factory, args) {
    let instances = this.pool.get(factory);
    let instance;

    if (instances &amp;&amp; instances.length &gt; 0) {
      instance = instances.pop();
      instance.setProperties(args.named);
    } else {
      instance = factroy.create(args.named);
    }

    // We need to remember which factory does the instance belong to so we can
    // check it back into the pool later.
    return { factory, instance };
  },

  getContext({ instance }) {
    return instance;
  },

  updateComponent({ instance }, args) {
    instance.setProperties(args.named);
  },

  destroyComponent({ factory, instance }) {
    let instances;

    if (this.pool.has(factory)) {
      instances = this.pool.get(factory);
    } else {
      this.pool.set(factory, instances = []);
    }

    if (instances.length &gt;= LIMIT) {
      instance.destroy();
    } else {
      // User hook to reset any state
      instance.willRecycle();
      instances.push(instance);
    }
  },

  // This is the `Ember.Object` lifecycle method, called when the component
  // manager instance _itself_ is being destroyed, not to be confused with
  // `destroyComponent`
  willDestroy() {
    for (let instances of this.pool.values()) {
      instances.forEach(instance =&gt; instance.destroy());
    }

    this.pool.clear();
  }
});
</code></pre>
<pre><code class="language-js">// ember-component-pool/addon/index.js

import EmberObject from '@ember/object';
import { setComponentManager } from '@ember/component';

function NOOP() {}

export default setComponentManager('pooled', EmberObject.extend({
  // Override this to implement reset any state on the instance
  willRecycle(): NOOP,

  // ...
}));
</code></pre>
<a class="header" href="print.html#how-we-teach-this-12" id="how-we-teach-this-12"><h1>How We Teach This</h1></a>
<p>What is proposed in this RFC is a <em>low-level</em> primitive. We do not expect most
users to interact with this layer directly. Instead, most users will simply
benefit from this feature by subclassing these special components provided by
addons.</p>
<p>At present, the classic components APIs is still the primary, recommended path
for almost all use cases. This is the API that we should teach new users, so we
do not expect the guides need to be updated for this feature (at least not the
components section).</p>
<p>For documentation purposes, each Ember.js release will only document the latest
component manager API, along with the available optional capabilities for that
realease. The documentation will also include the steps needed to upgrade from
the previous version. Documentation for a specific version of the component
manager API can be viewed from the versioned documentation site.</p>
<a class="header" href="print.html#drawbacks-30" id="drawbacks-30"><h1>Drawbacks</h1></a>
<p>In the long term, there is a risk of fragmentating the Ember ecosystem with
many competing component APIs. However, given the Ember community's strong
desire for conventions, this seems unlikely. We expect this to play out similar
to the data-persistence story  there will be a primary way to do things (Ember
Data), but there are also plenty of other alternatives catering to niche use
cases that are underserved by Ember Data.</p>
<p>Also, because apps can mix and match component styles, it's possible for a
library like smoke-and-mirrors or Liquid Fire to take advantage of the
enhanced functionality internally without leaking those implementation
details to applications.</p>
<a class="header" href="print.html#alternatives-30" id="alternatives-30"><h1>Alternatives</h1></a>
<p>Instead of focusing on exposing enough low-level primitives to build the new
components API, we could just focus on building out the user-facing APIs
without rationalizing or exposing the underlying primitives.</p>
<a class="header" href="print.html#appendix" id="appendix"><h1>Appendix</h1></a>
<a class="header" href="print.html#follow-up-rfcs" id="follow-up-rfcs"><h2>Follow-up RFCs</h2></a>
<p>We expect to rapidly iterate and improve the component manager API through the
RFC process and in-the-field usage/implementation experience. Here are a few
examples of additional capabilities that we hope to see proposed after this
initial (and intentionally minimal) proposal is finalized:</p>
<ol>
<li>
<p>Expose a way to access to the component's DOM structure, such as its bounds.
This RFC would also need to introduce a hook for DOM teardown and address
how event handling/delegation would work.</p>
</li>
<li>
<p>Expose a way to access to the <a href="https://github.com/glimmerjs/glimmer-vm/blob/master/guides/04-references.md">reference</a>-based APIs. This could include
the ability to customize the component's &quot;tag&quot; (<a href="https://github.com/glimmerjs/glimmer-vm/blob/master/guides/05-validators.md">validator</a>).</p>
</li>
<li>
<p>Expose additional features that are used to implement classic components,
<code>{{outlet}}</code> and other built-in components, such as layout customizations,
and dynamic scope access.</p>
</li>
<li>
<p>Angle bracket invocation.</p>
</li>
</ol>
<a class="header" href="print.html#using-es6-classes" id="using-es6-classes"><h2>Using ES6 Classes</h2></a>
<p>Although this RFC uses <code>Ember.Object</code> in the examples, it is not a &quot;hard&quot;
dependency.</p>
<a class="header" href="print.html#using-es6-classes-for-components" id="using-es6-classes-for-components"><h3>Using ES6 Classes For Components</h3></a>
<p>The main interaction between the Ember object model and the component class
is through the DI system. Specifically, the factory function returned by
<code>factoryFor</code> (<code>factoryFor('component:foo-bar').create(...)</code>), which is passed
to the <code>createComponent</code> method on the component manager, assumes a static
<code>create</code> method on the class that takes the &quot;property bag&quot; and returns the
created instance.</p>
<p>Therefore, as long as your ES6 super-class provides such a function, it will
work with the rest of the system:</p>
<pre><code class="language-js">// ember-basic-component/addon/index.js

import { setComponentManager } from '@ember/component';

class BasicComponent {
  static create(props) {
    return new this(props);
  }

  constructor(props) {
    // Do things with props, such as:
    Object.assign(this, props);
  }

  // ...
}

export default setComponentManager('basic', BasicComponent);
</code></pre>
<pre><code class="language-js">// ember-basic-component/app/component-managers/basic.js

import { capabilities } from '@ember/component';
import EmberObject from '@ember/object';

export default EmberObject.extend({
  capabilities: capabilities('3.2'),

  createComponent(factory, args) {
    // This Just Works since we have a static create method on the class
    return factory.create(args.named);
  },

  // ...
});
</code></pre>
<pre><code class="language-js">// my-app/app/components/foo-bar.js

import BasicCompoment from 'ember-basic-component';

export default class extends BasicCompoment {
  // ...
};
</code></pre>
<p>Alternatively, if you prefer not to add a static create method to your
super-class, you can also instantiate them in the component manager without
going through the DI system:</p>
<pre><code class="language-js">// ember-basic-component/app/component-managers/basic.js

import { capabilities } from '@ember/component';
import EmberObject from '@ember/object';

export default EmberObject.extend({
  capabilities: capabilities('3.2'),

  createComponent(factory, args) {
    // This does not use the factory function, thus no longer require a static
    // create method on the class
    return new factory.class(args.named);
  },

  // ...
});
</code></pre>
<p>However, doing do will prevent your components from receiving injections (as
well as setting the appropiate owner, etc). Therefore, when possible, it is
better to go through the DI system's factory function.</p>
<a class="header" href="print.html#using-es6-classes-for-component-managers" id="using-es6-classes-for-component-managers"><h3>Using ES6 Classes For Component Managers</h3></a>
<p>It is also possible to use ES6 classes for the component managers themselves.
The main interaction here is that they are automatically instantiated by the DI
system on-demand, which again assumes a static <code>create</code> method:</p>
<pre><code class="language-js">// ember-basic-component/app/component-managers/basic.js

import { capabilities } from '@ember/component';

export default class BasicComponentManager {
  static create(props) {
    return new this(props);
  }

  constructor(props) {
    // Do things with props, such as:
    Object.assign(this, props);
  }

  capabilities = capabilities('3.2');

  // ...
};
</code></pre>
<p>Alternatively, as shown above, you can also register the component manager
with <code>{ instantiate: false }</code>:</p>
<pre><code class="language-js">// ember-basic-component/app/initializers/register-basic-component-manager.js

import BasicComponentManager from 'ember-basic-component';

export function initialize(application) {
  application.register('component-manager:basic', new BasicComponentManager(), { instantiate: false });
}

export default {
  name: 'register-basic-component-manager',
  initialize
};
</code></pre>
<p>Note that this behaves a bit differently as the component manager instance is
shared across all application instances and is never destroyed, which might
affect stateful component managers such as the one shown in the &quot;Recycling
Components&quot; example above.</p>
<ul>
<li>Start Date: 2017-04-26</li>
<li>RFC PR: <a href="https://github.com/emberjs/ember.js/pull/15174">#15174</a></li>
<li>Ember Issue: (leave this empty)</li>
</ul>
<a class="header" href="print.html#summary-31" id="summary-31"><h1>Summary</h1></a>
<p>This RFC proposes allowing parameters to be passed to the <code>{{mount}}</code> syntax.</p>
<a class="header" href="print.html#motivation-32" id="motivation-32"><h1>Motivation</h1></a>
<p>This will enable developers to pass contextual data into routeless engines at
runtime, allowing individual engines to be used multiple times through a single
application under different contexts.</p>
<p>An example could be a dashboard of charts where each chart is a routeless engine.
Each chart could be of a different type and would require different data. This
RFC would enable the following:</p>
<pre><code class="language-hbs">{{!-- app/templates/application.hbs --}}
{{#each charts as |chart|}}
  {{mount &quot;chart&quot; type=chart.type data=chart.data}}
{{/each}}
</code></pre>
<a class="header" href="print.html#detailed-design-27" id="detailed-design-27"><h1>Detailed design</h1></a>
<p>You can see the implementation for this RFC <a href="https://github.com/emberjs/ember.js/pull/15174">here</a>.</p>
<p>Implementing this functionality turns out to be relatively straight forward. With
routeless engines already supporting an application controller, we can use this
as a means of providing access to the parameters.</p>
<p>Parameters would be passed to the <code>{{mount}}</code> syntax in the same way that
they are currently passed to components and helpers.</p>
<pre><code class="language-hbs">{{mount &quot;foo&quot; bar=&quot;baz&quot;}}
</code></pre>
<p>These parameters would then be set as the <code>model</code> property on the engines
application controller; making them accessible from both a JS and HBS context.</p>
<pre><code class="language-js">// foo/controllers/application.js
import Ember from 'ember';

export default Ember.Controller.extend({

  actions: {
    exampleAction() {
      let barParam = this.get(&quot;model.bar&quot;);
    }
  }

});
</code></pre>
<pre><code class="language-hbs">{{!-- foo/templates/application.hbs --}}
The value of the bar param is: {{model.bar}}
</code></pre>
<a class="header" href="print.html#how-we-teach-this-13" id="how-we-teach-this-13"><h1>How We Teach This</h1></a>
<p>This RFC re-uses concepts that are already heavily used throughout other areas
of the framework.</p>
<p>Updates will need to be made to the Ember API docs and <a href="http://ember-engines.com">ember-engines.com</a> guides in order to explain that
routeless engines can now accept parameters being passed via the <code>{{mount}}</code> syntax.</p>
<p>In addition, updates would need to include examples of both how to pass parameters
to <code>{{mount}}</code> as well as how any passed parameters can be accessed from within
the context of an engine.</p>
<a class="header" href="print.html#drawbacks-31" id="drawbacks-31"><h1>Drawbacks</h1></a>
<a class="header" href="print.html#increased-risk-of-runtime-dependencies-a-hrefhttpsgithubcomember-enginesember-enginesissues98issuecomment-217347193referencea" id="increased-risk-of-runtime-dependencies-a-hrefhttpsgithubcomember-enginesember-enginesissues98issuecomment-217347193referencea"><h3>Increased risk of runtime dependencies [<a href="https://github.com/ember-engines/ember-engines/issues/98#issuecomment-217347193">reference</a>]</h3></a>
<p>This RFC does increase the risk of introducing runtime dependencies.</p>
<p>Example:</p>
<pre><code class="language-js">import Ember from 'ember';

export default Ember.Component.extend({
  geo: Ember.inject.service('geolocation')
})
</code></pre>
<pre><code class="language-hbs">{{mount &quot;blog&quot; (hash geo=geo)}}
</code></pre>
<a class="header" href="print.html#alternatives-31" id="alternatives-31"><h1>Alternatives</h1></a>
<a class="header" href="print.html#application-route-model-hook" id="application-route-model-hook"><h3>Application route <code>model</code> hook</h3></a>
<p>This solution suggested that the parameters were provided to the engines
application route via the <code>model</code> hooks <code>params</code> argument. While viable,
this solution didn't <em>feel</em> quite right as you were using a route within a <em>routeless</em>
engine.</p>
<a class="header" href="print.html#introduction-of-new-routelessengine-primitive" id="introduction-of-new-routelessengine-primitive"><h3>Introduction of new <code>routelessEngine</code> primitive</h3></a>
<p>This solution suggested that routeless engines should be given their own primitive
similar to that of a component. The primitive would follow a construct to
components and use the same hooks <code>(e.g., didReceiveAttrs)</code> for working with
parameters.</p>
<p>This solution was decided against for following main reasons:</p>
<ol>
<li>The current public API is that we use <code>application</code> controller to back the
<code>application.hbs</code> of a route-less engine.  Adding a new conceptual primitive
here would be a fairly difficult change without breakage.</li>
<li>Introducing a new primitive (e.g. not controller and not a component) is a
<em>very</em> heavy handed thing, and should not be taken lightly. We don't think this
rises to that level of need.</li>
<li>This is an ideal case for &quot;just using a component&quot;, but that would be roughly
akin to &quot;routable components&quot; and we should follow Ember's lead.  When routeable
components are introduced, we can refactor this in the same way with the same
backwards compatibility guarantees.</li>
</ol>
<a class="header" href="print.html#unresolved-questions-25" id="unresolved-questions-25"><h1>Unresolved questions</h1></a>
<a class="header" href="print.html#positional-parameters" id="positional-parameters"><h3>Positional parameters</h3></a>
<p>In addition to supporting named parameters, should the <code>{{mount}}</code> syntax also
support positional parameters? If so, should this be covered in this RFC, or
in a follow up RFC?</p>
<ul>
<li>Start Date: 2017-05-05</li>
<li>RFC PR: https://github.com/emberjs/rfcs/pull/226</li>
<li>Ember Issue: (leave this empty)</li>
</ul>
<a class="header" href="print.html#summary-32" id="summary-32"><h1>Summary</h1></a>
<p>Introduce syntax for passing in multiple named template blocks into a component, and
unify the rendering syntaxes / semantics for
blocks/primitives/component-factories passed into a component.</p>
<p>This RFC is focused chiefly on bringing named blocks to Ember Components,
but it was necessary to define a basic roadmap of functionality for
Glimmer Components as well, but keep in mind that some of the Glimmer-centric details may
change and should hence be considered non-normative.</p>
<a class="header" href="print.html#motivation-33" id="motivation-33"><h1>Motivation</h1></a>
<p>There are limitations to composition due to the inability to pass more than one block to a component (or 2 blocks if you include the inverse block).</p>
<p>The result of this is that Ember developers have this ultra-powerful, compositional API for overriding portions of a component, but they can only use it in one place in the component invocation; any remaining overrides/configuration needs to be expressed as data and passed in as attributes to the component when it'd be vastly preferable to just pass in a chunk of DOM.</p>
<p>Example:</p>
<pre><code class="language-html">{{#x-modal headerText=page.title as |c|}}
  &lt;p&gt;Modal Content {{foo}}&lt;/p&gt;
  &lt;button onclick={{c.close}}&gt;
     Close modal
  &lt;/button&gt;
{{/x-modal}}
</code></pre>
<p>This works, but the moment you need to render a component in the header (rather than just <code>headerText</code>), you end up having to add more config/data/attrs to <code>x-modal</code> just to support every one of those overrides, when really you just should be able to pass in another block of DOM to define what the header looks like. The API in this proposal would allow you to express this use case via:</p>
<pre><code class="language-html">{{#x-modal}}
  &lt;@header as |c|&gt;
    {{page.title}}
    {{status-indicator status=status}}
    {{close-button action=c.close}}
  &lt;/@header&gt;

  &lt;@main as |c|&gt;
    &lt;p&gt;Modal Content {{foo}}&lt;/p&gt;
    &lt;button onclick={{c.close}}&gt;
       Close modal
    &lt;/button&gt;
  &lt;/@main&gt;
{{/x-modal}}
</code></pre>
<p>and with Glimmer components:</p>
<pre><code class="language-html">&lt;x-modal&gt;
  &lt;@header as |c|&gt;
    {{page.title}}
    {{status-indicator status=status}}
    {{close-button action=c.close}}
  &lt;/@header&gt;

  &lt;@main as |c|&gt;
    &lt;p&gt;Modal Content {{foo}}&lt;/p&gt;
    &lt;button onclick={{c.close}}&gt;
       Close modal
    &lt;/button&gt;
  &lt;/@main&gt;
&lt;/x-modal&gt;
</code></pre>
<p>Other RFCs/addons that have attempted to address this:</p>
<ul>
<li><a href="https://github.com/emberjs/rfcs/pull/72">named yields</a></li>
<li><a href="https://github.com/emberjs/rfcs/pull/43">multiple yields</a></li>
<li><a href="https://github.com/emberjs/rfcs/pull/193">yet another named yields rfc</a></li>
<li><a href="https://github.com/ciena-blueplanet/ember-block-slots">ember-block-slots</a></li>
<li><a href="https://github.com/knownasilya/ember-named-yields">ember-named-yields</a></li>
<li><a href="https://github.com/emberjs/rfcs/pull/199">local template blocks</a></li>
</ul>
<a class="header" href="print.html#detailed-design-28" id="detailed-design-28"><h1>Detailed design</h1></a>
<a class="header" href="print.html#invocation-syntax-is-separate-from-component-type" id="invocation-syntax-is-separate-from-component-type"><h2>Invocation Syntax is separate from Component type</h2></a>
<p>The features specified in this RFC require us to nail down
some specifics as to how Ember and
Glimmer components interop, which syntaxes can be used to render
them, and the mental/teaching model behind how it all works.</p>
<ul>
<li>Invocation Syntax (curly vs angle brackets) is conceptually separate from Component
type (Ember vs Glimmer component)</li>
<li>&quot;Curly Components&quot; is a misnomer since curly syntax can render both Ember
components AND Glimmer components</li>
<li>Angle-bracket syntax can only render Glimmer components</li>
<li><code>{{x-foo @k=v}}</code> will remain invalid curly syntax due to the <code>@k=v</code></li>
<li>The way KV pairs provided at invocation is handled depends on the
component type:
<ul>
<li>Given <code>{{x-foo k=v}}</code>, Ember Component <code>x-foo</code> will assign/bind <code>v</code>
to property <code>k</code> on the component instance, which can be rendered
within the component layout template as <code>{{k}}</code> (same behavior as always).
<code>{{@k}}</code> in an Ember component layout will remain a syntax error</li>
<li>Given <code>{{x-foo k=v}}</code>, Glimmer Component <code>x-foo</code> treats <code>k=v</code> as
assigning/binding arg <code>@k</code> to <code>v</code>; it will assign/bind <code>this.args.k</code>, and expose
the value as <code>{{@k}}</code> within the template. This example invocation
is functionally equivalent to <code>&lt;x-foo @k={{v}} /&gt;</code></li>
<li>The mental model is that with curly syntax, <code>k=v</code> is the syntax
for &quot;passing data&quot; to a component; Ember components receive/expose
this data via the properties on the component instance, and Glimmer
components receive the data as <code>@arg</code>s.</li>
</ul>
</li>
<li>Curly syntax will not be enhanced with syntax for passing HTML attrs
(at this time)</li>
<li>Angle-bracket syntax does not support passing positional params</li>
</ul>
<p>Implementation-wise, these varying semantics will be defined/implemented via
<a href="https://github.com/emberjs/rfcs/blob/custom-components/text/0000-custom-components.md#componentmanager">Component Managers</a>.</p>
<a class="header" href="print.html#multi-block-syntax" id="multi-block-syntax"><h2>Multi-block Syntax</h2></a>
<p>Both curly and angle-bracket component invocation syntax will be enhanced
with a nested syntax for passing multiple blocks into a component.</p>
<p>The syntax for curly invocation is as follows:</p>
<pre><code class="language-html">{{#x-foo}}
  &lt;@header&gt;
    Howdy.
  &lt;/@header&gt;

  &lt;@body as |foo|&gt;
    Body {{foo}}
  &lt;/@body&gt;
{{/x-foo}}
</code></pre>
<p>and for angle-bracket invocation:</p>
<pre><code class="language-html">&lt;x-foo&gt;
  &lt;@header&gt;
    Howdy.
  &lt;/@header&gt;

  &lt;@body as |foo|&gt;
    Body {{foo}}
  &lt;/@body&gt;
&lt;/x-modal&gt;
</code></pre>
<p>As demonstrated above, the <em>nested</em> syntax for both curly and
angle-bracket multi-block syntax has the format <code>&lt;@blockName&gt;...&lt;/@blockName&gt;</code>.</p>
<p>This multi-block syntax cannot be mixed with other syntaxes; either ALL
the nested &quot;children&quot; of a component invocation need to be
<code>&lt;@blockName&gt;...&lt;/@blockName&gt;</code> (multi-block syntax), or none of them do
(classic single-block syntax). The presence of any non-whitespace
character between or around <code>&lt;@blockName&gt;...&lt;/@blockName&gt;</code>s is a
compile-time error.</p>
<p>Passing two blocks with the same name is a compiler error (though this
might be relaxed in a future RFC).</p>
<a class="header" href="print.html#blocks-are-just-opaque-data" id="blocks-are-just-opaque-data"><h3>Blocks are just (opaque) data</h3></a>
<p>This RFC introduces the concept that blocks are just opaque values
passed into components as data, rather than living in what is
essentially a separate namespace only accessible to <code>{{yield}}</code>.</p>
<p>In the above example (with curly syntax), Ember Component <code>x-foo</code> would
have its <code>header</code> and <code>body</code> properties set on its instance. This means,
among other things, that there's no need for a
<a href="https://github.com/emberjs/rfcs/pull/102">hasBlock API for JavaScript</a>;
you can just use normal property lookup / computed properties / etc to
determine whether a block is provided. This means that blocks can
be stashed on services and rendered elsewhere, e.g. the
<a href="https://github.com/emberjs/rfcs/pull/226#issuecomment-299949000">ember-elsewhere use case</a>.</p>
<a class="header" href="print.html#unified-renderable-syntax" id="unified-renderable-syntax"><h3>Unified Renderable Syntax</h3></a>
<p>Rather than continuing to enhance the <code>{{yield}}</code> syntax, we should take
this opportunity to unify the various syntaxes for rendering things,
from blocks to primitive values to component factories.</p>
<p>We'll use the following example component invocation to explore
what this syntax looks like: the following (curly syntax) invocation is valid syntax for
rendering either an Ember.Component or a Glimmer Component named
<code>x-modal</code> and passing it 3 named blocks: <code>header</code>, <code>body</code>, and <code>footer</code>:</p>
<pre><code class="language-html">{{#x-modal}}
  &lt;@header as |title|&gt;
    Header {{title}}
  &lt;/@header&gt;

  &lt;@body&gt;
    Body
  &lt;/@body&gt;

  &lt;@footer&gt;
    Footer
  &lt;/@footer&gt;
{{/x-modal}}
</code></pre>
<p>Given the above invocation, here's how you could render these blocks:</p>
<pre><code>{{! within ember-component layout }}
{{this.header &quot;ima title&quot;}}
{{this.body}}
{{this.footer}}

{{! within glimmer-component layout }}
{{@header &quot;ima title&quot;}}
{{@body}}
{{@footer}}
</code></pre>
<p>Both of these Ember/Glimmer layouts would render:</p>
<pre><code>Header ima title
Body
Footer
</code></pre>
<p>The mental modal here is that is that for ECs, named blocks are
set/bound as a properties on the instance, which we're rendering the
same way we always rendering properties on the instance. For GCs, blocks
are just args that we're rendering with the standard @arg syntax</p>
<a class="header" href="print.html#why-thisheader-and-not-just-header" id="why-thisheader-and-not-just-header"><h4>Why <code>{{this.header}}</code> and not just <code>{{header}}</code>?</h4></a>
<p>Unfortunately, we are constrained by the fact that <code>{{foo}}</code> means:</p>
<ul>
<li>Try and find a helper named <code>foo</code>, and render it</li>
<li>If no such helper exists, fall back to rendering property <code>foo</code>
on the template context</li>
</ul>
<p>There is a risk that still exists today that any time you introduce a
new helper to your codebase, for example, a <code>time</code> helper, you will break any
templates that try to render a <code>time</code> property via <code>{{time}}</code>. This is
an unfortunate hangover from the past, and we don't want to continue to
expand the scope of this footgun with this RFC. Hence, to render
blocks/component factories, you must use <code>{{this.time}}</code> in your Ember
Component templates.</p>
<p>This is actually an extension to behavior introduced by the
<a href="https://github.com/emberjs/rfcs/blob/master/text/0064-contextual-component-lookup.md">Contextual Component Lookup
RFC</a>;
today, the following is supported:</p>
<pre><code class="language-hbs">&lt;!-- invocation --&gt;
{{x-foo header=(component 'x-header')}}
</code></pre>
<pre><code class="language-hbs">&lt;!-- x-foo layout --&gt;
{{this.header}}
</code></pre>
<p>In the above example, <code>{{this.header}}</code> will actually render the
<code>x-header</code> component factory; this RFC merely proposes extending this
syntax so that it can render blocks as well.</p>
<p>Since the potential for forgetting this rule is somewhat high, we
should consider detecting when you use <code>{{foo}}</code> syntax when <code>foo</code> is a
component factory or a block, and provide a useful warning or error
message to use <code>{{this.foo}}</code> instead.</p>
<a class="header" href="print.html#rendering-primitives" id="rendering-primitives"><h4>Rendering primitives</h4></a>
<p>Consider the following example, which modifies above example by changing
the <code>footer</code> block to a string:</p>
<pre><code class="language-html">{{#x-modal footer=&quot;ima footer&quot;}}
  &lt;@header as |title|&gt;
    Header {{title}}
  &lt;/@header&gt;
{{/x-modal}}
</code></pre>
<p>If <code>x-modal</code> renders footer via <code>{{this.footer}}</code>, then it'll just
render the &quot;ima footer&quot; string just fine; this a nice benefit of having
a Unified Renderable syntax
and supports a common workflow where string args can be promoted
to full-on blocks without having to rework the component code
to support an alternative/parallel API.</p>
<a class="header" href="print.html#call-syntax-with-primitives-or-undefined" id="call-syntax-with-primitives-or-undefined"><h4>Call syntax with primitives (or undefined)</h4></a>
<p>If you try to render a block/component with args, e.g. <code>{{this.foo 1 2 3}}</code>,
then <code>foo</code> MUST be a block or a component. If <code>foo</code> is any kind of
non-callable primitive, including undefined, it will be an error.</p>
<a class="header" href="print.html#unified-renderable-syntax-component-factories" id="unified-renderable-syntax-component-factories"><h4>Unified Renderable Syntax: component factories</h4></a>
<p>The following invocation using component factories is also supported:</p>
<pre><code class="language-html">{{#x-modal
     header=(component 'my-modal-header')
     footer=(component 'my-modal-footer')}}
  &lt;@main&gt;
    Main
  &lt;/@main&gt;
{{/x-modal}}
</code></pre>
<p>(It's worth mentioning that since we're only defining the <code>main</code> block
here, this could also be expressed simply as:)</p>
<pre><code class="language-html">{{#x-modal
     header=(component 'my-modal-header')
     footer=(component 'my-modal-footer')}}
  Main
{{/x-modal}}
</code></pre>
<p>This demonstrates that the unified renderable syntax is also capable of
rendering component factories (previously only renderable via
<code>{{component header}}</code>).</p>
<p>Note since we're passing a positional param <code>&quot;ima title&quot;</code> to <code>header</code>,
the <code>my-modal-header</code> component would only be able to access that param if it were
using the <code>positionalParams</code> API with (<code>reopenClass</code>), which is a bit of
a clunky / pro-user API.</p>
<p>As a component author, if you want to write your components to support
passing data to both blocks (which accept positional params) and
components (which accept KV pairs), you can pass in both formats
of the same data, e.g.:</p>
<pre><code>// Ember.component layout
{{this.header headerTitle title=headerTitle}}

// Glimmer Component layout
{{@header headerTitle title=headerTitle}}
</code></pre>
<a class="header" href="print.html#named-block-params" id="named-block-params"><h4>Named block params</h4></a>
<p>Prior to this RFC, there were only two ways to pass in overridable
chunks of DOM to a component:</p>
<ul>
<li>Passing in a block, which only accepts positional block params
(or a <code>(hash)</code> object of named params)</li>
<li>Passing in a component factory, which only accepts KV args (unless
you use the <code>reopenClass-positionalParams</code> api)</li>
</ul>
<p>Given that we're introducing a Unified Renderable syntax, it would be
unfortunate if we did nothing to address this impedance mismatch between
named and positional params. The goal is for component consumers/invokers to
be able to pass the most &quot;convenient&quot; kind of Renderable for their use
case, be it a simple primitive string value, a block if they want the
lexical scope + block params, or a component factory for rendering
a shared component that might be used in many places throughout the app.
Unfortunately, the component author will have to choose whether they
want to pass positional params (which would push consumers towards
only using  blocks) or named params (which are presently only supported
by component factories).</p>
<p>Hence, for this reason (among others), it makes sense to introduce a
syntax for named block params; with this syntax, there will be an
organic shift towards component authors using named KV pairs for passing
data in most cases (while still allowing positional params in certain
simpler cases were it only really makes sense to use a block, e.g.
control flow components that wrap <code>if</code> or <code>each</code>, etc.)</p>
<p>Here is the syntax for named block params:</p>
<pre><code class="language-html">{{#x-modal}}
  &lt;@header as |@title @data|&gt;
    The title: {{@title}}
    The data: {{@data}}
  &lt;/@header&gt;
{{/x-modal}}
</code></pre>
<p>There is also a &quot;soaking&quot; syntax which is useful in cases where nested
blocks might introduce new named block params that clobber preexisting
identifiers in the scope, as well as cases where spelling out each
named block param consumes too much rightward space. The above example
can be expressed using the soaking syntax as follows:</p>
<pre><code class="language-html">{{#x-modal}}
  &lt;@header as |@...d|&gt;
    The title: {{d.title}}
    The data: {{d.data}}
  &lt;/@header&gt;
{{/x-modal}}
</code></pre>
<p>(The <code>@</code> is not included as part of the identifier as that would
suggest it was a KV arg rather than essentially a hash of args.)</p>
<a class="header" href="print.html#block-form-of-unified-renderable-syntax" id="block-form-of-unified-renderable-syntax"><h4>Block form of Unified Renderable syntax</h4></a>
<p>It should be possible to pass a block TO the
block/component-factory that's been passed into a component.
The common use cases for this are:</p>
<a class="header" href="print.html#passing-a-block-to-a-component-factory" id="passing-a-block-to-a-component-factory"><h5>Passing a block to a component factory</h5></a>
<p>Given the following invocation:</p>
<pre><code>{{x-modal header=(component 'my-header')}}
</code></pre>
<p>It should be possible for <code>x-modal</code> to pass a block to the <code>header</code>
renderable:</p>
<pre><code>// ember-component x-modal layout
{{#this.header title=&quot;ima title&quot;}}
  I'm a block provided by the component layout template.
{{/this.header}}
</code></pre>
<p>Assuming <code>my-header</code> had a layout of:</p>
<pre><code>&lt;div class=&quot;my-header-inner&quot;&gt;
  title is {{title}}
  {{yield}}
&lt;/div&gt;
</code></pre>
<p>This would render the following (assuming <code>x-modal</code> and <code>my-header</code> are
Ember components with <code>tagName: 'div'</code> with <code>classNames</code> set):</p>
<pre><code>&lt;div class=&quot;x-modal&quot;&gt;
  &lt;div class=&quot;my-header&quot;&gt;
    &lt;div class=&quot;my-header-inner&quot;&gt;
      title is ima title
      I'm a block provided by the component layout template.
    &lt;/div&gt;
  &lt;/div&gt;
&lt;/div&gt;
</code></pre>
<a class="header" href="print.html#passing-a-block-to-a-block-aka-contextual-components" id="passing-a-block-to-a-block-aka-contextual-components"><h5>Passing a block to a block (aka contextual components)</h5></a>
<p>Given the following invocation:</p>
<pre><code>{{#x-modal}}
  &lt;@header as |@title @main|&gt;
    &lt;div class=&quot;header-block-content&quot;&gt;
      title is {{@title}}
      {{@main}}
    &lt;/div&gt;
  &lt;/header&gt;
{{/x-modal}}
</code></pre>
<p>This would render the following (assuming the same <code>x-modal</code> layout
as the previous example:</p>
<pre><code>&lt;div class=&quot;x-modal&quot;&gt;
  &lt;div class=&quot;header-block-content&quot;&gt;
    title is ima title
    I'm a block provided by the component layout template.
  &lt;/div&gt;
&lt;/div&gt;
</code></pre>
<p>It would also be possible to pass a component factory to the header
block from <code>x-modal</code>'s layout:</p>
<pre><code>// ember-component x-modal layout
{{this.header title=&quot;ima title&quot;
         main=(component 'x-modal-inner-content')}}
</code></pre>
<p>The multi-block syntax can be used as well with Unified Renderable
syntax:</p>
<pre><code>{{#header}}
  &lt;@main&gt;
    I'm a block provided by the component layout template.
  &lt;/@main&gt;

  &lt;@title&gt;
    ima title
  &lt;/@title&gt;
{{/header}}
</code></pre>
<a class="header" href="print.html#block-form-of--prefixed-identifiers" id="block-form-of--prefixed-identifiers"><h5>Block form of <code>@</code>-prefixed identifiers</h5></a>
<p>The syntax for passing a block to an <code>@</code>-prefixed identifier
(named block params and Glimmer <code>@arg</code>s) will be
<code>{{#@thing}} ... {{/@thing}}</code>, e.g.:</p>
<pre><code>{{#x-layout as |@widget|}}
  {{#@widget as |a b c|}}
    Hi.
  {{/@widget}}
{{/x-layout}}
</code></pre>
<a class="header" href="print.html#classic-single-block-syntax-main-and-else-args" id="classic-single-block-syntax-main-and-else-args"><h3>Classic single-block syntax: <code>main</code> and <code>else</code> args</h3></a>
<p>It would be unfortunate if component authors had to use different
syntaxes for rendering named blocks vs the traditional &quot;default&quot;
and &quot;inverse&quot; blocks provided by the classic single-block syntax.</p>
<p>Hence, the blocks provided in classic single-block syntax should also
be exposed as properties (Ember) and args (Glimmer), and should have
conventional, meaningful names: instead of &quot;default&quot; (which is a
bit misleading) and &quot;inverse&quot;, we standardize on <code>main</code> and <code>else</code>.</p>
<a class="header" href="print.html#glimmer-components-main-and-else" id="glimmer-components-main-and-else"><h4>Glimmer Components: <code>@main</code> and <code>@else</code></h4></a>
<p>Given Glimmer component invocation:</p>
<pre><code>{{#fancy-if cond=trueOrFalse}}
  True
{{else}}
  False
{{/fancy-component}}
</code></pre>
<p>The component layout could be:</p>
<pre><code>{{#if cond}}
  {{@main}}
{{else}}
  {{@else}}
{{/if}}
</code></pre>
<p>Note that angle-bracket syntax doesn't support passing in an
inverse/else block, but the block provided to angle-bracket invocation
would be passed in as <code>@main</code>.</p>
<a class="header" href="print.html#ember-components-main-and-else" id="ember-components-main-and-else"><h4>Ember Components: <code>main</code> and <code>else</code></h4></a>
<p>For Ember, we can't suddenly start setting <code>main</code> and <code>else</code> properties
on the component instances as this would be a breaking change, and
<code>main</code> in particular is not an uncommon property name.</p>
<p>We also shouldn't punt on this feature for Ember components for the
following reasons/use cases:</p>
<ul>
<li><a href="https://github.com/emberjs/rfcs/pull/226#issuecomment-299949000">ember-elsewhere</a>
(and other similar patterns) require having access to the opaque block
so that it can be stashed on a service and rendered elsewhere</li>
<li>wrapper components that forward args/properties/blocks to another
internal component; blocks need to be accessible as properties in order
to pass them into another component (otherwise you'd have to use a
combinatoric mess of block syntax + <code>if hasBlock</code> checks to forward
blocks through to the inner component)</li>
</ul>
<p>So we need an opt-in API; any Ember Component that wants <code>main</code>/<code>else</code>
properties to be set on the component instance need to opt into this
behavior via a mixin provided by Ember:</p>
<pre><code>import { ImplicitBlockPropertyMixin } from &quot;@ember/implicit-block-property-support&quot;;

export default Ember.Component.extend(ImplicitBlockPropertyMixin, {
  blockManager: inject.service(),
  init() {
    this._super();
    this.get('blockManager').registerBlock(this.get('main'));
  },
});
</code></pre>
<p>So if <code>fancy-if</code> were an Ember component that used this mixin, then
given the component invocation:</p>
<pre><code>{{#fancy-if cond=trueOrFalse}}
  True
{{else}}
  False
{{/fancy-if}}
</code></pre>
<p>The following ember component layout would work:</p>
<pre><code>{{#if cond}}
  {{this.main}}
{{else}}
  {{this.else}}
{{/if}}
</code></pre>
<a class="header" href="print.html#how-we-teach-this-14" id="how-we-teach-this-14"><h1>How We Teach This</h1></a>
<p>We teach this as a followup to classic block syntax; once the user is comfortable with single-block syntax, we can introduce named block syntax for more complex use cases.</p>
<p>We teach that what <code>&lt;@blockName&gt;&lt;/@blockName&gt;</code> syntax really means is
that we're just passing in an arg named <code>@blockName</code>, which is like
any other arg we might pass into a component, but it happens to point
to a template block than, say, some simple string value.</p>
<a class="header" href="print.html#drawbacks-32" id="drawbacks-32"><h1>Drawbacks</h1></a>
<a class="header" href="print.html#different-from-wc-slot-syntax" id="different-from-wc-slot-syntax"><h3>Different from WC slot syntax</h3></a>
<p>This isn't really anything like the
<a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/slot">WebComponents slot syntax</a>
that intends to address similar use cases, so there is some risk of
introducing an API that doesn't fit in with what the rest of the world
is doing.</p>
<a class="header" href="print.html#syntax-highlighting-changes" id="syntax-highlighting-changes"><h3>Syntax highlighting changes</h3></a>
<p>Some syntax highlighters might have trouble with this syntax; all
the editors I've tried it on look reasonable, but GitHub's Handlebars
parser isn't too kind (hence I've been using <code>html</code> snippets instead
of <code>handlebars</code> snippets):</p>
<pre><code class="language-hbs">&lt;x-modal&gt;
  &lt;@header as |c|&gt;
    ...
  &lt;/@header&gt;

  &lt;@main as |c|&gt;
    ...
  &lt;/@main&gt;
&lt;/x-modal&gt;
</code></pre>
<a class="header" href="print.html#conditionally-passing-blocks" id="conditionally-passing-blocks"><h3>Conditionally passing blocks?</h3></a>
<p>This RFC does NOT introduce any kind of facility for conditionally passing
blocks, e.g.:</p>
<pre><code class="language-html">{{! this syntax is INVALID! }}
&lt;x-layout&gt;
  &lt;@header&gt;...&lt;/@header&gt;
  &lt;@main&gt;...&lt;/@main&gt;

  {{#if userCanProceed}}
    &lt;@footer&gt;
      {{submit-button}}
    &lt;/@footer&gt;
  {{/if}}
&lt;/x-layout&gt;
</code></pre>
<p>This might be desirable in the future, particularly for use cases
involving flex-ish layouts where the component changes behavior /
appearance based on whether blocks on passed in.</p>
<a class="header" href="print.html#alternatives-32" id="alternatives-32"><h1>Alternatives</h1></a>
<p>I'd proposed a JSX-y <a href="https://github.com/emberjs/rfcs/pull/203">attr/component-centric</a> syntax for passing what are essentially DOM lambdas, rendered with <code>{{component}}</code>. Perhaps we'll add something like that feature in the future, but it's a much less natural enhancement to Ember than named blocks.</p>
<a class="header" href="print.html#considerations-for-future-rfcs" id="considerations-for-future-rfcs"><h1>Considerations for Future RFCs</h1></a>
<a class="header" href="print.html#defining-default-blocks" id="defining-default-blocks"><h2>Defining Default Blocks</h2></a>
<p>There's not really a nice way defining default blocks inside your
component layout (i.e. the block you render when known is provided at
invocation time), but then again I believe the following would be
a workable approach that is probably support by the features proposed in
this RFC?</p>
<pre><code>{{#with-blocks}}
  &lt;@mainOrDefault&gt;
    {{#if main}}
      {{main}}
    {{else}}
      I am the default main block when none is passed in.
    {{/if}}
  &lt;/@mainOrDefault&gt;

  &lt;@footerOrDefault&gt;
    {{#if footer}}
      {{footer}}
    {{else}}
      I am the default footer block when none is passed in.
    {{/if}}
  &lt;/@footerOrDefault&gt;

  &lt;@render as |@mainOrDefault @footerOrDefault|&gt;
    {{! this specially-named block gets passed all the other blocks above}}

    {{mainOrDefault}}
    {{footerOrDefault}}
  &lt;/@render&gt;
{{/with-blocks}}
</code></pre>
<p>Either way, it feels hacky and weird and I would be surprised if we'd
want/need a future RFC to define a nicer way to support default blocks.</p>
<a class="header" href="print.html#allow-passing-multiple-blocks-with-the-same-name" id="allow-passing-multiple-blocks-with-the-same-name"><h2>Allow passing multiple blocks with the same name</h2></a>
<p>e.g.</p>
<pre><code class="language-html">{{#power-select}}
  &lt;@option value=&quot;foo&quot;&gt;
    &lt;em&gt;Foo&lt;/em&gt;
  &lt;/@option&gt;
  &lt;@option value=&quot;bar&quot;&gt;
    &lt;blink&gt;Bar&lt;/blink&gt;
  &lt;/@option&gt;
{{/power-select}}
</code></pre>
<p>This RFC defines that passing multiple blocks with the same name is a
syntax error, but it's something we might want to relax in the future
for certain cases where you want to pass arrays of blocks, such as
<code>power-select</code> or use cases involving tables.</p>
<ul>
<li>Start Date: 2017-06-11</li>
<li>RFC PR: <a href="https://github.com/emberjs/rfcs/pull/229">emberjs/rfcs#229</a></li>
<li>Ember Issue: (leave this empty)</li>
</ul>
<a class="header" href="print.html#summary-33" id="summary-33"><h1>Summary</h1></a>
<p>In order to largely reduce the brittleness of tests, this RFC proposes to
remove the concept of artificially restricting the resolver used under
testing.</p>
<a class="header" href="print.html#motivation-34" id="motivation-34"><h1>Motivation</h1></a>
<p>Disabling the resolver while running tests leads to extremely brittle tests.</p>
<p>It is not possible for collaborators to be added to the object (or one
of its dependencies) under test, without modifying the test itself (even if
exactly the same API is exposed).</p>
<p>The ability to restrict the resolver is <strong>not</strong> actually a feature of Ember's
container/registry/resolver system, and has posed as significant maintenance
challenge throughout the lifetime of ember-test-helpers.</p>
<p>Removing this system of restriction will make choosing what kind of test to
be used easier, simplify many of the blueprints, and enable much simpler refactoring
of an applications components/controllers/routes/etc to use collaborating utilties
and services.</p>
<a class="header" href="print.html#transition-path-5" id="transition-path-5"><h1>Transition Path</h1></a>
<a class="header" href="print.html#deprecate-functionality" id="deprecate-functionality"><h2>Deprecate Functionality</h2></a>
<p>Issue a deprecation if <code>integration: true</code> is not included in the specified
options for the APIs listed below. This specifically includes specifying
<code>unit: true</code>, <code>needs: []</code>, or specifying none of the &quot;test type options&quot;
(<code>unit</code>, <code>needs</code>, or <code>integration</code> options) to the following <code>ember-qunit</code>
and <code>ember-mocha</code> API's:</p>
<ul>
<li><code>ember-qunit</code>
<ul>
<li><code>moduleFor</code></li>
<li><code>moduleForComponent</code></li>
<li><code>moduleForModel</code></li>
</ul>
</li>
<li><code>ember-mocha</code>
<ul>
<li><code>setupTest</code></li>
<li><code>setupComponentTest</code></li>
<li><code>setupModelTest</code></li>
</ul>
</li>
</ul>
<a class="header" href="print.html#non-component-test-apis" id="non-component-test-apis"><h3>Non Component Test APIs</h3></a>
<p>The migration path for <code>moduleFor</code>, <code>moduleForModel</code>, <code>setupTest</code>, and
<code>setupModelTest</code> is very simple:</p>
<pre><code class="language-js">// ember-qunit

// before
moduleFor('service:session');

moduleFor('service:session', {
  unit: true
});

moduleFor('service:session', {
  needs: ['type:thing']
});

// after
moduleFor('service:session', {
  integration: true
});
</code></pre>
<pre><code class="language-js">// ember-mocha

// before
describe('Session Service', function() {
  setupTest('service:session');
  
  // ...snip...
});

describe('Session Service', function() {
  setupTest('service:session', { unit: true });
  
  // ...snip...
});

describe('Session Service', function() {
  setupTest('service:session', { needs: [] });
  
  // ...snip...
});

// after

describe('Session Service', function() {
  setupTest('service:session', { integration: true });
  
  // ...snip...
});
</code></pre>
<p>The main change is adding <code>integration: true</code> to options (and removing <code>unit</code> or <code>needs</code>
if present).</p>
<a class="header" href="print.html#component-test-apis" id="component-test-apis"><h3>Component Test APIs</h3></a>
<p>Implicitly relying on &quot;unit test mode&quot; has been deprecated for quite some time
(<a href="https://github.com/emberjs/ember-test-helpers/pull/38">introduced 2015-04-07</a>),
so all consumers of <code>moduleForComponent</code> and <code>setupComponentTest</code> are specifying
one of the &quot;test type options&quot; (<code>unit</code>, <code>needs</code>, or <code>integration</code>).</p>
<p>This RFC proposes to deprecate completely using <code>unit</code> or <code>needs</code> options with
<code>moduleForComponent</code> and <code>setupComponentTest</code>. The vast majority of component tests
should be testing via <code>moduleForComponent</code> / <code>setupComponentTest</code> with the <code>integration: true</code>
option set, but on some rare occaisions it is easier to use the &quot;unit test&quot; style is
desired (e.g. non-rendering test) these tests should be migrated to using <code>moduleFor</code>
/ <code>setupTest</code> directly.</p>
<pre><code class="language-js">// ember-qunit

// before
moduleForComponent('display-page', {
  unit: true
});

moduleForComponent('display-page', {
  needs: ['type:thing']
});

// after

moduleFor('component:display-page', {
  integration: true
});
</code></pre>
<pre><code class="language-js">// ember-mocha
describe('DisplayPageComponent', function() {
  setupComponentTest('display-page', { unit: true });
  
  // ...snip...
});

describe('DisplayPageComponent', function() {
  setupComponentTest('display-page', { needs: [] });
  
  // ...snip...
});

// after

describe('DisplayPageComponent', function() {
  setupTest('component:display-page', { integration: true });
  
  // ...snip...
});
</code></pre>
<a class="header" href="print.html#ecosystem-updates" id="ecosystem-updates"><h2>Ecosystem Updates</h2></a>
<p>The blueprints in all official projects (and any provided by popular
addons) will need to be updated to avoid triggering a deprecation.</p>
<p>This includes:</p>
<ul>
<li><code>ember-source</code></li>
<li><code>ember-data</code></li>
<li><code>ember-cli-legacy-blueprints</code></li>
<li>Others?</li>
</ul>
<a class="header" href="print.html#remove-deprecated-unit--needs-options" id="remove-deprecated-unit--needs-options"><h2>Remove Deprecated <code>unit</code> / <code>needs</code> Options</h2></a>
<p>Once the changes from this RFC are made, we will be able to remove
support for the <code>unit</code> and <code>needs</code> options from <code>ember-test-helpers</code>,
<code>ember-qunit</code>, and <code>ember-mocha</code>. This would be a &quot;semver major&quot;
version bump for all of the related libraries to properly signal that
functionality was removed.</p>
<p>Once the underlying libraries have done a major version bump, we will
introduce a deprecation for using the <code>integration</code> option. This
deprecation would be issued once for the entire test suite (not once
per test module which has <code>integration</code> passed in). We will also update
the blueprints to remove the extraneous <code>integration</code> option.</p>
<a class="header" href="print.html#how-we-teach-this-15" id="how-we-teach-this-15"><h1>How We Teach This</h1></a>
<p>This RFC would require an audit of the main Ember.js guides to ensure
that all usages of the APIs in question continue to be non-deprecated
valid usages.</p>
<a class="header" href="print.html#drawbacks-33" id="drawbacks-33"><h1>Drawbacks</h1></a>
<a class="header" href="print.html#churn" id="churn"><h2>Churn</h2></a>
<p>One drawback to this deprecation proposal is the churn associated with
modifying the options passed for each test. This can almost certainly
be mitigated by providing a codemod to enable automated updating.</p>
<p>There are additional changes being entertained that would require changes
for the default testing blueprints, we should ensure that these RFCs do not
conflict or cause undue churn/pain.</p>
<a class="header" href="print.html#integration-true-confusion" id="integration-true-confusion"><h2><code>integration: true</code> Confusion</h2></a>
<p>Prior to this deprecation we had essentially 4 options for testing components:</p>
<ul>
<li><code>moduleFor(..., { unit: true })</code></li>
<li><code>moduleFor(..., { integration: true })</code></li>
<li><code>moduleForComponent(..., { unit: true })</code></li>
<li><code>moduleForComponent(..., { integatrion: true })</code></li>
</ul>
<p>With this RFC the option <code>integration</code> no longer provides value (we aren't talking
about &quot;unit&quot; vs &quot;integration&quot; tests), and may be seen as confusing.</p>
<p>I believe that this concern is mitigated by the ultimate removal of the <code>integration</code>
(it is only required in order to allow us a path forward that is compatible with
todays ember-qunit/ember-mocha versions).</p>
<ul>
<li>Start Date: 2017-06-13</li>
<li>RFC PR: <a href="https://github.com/emberjs/rfcs/pull/232">emberjs/rfcs#232</a></li>
<li>Ember Issue: (leave this empty)</li>
</ul>
<a class="header" href="print.html#summary-34" id="summary-34"><h1>Summary</h1></a>
<p>In order to embrace newer features being added by QUnit (our chosen default
testing framework), we need to reduce the brittle coupling between <code>ember-qunit</code>
and QUnit itself.</p>
<p>This RFC proposes a new testing syntax, that will expose QUnit API directly while
also making tests much easier to understand.</p>
<a class="header" href="print.html#motivation-35" id="motivation-35"><h1>Motivation</h1></a>
<p>QUnit feature development has been accelerating since the ramp up to QUnit 2.0.
A number of new features have been added that make testing our applications
much easier, but the current structure of <code>ember-qunit</code> impedes our ability
to take advantage of some of these features.</p>
<p>Developers are often confused by our <code>moduleFor*</code> APIs, questions like these
are very common:</p>
<ul>
<li>What &quot;magic&quot; is <code>ember-qunit</code> doing?</li>
<li>Where are the lines between QUnit and ember-qunit?</li>
<li>How can I use QUnit for plain JS objects?</li>
</ul>
<p>The way that <code>ember-qunit</code> wraps QUnit functionality makes the division
of responsiblity much harder to understand, and leads folks to believe that there
is much more going on in <code>ember-qunit</code> than there is. It should be much clearer
what <code>ember-qunit</code> is responsible for and what we rely on QUnit for.</p>
<p>This RFC also aims to remove a number of custom testing only APIs that exist today
(largely because the container/registry system was completely private when the
current tools were authored). Instead of things like <code>this.subject</code>, <code>this.register</code>,
<code>this.inject</code>, or <code>this.lookup</code> we can rely on the standard way of performing these
functions in Ember via the owner API.</p>
<p>When this RFC has been implemented and rolled out, these questions should all be
addressed and our testing system will both: embrace QUnit much more <strong>and</strong>
be much more framework agnostic, all the while dropping custom testing only APIs
in favor of public APIs that work across tests and app code.</p>
<p>Sounds like a neat trick, huh?</p>
<a class="header" href="print.html#detailed-design-29" id="detailed-design-29"><h1>Detailed design</h1></a>
<p>The primary change being proposed in this RFC is to migrate to using the QUnit
nested module syntax, and update our custom setup/teardown into a more functional
API.</p>
<p>Lets look at a basic example:</p>
<pre><code class="language-js">// **** before ****

import { moduleForComponent, test } from 'ember-qunit';
import hbs from 'htmlbars-inline-precompile';

moduleForComponent('x-foo', {
  integration: true
});

test('renders', function(assert) {
  assert.expect(1);

  this.render(hbs`{{pretty-color name=&quot;red&quot;}}`);

  assert.equal(this.$('.color-name').text(), 'red');
});

// **** after ****

import { module, test } from 'qunit';
import { setupRenderingTest } from 'ember-qunit';
import hbs from 'htmlbars-inline-precompile';

module('x-foo', function(hooks) {
  setupRenderingTest(hooks);

  test('renders', async function(assert) {
    assert.expect(1);

    await this.render(hbs`{{pretty-color name=&quot;red&quot;}}`);

    assert.equal(this.$('.color-name').text(), 'red');
  });
});
</code></pre>
<p>As you can see, this proposal leverages QUnit's nested module API in a way that
makes it much clearer what is going on. It is quite obvious what QUnit is doing
(acting like a general testing framework) and what <code>ember-qunit</code> is doing
(setting up rendering functionality).</p>
<p>This API was heavily influenced by the work that
<a href="https://github.com/Turbo87">Tobias Bieniek</a> did in
<a href="https://github.com/emberjs/ember-mocha/pull/84">emberjs/ember-mocha#84</a>.</p>
<a class="header" href="print.html#qunit-nested-modules-api" id="qunit-nested-modules-api"><h2>QUnit Nested Modules API</h2></a>
<p>Even though it is not a proposal of this RFC, the QUnit nested module
syntax may seem foreign to some folks so lets briefly review.</p>
<p>With nested modules, a normal 1.x QUnit module setup changes from:</p>
<pre><code class="language-js">QUnit.module('some description', {
  before() {},
  beforeEach() {},
  afterEach() {},
  after() {}
});

QUnit.test('it blends', function(assert) {
  assert.ok(true, 'of course!');
});
</code></pre>
<p>Into:</p>
<pre><code class="language-js">QUnit.module('some description', function(hooks) {

  hooks.before(() =&gt; {});
  hooks.beforeEach(() =&gt; {});
  hooks.afterEach(() =&gt; {});
  hooks.after(() =&gt; {});

  QUnit.test('it blends', function(assert) {
    assert.ok(true, 'of course!');
  });
});
</code></pre>
<p>This makes it much simpler to support multiple <code>before</code>, <code>beforeEach</code>, <code>afterEach</code>,
and <code>after</code> callbacks, and it also allows for arbitrary nesting of modules.</p>
<p>You can read more about QUnit nested modules
<a href="http://api.qunitjs.com/QUnit/module#nested-module-nested-hooks-">here</a>. The new APIs
proposed in this RFC expect to be leveraging nested modules.</p>
<a class="header" href="print.html#new-apis" id="new-apis"><h2>New APIs</h2></a>
<p>The following new methods will be exposed from <code>ember-qunit</code>:</p>
<pre><code class="language-ts">interface QUnitModuleHooks {
  before(callback: Function): void;
  beforeEach(callback: Function): void;
  afterEach(callback: Function): void;
  after(callback: Function): void;
}

declare module 'ember-qunit' {
  // ...snip... 
  export function setupTest(hooks: QUnitModuleHooks): void;
  export function setupRenderingTest(hooks: QUnitModuleHooks): void;
}
</code></pre>
<a class="header" href="print.html#setuptest" id="setuptest"><h3><code>setupTest</code></h3></a>
<p>This function will:</p>
<ul>
<li>invoke <code>ember-test-helper</code>s <code>setContext</code> with the tests context</li>
<li>create an owner object and set it on the test context (e.g. <code>this.owner</code>)</li>
<li>setup <code>this.set</code>, <code>this.setProperties</code>, <code>this.get</code>, and <code>this.getProperties</code> to
the test context</li>
<li>setup <code>this.pauseTest</code> and <code>this.resumeTest</code> methods to allow easy pausing/resuming
of tests</li>
</ul>
<a class="header" href="print.html#setuprenderingtest" id="setuprenderingtest"><h3><code>setupRenderingTest</code></h3></a>
<p>This function will:</p>
<ul>
<li>run the <code>setupTest</code> implementation</li>
<li>setup <code>this.$</code> method to run jQuery selectors rooted to the testing container</li>
<li>setup a getter for <code>this.element</code> which returns the DOM element representing
the element that was rendered via <code>this.render</code></li>
<li>setup Ember's renderer and create a <code>this.render</code> method which accepts a
compiled template to render and returns a promise which resolves once rendering
is completed</li>
<li>setup <code>this.clearRender</code> method which clears any previously rendered DOM (
also used during cleanup)</li>
</ul>
<p>When invoked, <code>this.render</code> will render the provided template and return a
promise that resolves when rendering is completed.</p>
<a class="header" href="print.html#changes-from-current-system" id="changes-from-current-system"><h2>Changes from Current System</h2></a>
<p>Here is a brief list of the more important but possibly understated changes
being proposed here:</p>
<ul>
<li>the various setup methods no longer need to know the name of the object under test</li>
<li><code>this.subject</code> is removed in favor of using the standard public API for looking up
and creating instances (<code>this.owner.lookup</code> and <code>this.owner.factoryFor</code>)</li>
<li><code>this.inject</code> is removed in favor of using <code>this.owner.lookup</code> directly</li>
<li><code>this.register</code> is removed in favor of using <code>this.owner.register</code> directly</li>
<li><code>this.render</code> will begin being asynchronous to allow for further iteration in the
underlying rendering engines ability to speed up render times (by yielding back
to the browser and not blocking the main thread)</li>
<li><code>this.pauseTest</code> and <code>this.resumeTest</code> are being added</li>
<li><code>this.element</code> is being introduced as a public API for DOM assertions in a jQuery-less
environment</li>
<li>QUnit nested modules are required</li>
</ul>
<p>These changes generally do not affect our ability to write a codemod to aide in the migration.</p>
<a class="header" href="print.html#migration-examples" id="migration-examples"><h2>Migration Examples</h2></a>
<p>The migration can likely be largely automated (following the
<a href="https://github.com/Turbo87/ember-mocha-codemods">excellent codemod</a> that
<a href="https://github.com/turbo87">Tobias Bieniek</a> wrote for a similar <code>ember-mocha</code>
the transition), but it is still useful to review concrete scenarios
of tests before and after this RFC is implemented.</p>
<a class="header" href="print.html#component--helper-integration-test" id="component--helper-integration-test"><h3>Component / Helper Integration Test</h3></a>
<pre><code class="language-js">// **** before ****

import { moduleForComponent, test } from 'ember-qunit';
import hbs from 'htmlbars-inline-precompile';

moduleForComponent('x-foo', {
  integration: true
});

test('renders', function(assert) {
  assert.expect(1);

  this.render(hbs`{{pretty-color name=&quot;red&quot;}}`);

  assert.equal(this.$('.color-name').text(), 'red');
});

// **** after ****

import { module, test } from 'qunit';
import { setupRenderingTest } from 'ember-qunit';
import hbs from 'htmlbars-inline-precompile';

module('x-foo', function(hooks) {
  setupRenderingTest(hooks);

  test('renders', async function(assert) {
    assert.expect(1);

    await this.render(hbs`{{pretty-color name=&quot;red&quot;}}`);

    assert.equal(this.$('.color-name').text(), 'red');
  });
});
</code></pre>
<a class="header" href="print.html#component-unit-test" id="component-unit-test"><h3>Component Unit Test</h3></a>
<pre><code class="language-js">// **** before ****

import { moduleForComponent, test } from 'ember-qunit';

moduleForComponent('x-foo', {
  unit: true
});

test('computes properly', function(assert) {
  assert.expect(1);

  let subject = this.subject({
    name: 'something'
  });

  let result = subject.get('someCP');
  assert.equal(result, 'expected value');
});

// **** after ****

import { module, test } from 'qunit';
import { setupTest } from 'ember-qunit';

module('x-foo', function(hooks) {
  setupTest(hooks);

  test('computed properly', function(assert) {
    assert.expect(1);

    let Factory = this.owner.factoryFor('component:x-foo');
    let subject = Factory.create({
      name: 'something'
    });

    let result = subject.get('someCP');
    assert.equal(result, 'expected value');
  });
});
</code></pre>
<a class="header" href="print.html#serviceroutecontroller-test" id="serviceroutecontroller-test"><h3>Service/Route/Controller Test</h3></a>
<pre><code class="language-js">// **** before ****

import { moduleFor, test } from 'ember-qunit';

moduleFor('service:flash', 'Unit | Service | Flash', {
  unit: true
});

test('should allow messages to be queued', function (assert) {
  assert.expect(4);
  
  let subject = this.subject();
  
  subject.show('some message here');
  
  let messages = subject.messages;
  
  assert.deepEqual(messages, [
    'some message here'
  ]);
});

// **** after ****

import { module, test } from 'qunit';
import { setupTest } from 'ember-qunit';

module('Unit | Service | Flash', function(hooks) {
  setupTest(hooks);
  
  test('should allow messages to be queued', function (assert) {
    assert.expect(4);
  
    let subject = this.owner.lookup('service:flash');
  
    subject.show('some message here');
  
    let messages = subject.messages;
  
    assert.deepEqual(messages, [
      'some message here'
    ]);
  });
});

</code></pre>
<a class="header" href="print.html#ecosystem-updates-1" id="ecosystem-updates-1"><h2>Ecosystem Updates</h2></a>
<p>The blueprints in all official projects (and any provided by popular addons)
will need to be updated to detect <code>ember-qunit</code> version and emit the correct
output.</p>
<p>This includes:</p>
<ul>
<li>ember-source</li>
<li>ember-data</li>
<li>ember-cli-legacy-blueprints</li>
<li>others?</li>
</ul>
<p>This exact process was done for <code>ember-mocha</code>'s migration, making this a well
trodden path.</p>
<a class="header" href="print.html#update-guides" id="update-guides"><h2>Update Guides</h2></a>
<p>The guides includes a section for testing, this section needs to be reviewed
and revamped to match the proposal here.</p>
<a class="header" href="print.html#deprecate-older-apis" id="deprecate-older-apis"><h2>Deprecate older APIs</h2></a>
<p>Once this RFC is implemented, the older APIs will be deprecated and retained
for a full LTS cycle (assuming speedy landing, this would mean the older APIs
would be deprecated around Ember 2.20). After that timeframe, the older APIs
will be removed from <code>ember-qunit</code> and <code>ember-test-helpers</code> and they will
release with SemVer major version bumps.</p>
<p>Note that while the older <code>moduleFor</code> and <code>moduleForComponent</code> APIs will be
deprecated, they will still be possible to use since the host application can
pin to a version of <code>ember-qunit</code> / <code>ember-test-helpers</code> that support its own
usage. This is a large benefit of migrating these testing features away from
<code>Ember</code>'s internals, and into the addon space.</p>
<a class="header" href="print.html#relationship-to-grand-testing-unification" id="relationship-to-grand-testing-unification"><h2>Relationship to &quot;Grand Testing Unification&quot;</h2></a>
<p>This RFC is a small stepping stone towards the future where all types of tests
share a similar API. The API proposed here is much easier to extend to provide
the functionality that is required for <a href="https://github.com/emberjs/rfcs/pull/119">emberjs/rfcs#119</a>.</p>
<a class="header" href="print.html#how-we-teach-this-16" id="how-we-teach-this-16"><h1>How We Teach This</h1></a>
<p>This change requires updates to the API documentation of <code>ember-qunit</code> and the
main Ember guides' testing section. The changes are largely intended to reduce
confusion, making it easier to teach and understand testing in Ember.</p>
<a class="header" href="print.html#drawbacks-34" id="drawbacks-34"><h1>Drawbacks</h1></a>
<a class="header" href="print.html#churn-1" id="churn-1"><h2>Churn</h2></a>
<p>As mentioned in <a href="https://github.com/emberjs/rfcs/pull/229">emberjs/rfcs#229</a>, test
related churn is quite painful and annoying. In order to maintain the general
goodwill of folks, we must ensure that we avoid needless churn.</p>
<p>This RFC should be implemented in conjunction with
<a href="https://github.com/emberjs/rfcs/pull/229">emberjs/rfcs#229</a> so that we can avoid
multiple back to back changes in the blueprints.</p>
<a class="header" href="print.html#a-hrefhttpsgithubcomqunitjsqunitissues977qunitjsqunit977a" id="a-hrefhttpsgithubcomqunitjsqunitissues977qunitjsqunit977a"><h2><a href="https://github.com/qunitjs/qunit/issues/977">qunitjs/qunit#977</a></h2></a>
<p>Until very recently, the QUnit nested module API was only able to allow a single
callback for each of the hooks per-nesting level. This means that the proposal in
this RFC (which requires the hooks to be setup by <code>ember-qunit</code>) would disallow
user-land <code>beforeEach</code>/<code>afterEach</code> hooks to be setup.</p>
<p>The work around is &quot;simple&quot; (if somewhat annoying), which is to &quot;just nest another
level&quot;. The good news is that <a href="https://github.com/trentwillis">Trent Willis</a> fixed
the underlying problem in <a href="https://github.com/qunitjs/qunit/pull/1188">qunitjs/qunit#1188</a>,
which should be released as 2.3.4 well before this RFC is merged.</p>
<a class="header" href="print.html#alternatives-33" id="alternatives-33"><h1>Alternatives</h1></a>
<p>The simplest alternative is to do nothing. This would loose all of the positive
benefits mentioned in this RFC, but should still be considered a possibility...</p>
<a class="header" href="print.html#unanswered-questions" id="unanswered-questions"><h1>Unanswered Questions</h1></a>
<a class="header" href="print.html#hooks-argument" id="hooks-argument"><h2><code>hooks</code> argument</h2></a>
<p>A few folks (e.g. <a href="https://github.com/ebryn">@ebryn</a> and <a href="https://github.com/stefanpenner">@stefanpenner</a>)
have approached me with concerns around the <code>hooks</code> argument I have mentioned/used here. The concerns
are generally an initial reaction to the QUnit nested modules API in general and not directly related
to this RFC (other than it highlighting a new feature that they haven't used before).</p>
<p>The main concerns are:</p>
<ul>
<li>Teaching folks what <code>hooks</code> means is a bit more difficult because it does not represent the &quot;test
environment&quot;, but rather just a way to invoke the callbacks for <code>before</code> / <code>beforeEach</code> / <code>after</code> /
<code>afterEach</code>.</li>
<li>Passing only <code>hooks</code> to the helper functions proposed in the RFC means that if we ever need to thread
more information through, we either have to use <code>hooks</code> as a transport or change our API to add more
arguments.</li>
<li>It seems somewhat impossible to communicate across multiple helpers (again without using <code>hooks</code>
as a state/transport mechanism).</li>
</ul>
<p>I've kicked off a conversation over with the QUnit folks in https://github.com/qunitjs/qunit/issues/1200.
If that PR were merged this proposal would be modified to the following syntax:</p>
<pre><code class="language-js">// current proposal
module('x-foo', function(hooks) {
  setupRenderingTest(hooks);
  // ....snip....
});

// after qunitjs/qunit#1200
module('x-foo', function(hooks) {
  setupRenderingTest(this);
  // ....snip....
});
</code></pre>
<p>Another possible solution is to rename the argument (here and in the blueprints) to <code>module</code>.
This is more in line with what the QUnit folks view it as: the &quot;module context&quot; that
is being created for that specific <code>QUnit.module</code> invocation.</p>
<ul>
<li>Start Date: 2017-07-14</li>
<li>RFC PR: https://github.com/emberjs/rfcs/pull/236</li>
<li>Ember Issue: https://github.com/emberjs/ember.js/issues/15624</li>
</ul>
<a class="header" href="print.html#summary-35" id="summary-35"><h1>Summary</h1></a>
<p>This RFC proposes to deprecate the prototype extensions done by <code>Ember.String</code>, deprecate the <code>loc</code> method, and moving <code>htmlSafe</code> and <code>isHTMLSafe</code> to <code>@ember/template</code>.</p>
<a class="header" href="print.html#motivation-36" id="motivation-36"><h1>Motivation</h1></a>
<p>Much of the public API of Ember was designed and published some time ago, when the client-side landscape looked much different. It was a time without many utilities and methods that have been introduced to JavaScript since, without the current rich npm ecosystem, and without ES6 modules. On the Ember side, Ember CLI and the subsequent addons were still to be introduced. Global mode was the way to go, and extending native prototypes like Ember does for <code>String</code>, <code>Array</code> and <code>Function</code> was a common practice.</p>
<p>With the introduction of <a href="https://github.com/emberjs/rfcs/blob/master/text/0176-javascript-module-api.md">RFC #176</a>, an opportunity to reduce and reorganize the API that is shipped by default with an Ember application appears. A lot of nice-to-have functionality that was added at that time can now be moved to optional packages and addons, where they can be maintained and evolved without being tied to the core of the framework.</p>
<p>In the specific case of <code>Ember.String</code>, our goal is that users that need these utility functions will include <code>@ember/string</code> in their dependencies, or rely on common utility packages like <a href="https://lodash.com/docs/#camelCase"><code>lodash.camelcase</code></a>.</p>
<p>To achieve the above goal we will move the <code>isHTMLSafe</code>/<code>htmlSafe</code> pair into a new package, deprecate <code>String.prototype</code> extensions, and deprecate the utility functions under the <code>Ember.String</code> namespace.</p>
<p>The <a href="https://github.com/emberjs/rfcs/blob/master/text/0176-javascript-module-api.md#organize-by-mental-model">&quot;Organize by Mental Model&quot;</a> section of RFC #176 mentions the concept of chunking. In the current setup, <code>isHTMLSafe</code>/<code>htmlSafe</code> make sense in the <code>Ember.String</code> namespace because they operate on strings, and they are available on the prototype, <code>&quot;myString&quot;.htmlSafe()</code>.
However, once prototype extensions are removed it becomes clearer that while this pair operates on strings, they don't transform them in the same way as <code>capitalize</code> or <code>dasherize</code>. They are instead a way for the user to communicate to the templating engine that this string should be safe to render. For this reason, moving to <code>@ember/template</code> seems appropriate.</p>
<p>Extending native prototypes, like we do for <code>String</code> with <code>&quot;myString&quot;.dasherize()</code> and the rest of the API, has been falling out of favour more as time goes by.
While the tradeoff might have been positive at the beginning, as it allowed users access to a richer API, prototype extensions blur the line between what is the framework and what is the language in a way that is not benefitial in the current module-driven and package-rich ecosystem.</p>
<p>Relatedly, deprecating <code>Ember.String</code> and requiring <code>@ember/string</code> as a dependency allows Ember to provide a leaner default core to all users, as well as iterate faster on the <code>@ember/string</code> package if desired.
Doing this will also open a path to extract more packages in the future.</p>
<a class="header" href="print.html#transition-path-6" id="transition-path-6"><h1>Transition Path</h1></a>
<p>It is important to understand that the transition path will be done in the context of the new modules API defined in RFC #176, which is scheduled to land in 2.16.
As this will likely be first of many packages to be extracted from the Ember source, the transition path arrived on needs to be clear and user-friendly.</p>
<a class="header" href="print.html#what-is-happening-for-framework-developers" id="what-is-happening-for-framework-developers"><h2>What is happening for framework developers?</h2></a>
<p>The order of operations will be as follows:</p>
<ol>
<li>Move <code>htmlSafe</code> and <code>isHTMLSafe</code> to <code>@ember/template</code>
<ul>
<li>Update https://github.com/ember-cli/ember-rfc176-data</li>
</ul>
</li>
<li>Create an <code>@ember/string</code> package with the remaining public API</li>
<li>Create an <code>ember-string-prototype-extensions</code> package that introduces <code>String</code> prototype extensions to aid in transitioning</li>
<li>Make <code>ember-cli-babel</code> aware of the <code>@ember/string</code> package so it tells <code>babel-plugin-ember-modules-api-polyfill</code> not to convert those imports to the global <code>Ember</code> namespace</li>
<li>Update usages in Ember and Ember Data codebases so that the projects do not trigger deprecations</li>
<li>Deprecate <code>Ember.String</code>
<ul>
<li>Write deprecation guide which mentions minimum version of <code>ember-cli-babel</code>, and how/when to use <code>@ember/string</code> and <code>ember-string-prototype-extensions</code> packages</li>
</ul>
</li>
<li>Deprecate <code>loc</code> in <code>@ember/string</code></li>
</ol>
<a class="header" href="print.html#what-is-happening-for-framework-users" id="what-is-happening-for-framework-users"><h2>What is happening for framework users?</h2></a>
<p>If you are using <code>Ember.String.loc</code>, you will be instructed to move to a dedicated localization solution, as this method will be completely deprecated.</p>
<p>If you are using <code>Ember.String.htmlSafe</code> or <code>Ember.String.isHTMLSafe</code>, you will be instructed to run the <a href="https://github.com/ember-cli/ember-modules-codemod"><code>ember-modules-codemod</code></a> and it will update to the correct imports from the <code>@ember/template</code> package.</p>
<p>If you are using one of the other <code>Ember.String</code> methods, like <code>Ember.String.dasherize</code>, you will receive a deprecation warning to inform you that you should run the <a href="https://github.com/ember-cli/ember-modules-codemod"><code>ember-modules-codemod</code></a>, update <code>ember-cli-babel</code> to a specific minor version, and add <code>@ember/string</code> to your application's or addon's dependencies.</p>
<p>If you are using the <code>String</code> prototype extensions, like <code>'myString'.dasherize()</code>, on top of the previous instructions you will be instructed to install <code>ember-string-prototype-extensions</code> in case updating the code to <code>dasherize('myString')</code> is not trivial.</p>
<a class="header" href="print.html#timeline" id="timeline"><h2>Timeline</h2></a>
<ul>
<li>Deprecations are introduced - Ember 2.x
<ul>
<li><code>String</code> protoype extensions are deprecated</li>
<li><code>Ember.String</code> functions are deprecated</li>
<li><code>loc</code> is completely deprecated</li>
<li><code>isHTMLSafe</code> and <code>htmlSafe</code> are moved to <code>@ember/template</code></li>
</ul>
</li>
<li>Transition packages are introduced - Ember 2.x
<ul>
<li><code>@ember/string</code>, which replaced <code>Ember.String</code></li>
<li><code>ember-string-prototype-extensions</code>, which brings <code>String</code> prototype extensions back</li>
</ul>
</li>
<li>Deprecations are removed - Ember 3.x, <code>@ember/string</code> 2.x
<ul>
<li>New major version of Ember is released</li>
<li>New major version of <code>@ember/string</code> is released</li>
</ul>
</li>
</ul>
<a class="header" href="print.html#how-we-teach-this-17" id="how-we-teach-this-17"><h1>How We Teach This</h1></a>
<a class="header" href="print.html#official-code-bases-and-documentation" id="official-code-bases-and-documentation"><h2>Official code bases and documentation</h2></a>
<p>The official documentation website, Guides, API documentation should be updated not to use <code>String</code> prototype extensions.
This documentation should already use the new modules API from an effort to update it for Ember 2.16.</p>
<p>The Guides section on <em>disabling prototype extension</em> will need to be updated when <code>String</code> prototype extensions are removed from Ember.</p>
<p>Resources owned by the Ember teams, such and Ember and Ember Data code bases, the Super Rentals repository, or the builds app for the website, will be updated accordingly.</p>
<a class="header" href="print.html#emberstringhtmlsafe-and-emberstringishtmlsafe" id="emberstringhtmlsafe-and-emberstringishtmlsafe"><h2><code>Ember.String.htmlSafe</code> and <code>Ember.String.isHTMLSafe</code></h2></a>
<p>The move of <code>htmlSafe</code> and <code>isHTMLSafe</code> from <code>Ember.String</code> to <code>@ember/template</code> should be documented as part of the <a href="https://github.com/ember-cli/ember-rfc176-data">ember-rfc176-data</a> and related codemods efforts, as that project is the source of truth for the mappings between the <code>Ember</code> global namespace and <code>@ember</code>-scoped modules.</p>
<a class="header" href="print.html#emberstringloc-and-import--loc--from-emberstring-emberstring-to-emberstring-string-prototype-extensions" id="emberstringloc-and-import--loc--from-emberstring-emberstring-to-emberstring-string-prototype-extensions"><h2><code>Ember.String.loc</code> and <code>import { loc } from '@ember/string';</code>, <code>Ember.String</code> to <code>@ember/string</code>, <code>String</code> prototype extensions</h2></a>
<p>An entry to the <a href="https://emberjs.com/deprecations/">Deprecation Guides</a> will be added outlining the different recommended transition strategies.</p>
<a class="header" href="print.html#emberstringloc-import--loc--from-emberstring" id="emberstringloc-import--loc--from-emberstring"><h3><code>Ember.String.loc</code>, <code>import { loc } from '@ember/string';</code></h3></a>
<p>As this function is deprecated, users will be recommended to use a <a href="https://emberobserver.com/categories/internationalization">dedicated localization solution</a>.</p>
<a class="header" href="print.html#emberstring-to-emberstring" id="emberstring-to-emberstring"><h3><code>Ember.String</code> to <code>@ember/string</code></h3></a>
<p>The way that <code>@ember</code>-scoped modules will work in 2.16 is that <code>ember-cli-babel</code> will convert something like <code>import { dasherize } from '@ember/string';</code> to <code>import Ember from 'Ember'; const dasherize = Ember.String.dasherize;</code>.
What this means is that <code>import { dasherize } from '@ember/string';</code> will trigger a deprecation if you do not have the <code>@ember/string</code> package in your dependencies.</p>
<p>To address the above deprecation you will need to update <code>ember-cli-babel</code> to a a specific minor version or higher, to make sure it has the logic to detect <code>@ember/string</code>. The specific minor version will be known at the time the deprecation guide is written.
You will also need to add <code>@ember/string</code> to your application's development dependencies, or your addon's dependencies.</p>
<a class="header" href="print.html#string-prototype-extensions" id="string-prototype-extensions"><h3><code>String</code> prototype extensions</h3></a>
<p>If you are using <code>'myString'.dasherize()</code> or one of the other functions added to <code>String</code>, you will be instructed to replace that usage with <code>import { dasherize } from '@ember/string'; dasherize('myString')</code>, in addition to the changes on the previous section.</p>
<p>In case your code base is complicated enough that migrating all these usages at the same time is not convenient, you will be able to add <code>ember-string-prototype-extensions</code> to your dependencies, which will bring back extensions, without deprecations.</p>
<a class="header" href="print.html#drawbacks-35" id="drawbacks-35"><h1>Drawbacks</h1></a>
<p>A lot of addons that deal with names depend on this behaviour, so they will need to install the addon. Also, Ember Data and some external serializers require these functions.</p>
<p><code>htmlSafe</code> and <code>isHTMLSafe</code> would need to change packages, thus the reason to try and provide an Ember Watson recipe.</p>
<p>Another side-effect of this change is that certain users might be shipping duplicated code between <code>Ember.String</code> and <code>@ember/string</code>, but it is a necessary stepping stone and might be able to be addressed via svelting.</p>
<a class="header" href="print.html#alternatives-34" id="alternatives-34"><h1>Alternatives</h1></a>
<p>Leave things as they are.</p>
<a class="header" href="print.html#unresolved-questions-26" id="unresolved-questions-26"><h1>Unresolved questions</h1></a>
<p>None.</p>
<ul>
<li>Start Date: 2017-07-20</li>
<li>RFC PR: https://github.com/emberjs/rfcs/pull/237</li>
<li>Ember Issue: (leave this empty)</li>
</ul>
<a class="header" href="print.html#summary-36" id="summary-36"><h1>Summary</h1></a>
<p>This RFC proposes the deprecation of the following classes:</p>
<ul>
<li><code>Ember.OrderedSet</code></li>
<li><code>Ember.Map</code></li>
<li><code>Ember.MapWithDefault</code></li>
</ul>
<p>These classes need to be moved to an external addon given they are private classes and unused in Ember.js itself.</p>
<a class="header" href="print.html#motivation-37" id="motivation-37"><h1>Motivation</h1></a>
<p>These classes have not been used in Ember itself for a while now. They have always been private but they are used in a few addons, and in particular Ember Data is using them.</p>
<a class="header" href="print.html#transition-path-7" id="transition-path-7"><h1>Transition Path</h1></a>
<p><code>Ember.Map</code> and <code>Ember.MapWithDefault</code> will be deprecated and not extracted, but not before the fix mentioned in the following paragraph is landed in Ember Data. There is already an addon with <code>Ember.OrderedSet</code> extracted (<a href="https://github.com/emberjs/ember-ordered-set">@ember/ordered-set</a>).</p>
<p>Ember Data is quite likely the biggest project using these classes. There is already a PR that needs merging before deprecating <code>Ember.Map</code> and <code>Ember.MapWithDefault</code> https://github.com/emberjs/data/pull/5255. Ember Data still needs to migrate to <code>@ember/ordered-set</code> to its relationship logic.</p>
<p>Once Ember Data is updated to not use the classes from Ember, and that fix is released, the <code>Ember.Map</code> and <code>Ember.MapWithDefault</code> can be deprecated in Ember itself.</p>
<a class="header" href="print.html#how-we-teach-this-18" id="how-we-teach-this-18"><h1>How We Teach This</h1></a>
<p>These classes being private would make this simple than other deprecations. People were not supposed to be using a private API and the few that were, would just need to use a new addon.</p>
<p>This should not impact many codebases.</p>
<a class="header" href="print.html#drawbacks-36" id="drawbacks-36"><h1>Drawbacks</h1></a>
<p>This requires cooperation with Ember Data, the main user of these classes. It would be nice to have moved Ember Data to using the addon before releasing Ember with the deprecation so the average user does not see any deprecation warning.</p>
<a class="header" href="print.html#alternatives-35" id="alternatives-35"><h1>Alternatives</h1></a>
<p>Other option would be moving these classes to Ember Data itself or leaving things as they are now.</p>
<a class="header" href="print.html#unresolved-questions-27" id="unresolved-questions-27"><h1>Unresolved questions</h1></a>
<ul>
<li>Start Date: 2017-07-28</li>
<li>RFC PR: <a href="https://github.com/emberjs/rfcs/pull/240">#240</a></li>
<li>Ember Issue: (leave this empty)</li>
</ul>
<a class="header" href="print.html#summary-37" id="summary-37"><h1>Summary</h1></a>
<p>This RFC aims to solidify the usage of ES2015 Classes as a public API of Ember so
that users can begin building on them, and projects like <code>ember-decorators</code> can
continue to push forward with experimental Javascript features. This includes:</p>
<ul>
<li>Making the class <code>constructor</code> function a public API</li>
<li>Modifying some of the internals of <code>Ember.Object</code> to support existing features
and make the usage of ES Classes cross-compatible with <code>Ember.Object</code></li>
</ul>
<p>It does <em>not</em> propose additions in the form of helpers or decorators, which should
continue to be iterated on in the community as the spec itself is finalized. It also
does not propose deprecating or removing existing functionality in <code>Ember.Object</code>.</p>
<a class="header" href="print.html#motivation-38" id="motivation-38"><h1>Motivation</h1></a>
<p>The Ember Object model has served its purpose well over the years, but now that
ES Classes are becoming prevalent throughout the wider Javascript community
it is beginning to show its age. With class properties at stage 3 and decorators at
stage 2 in the TC39 process, classes are finally at a point where we can start
integrating them into Ember.</p>
<p>The <a href="https://github.com/rwjblue/ember-decorators">ember-decorators</a> project has been
experimenting with using ES Classes and filling out the Ember feature-set,
allowing us to write Ember classes like so:</p>
<pre><code class="language-javascript">export default class MyComponent extends Ember.Component {
  didInsertElement() {
    // do stuff
  }

  @computed
  get foo() {
    // do stuff
  }

  @action
  bar() {
    // do stuff
  }
}
</code></pre>
<p>Using classes makes Ember easier to teach and understand by normalizing it with
standard Javascript coding practices, and allows us to share code and solutions
with other frameworks and libraries. It also brings with it all the benefits of
ES Class syntax:</p>
<ul>
<li>More aligned with the greater Javascript community</li>
<li>Ability to share code more easily with other libraries and frameworks</li>
<li>Easier to statically analyze</li>
<li>Cleaner and easier to read (subjective)</li>
</ul>
<p>The Ember Object model already works extremely well with ES classes, as
demonstrated above, but there several failure scenarios. Furthermore, because
they are not officially supported as a public API, there is no guarantee
that they will continue to work well. Thus, this RFC seeks to solidify the
behavior of ES Classes so that the community can continue to experiment with
new Javascript features and build on a stable API.</p>
<a class="header" href="print.html#detailed-design-30" id="detailed-design-30"><h1>Detailed Design</h1></a>
<p>Many of the standard features of Ember classes work out of the box today, either with
vanilla ES Classes or through <code>ember-decorators</code>, including:</p>
<ul>
<li>Inheritance</li>
<li>Lifecycle hooks</li>
<li>Computeds</li>
<li>Injections</li>
<li>Actions</li>
</ul>
<p>However, the following features either do not exist or do not work as a
user familiar with <code>Ember.Object</code> would expect:</p>
<ul>
<li>Extending from ES Classes using <code>extend</code></li>
<li>Class properties</li>
<li>Mixins</li>
<li>Observers and events</li>
<li>Merged and concatenated properties</li>
</ul>
<p>These features will require changes to <code>Ember.Object</code></p>
<a class="header" href="print.html#extend" id="extend"><h2>Extend</h2></a>
<p>Currently, once a class is defined using ES Classes it is not possible for users
to extend it using the previous CoreObject style of writing and extending classes.
This can limit the rate of adoption because ES Classes would become a trapdoor -
once you begin using them, you must continue to use them. It would be a particularly
thorny issue for addon developers, who may design components which their users
expect to be able to extend and modify.</p>
<p>This RFC proposes that <code>extend</code> be fixed on ES Classes to make them fully
cross-compatible with the existing syntax. There are two general approaches to
making this work:</p>
<ol>
<li>
<p>Modify CoreObject to use prototypes/ES Classes internally. This would bring
CoreObject more inline with ES Classes, but would be a significant internal change.</p>
</li>
<li>
<p>Modify CoreObject to have different behavior if it is extending an ES Class
using <code>extend</code>.</p>
</li>
</ol>
<p>Both approaches should be explored and benchmarked to determine if there are an
significant advantages to one over the other.</p>
<a class="header" href="print.html#class-properties" id="class-properties"><h2>Class Properties</h2></a>
<p>When using <code>Ember.Object.extend</code>, properties that are passed in on the object
are assigned to the prototype of the class:</p>
<pre><code class="language-javascript">const Foo = Ember.Object.extend({ bar: 'baz' });
const foo = Foo.create();

console.log(Foo.prototype.bar) // 'baz'
foo.hasOwnProperty('bar') // false
</code></pre>
<p>This differs from the behavior of ES Class properties, which initialize their
value on the instance of the class.</p>
<pre><code class="language-javascript">class Foo {
  bar = 'baz'
}

const foo = new Foo();

console.log(Foo.prototype.bar) // undefined
foo.hasOwnProperty('bar') // true
</code></pre>
<p>The above is essentially currently compiled down by Babel to the following:</p>
<pre><code class="language-javascript">class Foo {
  constructor() {
    this.bar = 'baz';
  }
}
</code></pre>
<p>Property assignments like this are always done at the end of the constructor,
and given the requirement that <code>super</code> must always be called before properties
are assigned it is unlikely that this will change as the spec progresses.</p>
<p>While one might intuitively expect class properties to function the same in
ES Classes as they do with Ember Objects, this difference in behavior means that
class properties will always be assigned after properties passed into <code>create</code>
are initialized on the object, and thus will always win:</p>
<pre><code class="language-javascript">const Foo = Ember.Object.extend({ testProp: 'default value' });

class Bar extends Ember.Object {
  testProp = 'default value'
}

const foo = Foo.create({ testProp: 'new value' });
const bar = Bar.create({ testProp: 'new value' });

console.log(foo.get('testProp')); // 'new value'
console.log(bar.get('testProp')); // 'default value'
</code></pre>
<p>This behavior makes sense when you consider that it is equivalent to assigning
values in <code>init</code> rather than on the object when it is defined. Rather than modify
<code>Ember.Object</code> to treat class properties as default values, this RFC proposes that
we accept the difference in behavior and utilize the constructor to allow users
to set default values, as in the following example:</p>
<pre><code class="language-javascript">class Foo extends Ember.Object {
  constructor(props) {
    props.testProp = props.testProp || 'default value';

    super(props);
  }
}
</code></pre>
<p>This enforces a public API rather than allowing <code>create</code> to override values as
it pleases, and is more inline with the behavior of components in Glimmer today -
args that are passed into the class are distinguished from properties that are
defined on the class.</p>
<a class="header" href="print.html#mixins" id="mixins"><h2>Mixins</h2></a>
<p>Mixins are a contentious part of both the Ember Object model and the wider
Javascript community - some swear by the pattern, and others believe it fundamentally
flawed. While Ember mixins are at the core of Ember Object, the fact is that
no standard solution for them has arisen in the wider Javascript community as
of yet.</p>
<p>Additionally, while concepts like computed properties, actions, and
service injection are either unique to Ember or highly dependent on implementation,
mixins can be implemented in a generic way which could be used across all of
Javascript, independent of one's framework or library of choice. With that in
mind, this RFC considers mixins out of scope and suggests that in the future Ember
users can choose to use a mixin library if it suits their needs.</p>
<p>It should also be noted that existing classes which have used mixins can still be
extended using ES Class syntax:</p>
<pre><code class="language-javascript">const Mix = Ember.Mixin.create({ bar: 'baz' });
const Foo = Ember.Object.extend(Mix, { /* ... */ });

class Bar extends Foo { /* ... */ }

const bar = Bar.create();

console.log(bar.get('bar')); // 'baz'
</code></pre>
<a class="header" href="print.html#observers-and-events" id="observers-and-events"><h2>Observers and Events</h2></a>
<p>Observers and events both fail to work properly when using ES Class syntax. The root
of the issue here is how <code>Ember.Object</code> works at a fundamental level, and will require
some refactoring to fix.</p>
<p>Currently, each time <code>Ember.Object.extend</code> is used, it stores the list of mixins and
objects passed in on a list which also contains the superclass's properties and mixins,
and so on. A class is then returned which has access to a closure variable, <code>wasApplied</code>:</p>
<pre><code class="language-javascript">makeCtor = function() {
  wasApplied = false;

  return class {
    constructor() {
      if (!wasApplied) {
        this.proto();
      }
    }
  }
}
</code></pre>
<p>The <code>proto</code> function walks the chain of stored mixins, collapsing them into a single object
prototype the first time the class is created. It is during this walk that observers and
events listeners are applied and finalized, as well as merged and concatenated properties
applied (this will be touched on more in the next section).</p>
<p>Unfortunately, due to the nature of how observers and event listeners work, they cannot be
applied at class definition time without a class decorator. For example:</p>
<pre><code class="language-javascript">const Foo = Ember.Object.extend({
  fooObserver: Ember.observer('foo', function() { /* ... */m })
});

class Bar extends Foo {
  fooObserver() { /* ... */ }
}
</code></pre>
<p>When <code>proto</code> walks the mixin chain for Foo, it will add an observer that triggers the
<code>fooObserver</code> function whenever <code>foo</code> changes. Bar, however, overloads the <code>fooObserver</code>
function with a function that is <em>not</em> observed, and thus should not trigger (this is
analagous to how Ember Object's work today). Currently there is no time at which
Bar can inspect undecorated properties to determine if the superclass has already defined
them and if they are observed and thus should have the observer removed.</p>
<p>To fix this, the <code>wasApplied</code> state should be moved to the ember meta object on the
class itself, so that both Ember Objects and ES Classes can track if they have had it
applied. Additional logic will also need to be added to allow the current &quot;squashing&quot;
behavior of <code>proto</code> to work with Prototypes instead of a list of mixins as well.</p>
<a class="header" href="print.html#merged-and-concatenated-properties" id="merged-and-concatenated-properties"><h2>Merged and Concatenated Properties</h2></a>
<p>Ember Objects currently have the ability to define special properties which are
merged or concatenated with their superclass when extended. This is most commonly
seen with <code>actions</code> and <code>classNames</code> among others.</p>
<p>As mentioned in the last section, merged and concatenated properties are also
combined during the <code>proto</code> &quot;squash&quot; phase, and so it is also broken in ES Classes
currently. This RFC proposes that their behavior also be fixed as part of the refactors
to Ember.Object.</p>
<a class="header" href="print.html#how-we-teach-this-19" id="how-we-teach-this-19"><h1>How We Teach This</h1></a>
<p>The sole purpose of this RFC is to make the behavior of ES Classes within Ember a
public API so that projects like <code>ember-decorators</code> can continue to build and experiment
with confidence that the underlying behavior will not change. The Ember Object model
will remain exactly the same as today, and will continue to be the recommended path
for Ember users. Thus, we will not need to add new documentation for the time being.</p>
<a class="header" href="print.html#drawbacks-37" id="drawbacks-37"><h1>Drawbacks</h1></a>
<ul>
<li>Making <code>constructor</code> a public API means we are solidifying the lifecycle of
objects, locking us into a particular sequence of events (<code>init</code> occurs within
the <code>super()</code> portion of the constructor).</li>
<li>Lack of mixin support may make it difficult for mixin heavy codebases to utilize
ES Classes.</li>
<li>ES Class features/usage such as getters and setters may confuse users in general
(getter functions will <em>appear</em> to work, but without a <code>computed</code> decorator will
not update, etc.)</li>
</ul>
<a class="header" href="print.html#alternatives-36" id="alternatives-36"><h1>Alternatives</h1></a>
<ul>
<li>Class property initialization can be changed such that properties are initialized
after the constructor runs entirely, allowing them to be overwritten by values
passed to <code>create</code></li>
</ul>
<a class="header" href="print.html#topics-for-future-rfcs" id="topics-for-future-rfcs"><h1>Topics for Future RFCs</h1></a>
<p>While working on this RFC, some issues were brought into focus regarding existing
features in CoreObject that are seen as problematic or unintuitive. In order to
avoid bikeshedding these have been slated for discussion in future RFCs, but the
discussion points have been included below.</p>
<a class="header" href="print.html#merged-and-concatenated-properties-1" id="merged-and-concatenated-properties-1"><h2>Merged and Concatenated Properties</h2></a>
<p>Merged and concatenated properties are pain points for new Ember developers,
specifically because they give no lexical hint that they are special in any way.
Developers must know that these particular properties will be merged with the
superclass, and there is no way to opt out of this behavior.</p>
<p>With decorators, this same behavior can be accomplished in a much clearer and
more straightforward way:</p>
<pre><code class="language-javascript">class FooComponent extends Ember.Component {
  @concatenated classNameBindings = ['foo']

  @computed
  get foo() { /* ... */ }

  @merged actions = {
    bar() { /* ... */ }
  }
}
</code></pre>
<p>They could also be accomplished more ergonomically with specialized decorators:</p>
<pre><code class="language-javascript">class FooComponent extends Ember.Component {
  @className
  @computed
  get foo() { /* ... */ }

  @action
  bar() { /* ... */ }
}
</code></pre>
<p>This approach has two distinct advantages over the existing behavior:</p>
<ol>
<li>It is less magical. The decorators indicate to new users that the properties are
special in some way, and ultimately they are just plain decorators, which are
compatible with ES Classes as a whole and can be reused anywhere.</li>
<li>It provides a way to opt out of the behavior. Currently, there is no easy
way to prevent properties which were marked to be merged from being merged,
meaning subclasses are stuck with the values that their superclass provided.</li>
</ol>
<a class="header" href="print.html#observers-and-listeners" id="observers-and-listeners"><h2>Observers and Listeners</h2></a>
<p>Observers and event listeners are a powerful pattern that saw a lot of usage in Ember 1.
However, it is now widely accepted that they are problematic when overused, and using
computed properties and lifecycle hooks are better patterns in most cases.</p>
<p>As such, rather than having events and observers turned on by default it may make
more sense to have them be opt-in APIs. This could be accomplished by making new
class decorators like so:</p>
<pre><code class="language-javascript">@evented
class Foo extends Ember.Object {
  @on('init')
  onInit() {
    // do something
  }
}
</code></pre>
<p>Or it could be accomplished with new base classes that include the functionality:</p>
<pre><code class="language-javascript">class Foo extends EventedObject {
  @on('init')
  onInit() {
    // do something
  }
}
</code></pre>
<a class="header" href="print.html#unresolved-questions-28" id="unresolved-questions-28"><h1>Unresolved questions</h1></a>
<p>None currently</p>
<a class="header" href="print.html#browser-support-changes" id="browser-support-changes"><h1>Browser Support Changes</h1></a>
<ul>
<li>Start Date: 2017-09-25</li>
<li>RFC PR: (leave this empty)</li>
<li>Ember Issue: (leave this empty)</li>
</ul>
<a class="header" href="print.html#summary-38" id="summary-38"><h1>Summary</h1></a>
<p>Solicit feedback on dropping support for IE9, IE10, and PhantomJS.</p>
<a class="header" href="print.html#motivation-39" id="motivation-39"><h1>Motivation</h1></a>
<p>As Ember heads towards version 3.0, it is a good time to evaluate our browser support matrix. Ember follows Semantic Versioning, and we consider browser compatibility to be under the umbrella of those guarantees. In other words, we will continue to support whatever browsers we officially support in Ember 3.0 until Ember 4.0.</p>
<p>We want to make this decision on the basis of the browsers that our community still needs to support, while weighing that against the costs we bear as a community to support older browsers. This RFC will lay out some of those costs, so we can decide what tradeoff is most appropriate.
Members of the core team maintain many different kinds of apps across many different kinds of companies. Some of us work on applications with small, agile teams, while others work inside of large corporations with many engineers. When this topic came up amongst the team, we discovered that, across all these different companies and Ember apps, we did not generally support IE9, IE10, and PhantomJS.</p>
<p>Because of this, the core team's impression is that the costs support now far exceed the benefits, and we are considering dropping support for them in Ember 3.0. Before we make the decision, we want to hear from the rest of the community. Supporting IE9, IE10, and PhantomJS incurs significant cost, both in terms of features and maintenance, and we want the community to help us think through the cost-benefit analysis.</p>
<p>Ember is more than just the framework's code. When people use Ember, they expect to be able to use Ember's tooling, read Ember's documentation, find solutions to problems on Stack Overflow, and read tutorials produced by community members. <strong>All of these, including addons that follow Embers lead, are shackled to the limitations of these legacy browsers.</strong> By dropping support for them, people can begin to rely on the improved baseline of features.</p>
<p>Some of the features (unavailable in IE9, IE10, or PhantomJS) that addons will be able to freely take advantage of include:</p>
<ul>
<li>requestAnimationFrame (<a href="http://caniuse.com/#feat=requestanimationframe">caniuse</a>, <a href="https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame">MDN</a>)</li>
<li>CSS flexbox (<a href="http://caniuse.com/#search=flexbox">caniuse</a>, <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Flexible_Box_Layout/Using_CSS_flexible_boxes">MDN</a>)</li>
<li>Websockets (<a href="http://caniuse.com/#feat=websockets">caniuse</a>, <a href="https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API">MDN</a>)</li>
<li>let (<a href="http://caniuse.com/#feat=let">caniuse</a>, <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/let">MDN</a>)</li>
<li>const (<a href="http://caniuse.com/#feat=const">caniuse</a>, <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/const">MDN</a>)</li>
<li>TypedArray (<a href="http://caniuse.com/#feat=typedarrays">caniuse</a>, <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray">MDN</a>)</li>
<li>Geolocation API (<a href="https://caniuse.com/#search=Geolocation">caniuse</a>, <a href="https://developer.mozilla.org/en-US/docs/Web/API/Geolocation">MDN</a>)</li>
<li>Online/offline API (<a href="http://caniuse.com/#feat=online-status">caniuse</a>, <a href="https://developer.mozilla.org/en-US/docs/Online_and_offline_events">MDN</a>)</li>
<li>XHR advanced features (<a href="https://caniuse.com/#feat=xhr2">caniuse</a>, <a href="https://www.w3.org/TR/2012/WD-XMLHttpRequest-20120117/">specification</a>)</li>
<li>HTTP2 (<a href="http://caniuse.com/#feat=http2">caniuse</a>, <a href="https://en.wikipedia.org/wiki/HTTP/2">wikipedia</a>)</li>
<li>Web Workers (<a href="http://caniuse.com/#feat=webworkers">caniuse</a>, <a href="https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Using_web_workers">MDN</a>)</li>
<li>IndexedDB (<a href="http://caniuse.com/#feat=indexeddb">caniuse</a>, <a href="https://developer.mozilla.org/en-US/docs/Web/API/IndexedDB_API">MDN</a>)</li>
<li>WebGL (<a href="http://caniuse.com/#feat=webgl">caniuse</a>, <a href="https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API">MDN</a>)</li>
<li>File API (<a href="http://caniuse.com/#feat=fileapi">caniuse</a>, <a href="https://developer.mozilla.org/en-US/docs/Web/API/File">MDN</a>)</li>
<li>PageTransitionEvent (<a href="http://caniuse.com/#feat=page-transition-events">caniuse</a>, <a href="https://developer.mozilla.org/en-US/docs/Web/API/PageTransitionEvent">MDN</a>)</li>
<li>SVG filters (<a href="http://caniuse.com/#feat=svg-filters">caniuse</a>, <a href="https://developer.mozilla.org/en-US/docs/Web/SVG/Tutorial/SVG_Filters_Tutorial">MDN</a>)</li>
<li>MutationObserver (<a href="http://caniuse.com/#feat=mutationobserver">caniuse</a>, <a href="https://developer.mozilla.org/en-US/docs/Web/API/MutationObserver">MDN</a>)</li>
</ul>
<p>Below, weve outlined several specific features were interested in using to improve the Ember framework itself. Weve also included some other supporting arguments for this decision.</p>
<a class="header" href="print.html#vendor-support" id="vendor-support"><h2>Vendor Support</h2></a>
<p>Microsoft dropped most support and maintenance for IE9 and IE10 on 2016-01-16 (IE9 on Vista SP2 <a href="http://www.allyncs.com/docs/lifecyclesupport.html">expired in April 2017</a>).</p>
<p>With the advent of headless Chrome and Firefox, PhantomJS is now <a href="https://groups.google.com/forum/#!topic/phantomjs/9aI5d-LDuNE">effectively unmaintained</a>. The default testing boilerplate for Ember CLI-generated applications was changed to headless Chrome in Ember CLI 2.15.</p>
<a class="header" href="print.html#weakmap-map-set" id="weakmap-map-set"><h2>WeakMap, Map, Set</h2></a>
<p>From a framework perspective, being able to rely on native <code>WeakMap</code> support will allow us to remove a significant number of fallback paths that are used in browsers without <code>WeakMap</code>. Using <code>WeakMap</code> results in better developer ergonomics as it allows us to remove many of the random properties that we currently have to assign to an object which makes interacting with your objects in the devtools much less noisy. Minimal support for WeakMap was <a href="http://kangax.github.io/compat-table/es6/#test-WeakMap">introduced in IE11</a>.</p>
<a class="header" href="print.html#better-es-class-support" id="better-es-class-support"><h2>Better ES Class Support</h2></a>
<p>In order to support static class methods (with inheritance) transpilers (e.g. Babel) need to leverage the <code>Object.setPrototypeOf</code> / <code>Object.getPrototypeOf</code> APIs. Without the ability to rely on <code>Object.setPrototypeOf</code> we will not be able to continue iterating slowly towards leveraging ES classes as a replacement for the custom object model functionality that we have known and loved for so many years. Specifically, there is no replacement / capability to support proper inheritance with <code>.reopenClass</code>. There are several lower-fidelity hacks you might opt into, but none that we think satisfy the needs of the Ember community.</p>
<p>Generally this means IE11 is the oldest browser we can reliably transpile ES classes for reliably.</p>
<a class="header" href="print.html#typed-arrays" id="typed-arrays"><h2>Typed Arrays</h2></a>
<p>Typed arrays are not currently used in Ember, but experimentation is underway deep in the internals of Glimmer VM to be able to further reduce template size <em>and</em> the costs associated with expanding the wire format (currently a JSON structure) into a runnable program. Leveraging typed arrays would allow Ember and Glimmer apps to completely avoid the wire format to opcode compilation that currently happens before initial render. It also significantly reduces the resulting memory footprint for the same runnable program.</p>
<a class="header" href="print.html#dom-api-improvements" id="dom-api-improvements"><h2>DOM API Improvements</h2></a>
<p>Although IE9 introduced JavaScript engine with support for much of ES5, it was not until IE10 that the browser began to support much of what developers consider modern web platform APIs. Littered throughout the Ember and Glimmer VM codebase are <a href="https://github.com/glimmerjs/glimmer-vm/blob/1759c16defc546b034b97e37141187652ed93859/packages/%40glimmer/runtime/lib/dom/props.ts#L54">many</a> <a href="https://github.com/glimmerjs/glimmer-vm/blob/9ecc88504c81469ba20dba3ed3f37d373a998355/packages/%40glimmer/test-helpers/lib/helpers.ts#L170">examples</a> <a href="https://github.com/glimmerjs/glimmer-vm/blob/bfed16af6a5ecce4fbe9f27783245fe0f8b03480/build/broccoli/transpile-to-es5.js#L25">of</a> IE9 workarounds (and <a href="https://github.com/glimmerjs/glimmer-vm/blob/1759c16defc546b034b97e37141187652ed93859/packages/%40glimmer/runtime/lib/dom/props.ts#L49">PhantomJS workarounds</a>, in fact). Weve worked hard to make these fixes free at runtime for modern browsers, but some cost is unavoidable.</p>
<p>PhantomJS in particular is a weird environment. Users must often fix Phantom-specific browser bugs, which is wasted effort since real users never run your app in Phantom. And &quot;how to debug in Phantom&quot; is an entire extra skill people are forced to learn. Testing your app in PhantomJS is generally a form of testing theater, since it fails to execute your code in a realistic environment.</p>
<a class="header" href="print.html#requestanimationframe" id="requestanimationframe"><h2><code>requestAnimationFrame</code></h2></a>
<p>IE10 introduced support for <code>requestAnimationFrame</code>, an efficient way to schedule work in the browser environment. Were interested in using this API to explore incremental rendering strategies, and as a way to improve Embers coordination with the browser when native promises are used in application code.</p>
<a class="header" href="print.html#detailed-design-31" id="detailed-design-31"><h1>Detailed Design</h1></a>
<p>When using Ember applications in IE9, IE10, or PhantomJS, Ember will cause an appropriate deprecation to be issued. The deprecation will be until 3.0 and will reference an entry in the deprecation guide. The guide entry will describe For example:</p>
<blockquote>
<p>Using Ember.js in IE9, IE10, or PhantomJS is deprecated and will be unsupported in Ember.js 3.0. We recommend using Embers 2.x LTS releases if your applications must support those browsers.</p>
<p>PhantomJS is often used for continuous integration testing. We strongly suggest adopting headless Chrome or Firefox to run CI tests.</p>
</blockquote>
<a class="header" href="print.html#drawbacks-38" id="drawbacks-38"><h1>Drawbacks</h1></a>
<p>Many users have told us that they chose Ember because of the community's commitment to backwards compatibility. There will always be organizations using Ember that exist on the tail-end of browser adoption patterns. We risk alienating or upsetting those users by dropping support for a browser that, while on the way out, is not yet completely gone.</p>
<p>However, in many cases, the requirement for supporting these legacy browsers is driven by non-technical management who do not have a strong sense of the experience of using apps in IE9/IE10. In practice, many applications are not rigorously tested in older browsers, and the performance is so bad that applications written using any framework perform poorly. Techniques that framework and application developers use to make Chrome fast quite often have pathological characteristics on browsers with legacy DOM and JavaScript engines.</p>
<p>Still, some people make it work, and dropping support may prevent those teams from staying with the community as it migrates to Ember 3.0.</p>
<p>As a mitigation for these concerns, the final release of Ember 2.x will itself be made an LTS release. This will ensure a 2.x platform supporting IE9+ with critical bugfix for roughly 8 months following the 3.0 release and security fixes for roughly 14 months after 3.0 release.</p>
<a class="header" href="print.html#alternatives-37" id="alternatives-37"><h1>Alternatives</h1></a>
<a class="header" href="print.html#bring-your-own-compatibility-1" id="bring-your-own-compatibility-1"><h2>Bring Your Own Compatibility</h2></a>
<p>Some libraries attempt to thread the needle of compatibility by asking users to bring their own compatibility libraries. They write the internals of their framework as if these older browsers did not exist, and require end users to use polyfills to make the environment look equivalent to newer browsers.</p>
<p>We have spent considerable effort on first-class support in Ember 2.x, and we feel that users who require IE9 and IE10 support will have a better experience using Ember 2.x. (with the subset of the ecosystem that supports 2.x) than trying to cobble together a solution that works reliably in a version of Ember with second-class, bring-your-own-compatibility support.</p>
<ul>
<li>Start Date: 2017-11-05</li>
<li>RFC PR: <a href="https://github.com/emberjs/rfcs/pull/268">emberjs/rfcs#268</a></li>
<li>Ember Issue: (leave this empty)</li>
</ul>
<a class="header" href="print.html#summary-39" id="summary-39"><h1>Summary</h1></a>
<p>The testing story in Ember today is better than it ever has been. It is now
possible to test individual component/template combos, register your own mock
components/services/etc, build complex acceptance tests, and almost anything else
you would like.</p>
<p>Unfortunately, there is a massive disparity between different types of tests.
In acceptance tests, you use well designed global helpers to deal with async
related interactions; whereas in integration and unit tests you are forced to
manually deal with this asynchrony.
<a href="https://github.com/emberjs/rfcs/blob/master/text/0232-simplify-qunit-testing-api.md">emberjs/rfcs#232</a>
introduced us to QUnit's nested modules API, made integration and unit testing
modular, and greatly simplified the concepts needed to learn how to write unit
and integration tests. The goal of this RFC is to leverage what we have learned
in prior RFCs and apply that knowledge to acceptance testing. Once this RFC has
been implemented all test types in Ember will have a unified cohesive structure.</p>
<a class="header" href="print.html#motivation-40" id="motivation-40"><h1>Motivation</h1></a>
<p>Usage of rendering tests is becoming more and more common, but these tests
often include manual event delegation (<code>this.$('.foo').click()</code> for
example), and assumes most (if not all) interactions are synchronous.  This is
a major issue due to the fact that the vast majority of interactions will
actually be asynchronous. There have been a few recent additions to
<code>@ember/test-helpers</code> that have made dealing with asynchrony better (namely
<a href="https://github.com/emberjs/rfcs/blob/master/text/0232-simplify-qunit-testing-api.md">emberjs/rfcs#232</a>)
but forcing users to manually manage all interaction based async is a recipe
for disaster.</p>
<p>Acceptance tests allow users to handle asynchrony with ease, but they rely on
global helpers that automatically wrap a single global promise which makes
testing of interleaved asynchronous things more difficult. There are a number
of limitations in acceptance tests as compared to integration tests (cannot
mock and/or stub services, cannot look up services to setup test context, etc).</p>
<p>We need a single unified way to teach and understand testing in Ember that
leverages all the things we learned with the original acceptance testing
helpers that were introduced in Ember 1.0.0.  Instead of inventing our own
syntax for dealing with the async (<code>andThen</code>) we should use new language
features such as <code>async</code> / <code>await</code>.</p>
<a class="header" href="print.html#detailed-design-32" id="detailed-design-32"><h1>Detailed design</h1></a>
<p>The goal of this RFC is to introduce new system for acceptance tests that follows in the footsteps of
<a href="https://github.com/emberjs/rfcs/blob/master/text/0232-simplify-qunit-testing-api.md">emberjs/rfcs#232</a>
and continues to enhance the system created in that RFC to share the same structure and helper system.</p>
<p>This new system for acceptance tests will be implemented in the
<a href="https://github.com/emberjs/ember-test-helpers/">@ember/test-helpers</a> library so
that we can iterate faster while supporting multiple Ember versions
independently and easily support multiple testing frameworks build on top of
the primitives in <code>@ember/test-helpers</code>. Ultimately, the existing <a href="https://github.com/emberjs/ember.js/tree/master/packages/ember-testing">ember-testing</a> system
will be deprecated but that deprecation will be added well after the new system has been
released and adopted by the community.</p>
<p>Lets take a look at a basic example (lifted from <a href="https://guides.emberjs.com/v2.16.0/testing/acceptance/">the guides</a>):</p>
<pre><code class="language-js">// **** before ****
import { test } from 'qunit';
import moduleForAcceptance from '../helpers/module-for-acceptance';

moduleForAcceptance('Acceptance | posts');

test('should add new post', function(assert) {
  visit('/posts/new');
  fillIn('input.title', 'My new post');
  click('button.submit');
  andThen(() =&gt; assert.equal(find('ul.posts li:first').text(), 'My new post'));
});

// **** after ****
import { module, test } from 'qunit';
import { setupApplicationTest } from 'ember-qunit';
import { visit, fillIn, click } from '@ember/test-helpers';

module('Acceptance | login', function(hooks) {
  setupApplicationTest(hooks);

  test('should add new post', async function(assert) {
    await visit('/posts/new');
    await fillIn('input.title', 'My new post');
    await click('button.submit');

    assert.equal(this.element.querySelectorAll('ul.posts li')[0].textContent, 'My new post');
  });
});
</code></pre>
<p>As you can see, this proposal unifies on Qunit's nested module syntax following
in emberjs/rfcs#232's footsteps.</p>
<a class="header" href="print.html#new-apis-proposed" id="new-apis-proposed"><h2>New APIs Proposed</h2></a>
<p>The following new methods will be exposed from <code>ember-qunit</code>:</p>
<pre><code class="language-ts">declare module 'ember-qunit' {
  // ...snip... 
  export function setupApplicationTest(hooks: QUnitModuleHooks): void;
}
</code></pre>
<a class="header" href="print.html#dom-interaction-helpers" id="dom-interaction-helpers"><h3>DOM Interaction Helpers</h3></a>
<p>New native DOM interaction helpers will be added to both <code>setupRenderingTest</code>
and (proposed below) <code>setupApplicationTest</code>. The implementation for these
helpers has been iterated on and is quite stable in the
<a href="https://github.com/cibernox/ember-native-dom-helpers">ember-native-dom-helpers</a>
addon.</p>
<p>The helpers will be migrated to <code>@ember/test-helpers</code> and eventually
(once &quot;the dust settles&quot;) <code>ember-native-dom-helpers</code> will be able to reexport
the versions from <code>@ember/test-helpers</code> directly (which means apps that have
already adopted will have very minimal changes to make).</p>
<p>The specific DOM helpers to be added to the <code>@ember/test-helpers</code> module are:</p>
<pre><code class="language-ts">/**
  Clicks on the specified selector.
*/
export function click(selector: string | HTMLElement): Promise&lt;void&gt;;

/**
  Taps on the specified selector.
*/
export function tap(selector: string | HTMLElement): Promise&lt;void&gt;;

/**
  Triggers a keyboad event on the specified selector.
*/
export function triggerKeyEvent(
  selector: string | HTMLElement,
  eventType: 'keydown' | 'keypress' | 'keyup',
  keyCode: string,
  modifiers?: {
    ctrlKey: false,
    altKey: false,
    shiftKey: false,
    metaKey: false
  }
): Promise&lt;void&gt;;

/**
  Triggers an event on the specified selector.
*/
export function triggerEvent(
  selector: string | HTMLElement,
  eventType: string,
  eventOptions: any
): Promise&lt;void&gt;;

/**
  Fill in the specified selector's `value` property with the provided text.
*/
export function fillIn(selector: string | HTMLElement, text: string): Promise&lt;void&gt;;

/**
  Focus the specified selector.
*/
export function focus(selector: string | HTMLElement): Promise&lt;void&gt;;

/**
  Unfocus the specified selector.
*/
export function blur(selector: string | HTMLElement): Promise&lt;void&gt;;

/**
  Returns a promise which resolves when the provided callback returns a truthy value.
*/
export function waitUntil&lt;T&gt;(Function: Promise&lt;T&gt;, { timeout = 1000 }): Promise&lt;T&gt;;

/**
  Returns a promise which resolves when the provided selector (and count) becomes present.
*/
export function waitFor(selector: string, { count?: number, timeout = 1000 }): Promise&lt;HTMLElement | HTMLElement[]&gt;;
</code></pre>
<a class="header" href="print.html#setupapplicationtest" id="setupapplicationtest"><h3><code>setupApplicationTest</code></h3></a>
<p>This function will:</p>
<ul>
<li>invoke <code>ember-test-helper</code>s <code>setupContext</code> with the tests context (which does the following):
<ul>
<li>create an owner object and set it on the test context (e.g. <code>this.owner</code>)</li>
<li>setup <code>this.pauseTest</code> and <code>this.resumeTest</code> methods to allow easy pausing/resuming
of tests</li>
</ul>
</li>
<li>add routing related helpers
<ul>
<li>setup importable <code>visit</code> method to visit the given url</li>
<li>setup importable <code>currentRouteName</code> method which returns the current route name</li>
<li>setup importable <code>currentURL</code> method which returns the current URL</li>
</ul>
</li>
<li>add DOM interaction helpers (heavily influenced by @cibernox's lovely addon <a href="https://github.com/cibernox/ember-native-dom-helpers">ember-native-dom-helpers</a>)
<ul>
<li>setup a getter for <code>this.element</code> which returns the DOM element representing
the applications root element</li>
<li>setup importable <code>click</code> helper method</li>
<li>setup importable <code>tap</code> helper method</li>
<li>setup importable <code>triggerKeyEvent</code> helper method</li>
<li>setup importable <code>triggerEvent</code> helper method</li>
<li>setup importable <code>fillIn</code> helper method</li>
<li>setup importable <code>focus</code> helper method</li>
<li>setup importable <code>blur</code> helper method</li>
<li>setup importable <code>waitUntil</code> helper method</li>
<li>setup importable <code>waitFor</code> helper method</li>
</ul>
</li>
</ul>
<a class="header" href="print.html#setuprenderingtest-1" id="setuprenderingtest-1"><h3><code>setupRenderingTest</code></h3></a>
<p>The <code>setupRenderingTest</code> function proposed in
<a href="https://github.com/emberjs/rfcs/blob/master/text/0232-simplify-qunit-testing-api.md">emberjs/rfcs#232</a>
(and implemented in
<a href="https://github.com/emberjs/ember-qunit">ember-qunit</a>@3.0.0) will be modified to add the same DOM interaction helpers mentioned above:</p>
<ul>
<li>setup importable <code>click</code> helper method</li>
<li>setup importable <code>tap</code> helper method</li>
<li>setup importable <code>triggerKeyEvent</code> helper method</li>
<li>setup importable <code>triggerEvent</code> helper method</li>
<li>setup importable <code>fillIn</code> helper method</li>
<li>setup importable <code>focus</code> helper method</li>
<li>setup importable <code>blur</code> helper method</li>
<li>setup importable <code>waitUntil</code> helper method</li>
<li>setup importable <code>waitFor</code> helper method</li>
</ul>
<p>Once implemented, <code>setupRenderingTest</code> and <code>setupApplicationTest</code> will diverge from each other in very few ways.</p>
<a class="header" href="print.html#changes-from-current-system-1" id="changes-from-current-system-1"><h2>Changes from Current System</h2></a>
<p>Here is a brief list of the more important but possibly understated changes
being proposed here:</p>
<ul>
<li>The global test helpers that exist now, will no longer be present (e.g.
<code>click</code>, <code>visit</code>, etc) and instead will be available on the test context as
well as importable helpers.</li>
<li><code>this.owner</code> will now be present and allow (for the first time ) overriding
items in the container/registry.</li>
<li>The new system will leverage the <code>Ember.Application</code> /
<code>Ember.ApplicationInstance</code> split so that we can avoid creating an
<code>Ember.Application</code> instance per-test, and instead leverage the same system
that FastBoot itself uses to avoid running initializers for each acceptance
test.</li>
<li>Implicit promise chaining will no longer be present. If your test needs to
wait for a given promise, it should use <code>await</code> (which will wait for the
system to &quot;settle&quot; in similar semantics to today's <code>wait()</code> helper).</li>
<li>The test helpers that are included by a new default ember-cli app will be no
longer needed and will be removed from the new application blueprint. This
includes:
<ul>
<li><code>tests/helpers/resolver.js</code></li>
<li><code>tests/helpers/start-app.js</code></li>
<li><code>tests/helpers/destroy-app.js</code></li>
<li><code>tests/helpers/module-for-acceptance.js</code></li>
</ul>
</li>
</ul>
<a class="header" href="print.html#examples-4" id="examples-4"><h2>Examples</h2></a>
<a class="header" href="print.html#test-helper" id="test-helper"><h3>Test Helper</h3></a>
<p>Assuming the following input:</p>
<pre><code class="language-js">import Ember from 'ember';

export function withFeature(app, featureName) {
  let featuresService = app.__container__.lookup('service:features');
  featuresService.enable(featureName);
}

Ember.Test.registerHelper('withFeature', withFeature);
</code></pre>
<p>In order for an addon to support both the existing acceptance testing system, and the new system it could replace that helper with the following:</p>
<pre><code class="language-js">import { registerAsyncHelper } from '@ember/test';

export function enableFeature(owner, featureName) {
  let featuresService = owner.lookup('service:features');
  featuresService.enable(featureName);
}

registerAsyncHelper('withFeature', function(app, featureName) {
  enableFeature(app.__container__, featureName);
});
</code></pre>
<p>This allows both the prior API (without modification) and the following:</p>
<pre><code class="language-js">// Option 2:
import { module, test } from 'qunit';
import { setupApplicationTest } from 'ember-qunit';
import { enableFeature } from 'addon-name-here/test-support';

module('asdf', function(hooks) {
  setupApplicationTest(hooks);

  test('awesome test title here', function(assert) {
    enableFeature(this.owner, 'feature-name-here');

    // ...snip...
  });
});
</code></pre>
<a class="header" href="print.html#registering-factory-overrides" id="registering-factory-overrides"><h3>Registering Factory Overrides</h3></a>
<p>Overriding a factory is generally done to allow the test to have more control
over the thing being tested. This is sometimes used to prevent side effects
that are not related to the test (i.e. to prevent network calls), other times
it is used to allow the test to inject some known state to make asserting the
results much easier.</p>
<p>It is currently possible to register custom factories in integration and unit
tests, but not in acceptance tests (without using private API's that is).</p>
<p>As of <a href="https://github.com/emberjs/rfcs/pull/232">emberjs/rfcs#232</a> the
integration/unit test API for this registration is:</p>
<pre><code class="language-js">this.owner.register('service:stripe', MockService);
</code></pre>
<p>This RFC will allow this invocation syntax to work in all test types
(acceptance, integration, and unit).</p>
<a class="header" href="print.html#migration-2" id="migration-2"><h2>Migration</h2></a>
<p>It is important that both the existing acceptance testing system, and the
newly proposed system can co-exist together. This means that new tests can be generated
in the new style while existing tests remain untouched.</p>
<p>However, it is likely that
<a href="https://github.com/rwjblue/ember-qunit-codemod">ember-qunit-codemod</a> will be
able to accurately rewrite acceptance tests into the new format.</p>
<a class="header" href="print.html#how-we-teach-this-20" id="how-we-teach-this-20"><h1>How We Teach This</h1></a>
<p>This change requires updates to the API documentation of <code>ember-qunit</code> and the
main Ember guides' testing section. The changes are largely intended to reduce
confusion, making it easier to teach and understand testing in Ember.</p>
<a class="header" href="print.html#drawbacks-39" id="drawbacks-39"><h1>Drawbacks</h1></a>
<ul>
<li>This is a relatively large set of changes that are arguably not needed (things mostly work today).</li>
<li>One of the major hurdles in upgrading larger applications to newer Ember versions, is updating their tests to follow &quot;new&quot; patterns.  This RFC introduces yet another &quot;new&quot; thing (and proposes to deprecate the old thing), and could therefore be considered &quot;just more churn&quot;.</li>
</ul>
<a class="header" href="print.html#alternatives-38" id="alternatives-38"><h1>Alternatives</h1></a>
<ul>
<li>Do nothing?</li>
<li>Make <code>ember-native-dom-helpers</code> a default addon (removing the need for DOM interaction helpers proposed here).</li>
</ul>
<ul>
<li>Start Date: 2017-12-10</li>
<li>RFC PR: https://github.com/emberjs/rfcs/pull/276</li>
<li>Ember Issue: https://github.com/emberjs/ember.js/pull/15968</li>
</ul>
<a class="header" href="print.html#summary-40" id="summary-40"><h1>Summary</h1></a>
<p>Introduce <code>{{@foo}}</code> in as a dedicated syntax for a component's template to
refer to named arguments passed in by the caller.</p>
<p>For example, given the invocation <code>{{hello-world name=&quot;Godfrey&quot;}}</code> and this
component template in <code>app/templates/components/hello-world.hbs</code>:</p>
<pre><code class="language-hbs">Hello, {{@name}}
</code></pre>
<p>Ember will render &quot;Hello, Godfrey&quot;.</p>
<a class="header" href="print.html#motivation-41" id="motivation-41"><h1>Motivation</h1></a>
<p>Currently, the way to access named arguments passed in from the caller is to
reference <code>{{name}}</code> in the template. This works because when Ember creates
the component instance, it automatically <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign">assigns</a>
all named arguments as properties on the component instance.</p>
<p>The first problem with this approach is that the <code>{{name}}</code> syntax is highly
ambigious, as it could be referring to a local variable (block param), a
helper or a named argument from the caller (which actually works by accessing
auto-reflected <code>{{this.name}}</code>) or a property on the component class (such as
a computed property).</p>
<p>This can often lead to confusion for readers of the template. Upon encountering
<code>{{foo}}</code> in a component's template, the reader has to check all of
these places: first you need to scan the surrounding lines for block
params with that name; next you check in the helpers folder to see if there
is a helper with that name (it could also be coming from an addon!); then you
check if it is an argument provided by the caller; finally, you check the
component's JavaScript class to look for a (computed) property. If you <em>still</em>
did not find it, maybe it is a named arguments that is passed only sometimes,
or perhaps it is just a leftover reference from a previous refactor?</p>
<p>Providing a dedicated syntax for referring to named arguments will resolve the
ambiguity and greatly improve clarity, especially in big projects with a lot
of files (and uses a lot of addons). (The existing <code>{{this.name}}</code> syntax can
already be used to disambiguate component properties from helpers.)</p>
<p>As an aside, the ambiguity that causes confusion for human readers is also a
problem for the compiler. While it is not the main goal of this proposal,
resolving this ambiguity also helps the rendering system. Currently, the
&quot;runtime&quot; template compiler has to perform a helper lookup for every <code>{{name}}</code>
in each template. It will be able to skip this resolution process and perform
other optimizations (such as reusing the internal <a href="https://github.com/glimmerjs/glimmer-vm/blob/master/guides/04-references.md">reference</a>
object and caches) with this addition.</p>
<p>Another problem with the current approach of automatically &quot;reflecting&quot; named
arguments on the instance is that they can unexpectedly overwrite other
properties defined on the component's class. It also defeats performance
optimizations in JavaScript engines as this approach creates many different
polymorphic &quot;shapes&quot; for instances that otherwise belong to the same
component class.</p>
<p>While this proposal does not directly solve this problem (we are not proposing
that we deprecate or remove the &quot;auto-reflection&quot; on <code>Ember.Component</code>), it
paves the way for a future world where components can work without them.</p>
<p>Notably, the current iteration of the <a href="https://glimmerjs.com/guides/templates-and-helpers">Glimmer Components</a>
have adopted this design for over a year now and the experience has been very
positive. This would be one of the first pieces (admittedly, only a tiny piece)
of the Glimmer.js experiment to make its way into Ember. We think this feature
is small, self-contained but useful enough to be the ideal candidate to kick
off this process.</p>
<a class="header" href="print.html#detailed-design-33" id="detailed-design-33"><h1>Detailed design</h1></a>
<p>This feature was baked into the Glimmer VM very early on. In fact, the
only thing that is stopping them from working in Ember is <a href="https://github.com/emberjs/ember.js/blob/87be17d8e69f83b2abed8c0695f8fa5e4bcae473/packages/ember-template-compiler/lib/plugins/assert-reserved-named-arguments.js">an AST transform</a>
that specifically disallows them. Therefore, &quot;implementing&quot; this feature is
just a matter of deleting that file.</p>
<p>Additionally, the legacy <code>{{attrs.foo}}</code> syntax (which more or less tries to
accomplish the same thing) has actually been <a href="https://github.com/emberjs/ember.js/blob/87be17d8e69f83b2abed8c0695f8fa5e4bcae473/packages/ember-template-compiler/lib/plugins/transform-attrs-into-args.js">implemented using <code>{{@foo}}</code></a>
under-the-hood since Ember 2.10.</p>
<a class="header" href="print.html#reserved-names" id="reserved-names"><h2>Reserved Names</h2></a>
<p>We will reserve <code>{{@args}}</code>, <code>{{@arguments}}</code> and anything that does not
start with a lowercase letter (such as <code>@Foo</code>, <code>@0</code>, <code>@!</code> etc) in the first
version. This is purely speculative and the goal is to carve out some space
for future features. If we don't end up needing them, we can always relax
the restrictions down the road.</p>
<a class="header" href="print.html#how-we-teach-this-21" id="how-we-teach-this-21"><h1>How We Teach This</h1></a>
<p><code>{{@foo}}</code> is the way to access the named arguments passed from the caller.</p>
<p>Since the <code>{{foo}}</code> syntax still works on <code>Ember.Component</code> (which is the
only kind of components available today) via the auto-reflection mechanism,
we are not really in a rush to migrate the community (and the guides, etc)
to using the new syntax. In the meantime, this could be viewed as a tool to
improve clarity in templates, similar to how the optional &quot;explicit <code>this</code>&quot;
syntax (<code>{{this.foo}}</code>).</p>
<p>While we think writing <code>{{@foo}}</code> would be a best practice for new code
going forward, the community can migrate at its own pace one component at a
time.</p>
<p>We can also encourage the community to supplement this effort by wiring
linting tools and code mods.</p>
<a class="header" href="print.html#drawbacks-40" id="drawbacks-40"><h1>Drawbacks</h1></a>
<p>This introduces a new piece of syntax that one would need to learn in order to
understand Ember templates.</p>
<p>This mostly affects &quot;casual&quot; readers (as this should be very easy for an Ember
developer to learn, understand and remember after encounting/learning it for
the first time). However, since these casual readers are also among those
who are most acutely affected by the ambiguity, we believe this is still a
net improvement over the status-quo.</p>
<a class="header" href="print.html#alternatives-39" id="alternatives-39"><h1>Alternatives</h1></a>
<p>We have <code>{{attrs.foo}}</code> today. In React, there is <code>this.props.foo</code>.</p>
<p>Given how common this is, we think it deserves its own dedicated, succinct
syntax. The other alternatives that involve reflecting them on the component
instances also would not allow for the internal optimizations in the Glimmer
VM.</p>
<ul>
<li>Start Date: 2017-12-11</li>
<li>RFC PR: https://github.com/emberjs/rfcs/pull/278</li>
<li>Ember Issue: https://github.com/emberjs/ember.js/pull/15974</li>
</ul>
<a class="header" href="print.html#summary-41" id="summary-41"><h1>Summary</h1></a>
<p>Introduce a low-level &quot;flag&quot; to remove the automatic wrapper <code>&lt;div&gt;</code> for
template-only components (templates in the <code>components</code> folder that do not
have a corresponding <code>.js</code> file).</p>
<p>In other words, given there is NO <code>app/components/hello-world.js</code> and there
exists <code>app/templates/components/hello-world.hbs</code> which contains the
following markup:</p>
<pre><code class="language-hbs">Hello world!
</code></pre>
<p>When this template-only component is invoked as <code>{{hello-world}}</code> with the
flag unset or disabled (i.e. today's semantics), Ember will render:</p>
<pre><code class="language-html">&lt;div id=&quot;ember123&quot; class=&quot;ember-view&quot;&gt;Hello world!&lt;/div&gt;
</code></pre>
<p>When the flag is enabled, the same invocation will render:</p>
<pre><code class="language-html">Hello world!
</code></pre>
<a class="header" href="print.html#motivation-42" id="motivation-42"><h1>Motivation</h1></a>
<p>With today's component system (i.e. <code>Ember.Component</code>), a wrapper element (a
<code>div</code> by default, along with an ID like <code>ember123</code> and the <code>ember-view</code> class)
is automatically added for every component.</p>
<p>Customizing this wrapper element (such as changing the tag name  or removing
it altogether) requires making changes to the component's JavaScript class,
such as:</p>
<pre><code class="language-js">import Component from &quot;@ember/component&quot;;

export Component.extend({
  tagName: &quot;footer&quot;,
  classNames: [&quot;legalese&quot;]
});
</code></pre>
<p>While we acknowledge this API is quite cumbersome, it is sufficient to &quot;get
things done&quot; for regular components, and Glimmer Components will address
the usability aspect once they land.</p>
<p>However, this API does not work for template-only components, as they do
not have a component JavaScript class by definition. Therefore, in practice,
template-only components always come with a <code>&lt;div&gt;</code> wrapper, along with the
default <code>id</code> and <code>class</code> attributes, with no obvious ways to customize it.</p>
<p>This is quite problematic, as it is often desirable to use a template-only
component to organize content that requires a certain markup structure. The
most common workaround for this problem is to use a partial instead, which
comes with <a href="https://github.com/emberjs/rfcs/pull/262">a host of issues</a>. I
will discuss other workarounds in the section below.</p>
<p>This RFC proposes to add a global flag to remove this wrapper element around
template-only components. This will allow the component author to specify the
wrapper element in the component template, offering direct control over the
tag name and other attributes. It would also allow the component to have more
than one top-level element, or none at all.</p>
<p>In other words, this flag changes template-only components in the app to have
&quot;Outer HTML&quot; semantics. <em>What you type is what you get.</em></p>
<p>Notably, <a href="https://glimmerjs.com/guides/templates-and-helpers">Glimmer Components</a>
have adopted the &quot;Outer HTML&quot; semantics long ago and the experience has been
very positive. This would be one of the first pieces of the Glimmer.js experiment
to make its way into Ember. We think this feature is small, self-contained but
useful enough to be integrated back into Ember at this point.</p>
<p>If accepted, this RFC will fully subsume the <a href="https://github.com/emberjs/rfcs/pull/262">Non-context-shifting partials</a>
RFC. We can therefore (at a later time, in a separate RFC) explore deprecating
partials in favor of wrapper-free template-only components.</p>
<a class="header" href="print.html#detailed-design-34" id="detailed-design-34"><h1>Detailed design</h1></a>
<a class="header" href="print.html#api-surface" id="api-surface"><h2>API Surface</h2></a>
<p>We should not expose the flag directly as a public API. Instead, we should
abstract the flag with a &quot;privileged addon&quot; whose only purpose is to enable
the flag. Applications will enable the flag by installing this addon. This
will allow for more flexibility in changing the flag's implementation (the
location, naming, value, or even the existence of it) in the future. From the
user's perspective, it is the <em>addon</em> that provides this functionality. The
flag is simply an internal implementation detail.</p>
<p>We have done this before in other cases (such as the legacy view addon during
the 2.0 transition period), and it has generally worked well.</p>
<p>When landing this feature, it will be entirely opt-in for existing apps, but
the Ember CLI application blueprint should be updated to include the addon by
default. At a later time, we should provide another addon that <em>disables</em> the
flag explicitly (installing both addons would be an install-time error). At
that time, we will issue a deprecation warning if the flag is <em>not set</em>, with
a message that directs the user to install one of the two addons.</p>
<a class="header" href="print.html#single-global-flag" id="single-global-flag"><h2>Single Global &quot;Flag&quot;</h2></a>
<p>The proposed flag will be truly global in scope. That is, setting this flag
will change the semantics of all template-only components in the entire app,
even for components that were included by addons.</p>
<p>However, we believe this would not affect any addon components in practice,
as the predominant pattern for addons to expose components currently
necessitates a JavaScript class. Addon authors would create the component
(with or without a JavaScript class) in the <code>/addon</code> folder, but exposing
it for consumption in apps requires creating a corresponding JavaScript class
in the <code>/app</code> folder to &quot;re-export&quot; the component. Therefore, in practice,
it is not actually possible for addons to have a truly template-only
component today (something to address in a future RFC).</p>
<a class="header" href="print.html#leakage-of-embercomponent-semantics" id="leakage-of-embercomponent-semantics"><h2>Leakage Of <code>Ember.Component</code> Semantics</h2></a>
<p>While the primary purpose of this flag is to remove the wrapper element from
template-only components, there are a few other observable semantics changes
that comes with it as well.</p>
<p>Currently, template-only components are &quot;backed&quot; by an instance of <code>Ember.Component</code>.
That is, Ember will create an instance of <code>Ember.Component</code> and set it as the
<code>{{this}}</code> context for the template.</p>
<p>With the flag enabled, there will be <em>no</em> component instance for the template
and <code>{{this}}</code> will be set to <code>undefined</code> (or <code>null</code>, perhaps). This would
improve performance for template-only components significantly.</p>
<p>Since there is no JavaScript file for the component, this is only observable
in a few limited ways:</p>
<ol>
<li>
<p>The most noticable artifact is the component's arguments will not be
auto-reflected on the component instance (as there is no component
instance at all). Therefore, the only way to access the component's
arguments is to use the <code>{{@foo}}</code> syntax proposed in <a href="https://github.com/emberjs/rfcs/pull/276">RFC #276</a>.</p>
</li>
<li>
<p>Because of the named arguments auto-reflection, it is actually possible
to configure the <code>tagName</code> and classes on the &quot;hidden&quot; component
instance on the invocation (e.g. <code>{{foo-bar tagName=&quot;footer&quot; class=&quot;legalese&quot;}}</code>).
This will obviously stop working, but it is also not necessary anymore
as the component author can simply include the tag in the template.
Alternatively, the component author can choose to leave out the tag
and let the caller wrap it in their template.</p>
</li>
<li>
<p>It is possible (but very rare) to configure global injections on the
component type. Since no component is being instantiated here, those
properties will not be accessible in the template.</p>
<p>More broadly, <code>{{this.foo}}</code> or the shorthand <code>{{foo}}</code> (where it
would have resolved into a <code>this</code> lookup) will always be <code>undefined</code>
(or <code>null</code>, perhaps).</p>
</li>
</ol>
<a class="header" href="print.html#migration-path" id="migration-path"><h2>Migration Path</h2></a>
<p>Given the subtle semantics differences enumerated above, it is
not necessarily safe to simply turn on the flag in bigger applications
as it is quite likely that some of the template-only components might be
relying on one or more of these features. Further, removing the wrapper
element might break the layout.</p>
<p>Therefore, the only safe, mechanical transformation is to generate a
JavaScript file for each template-only component (turning them into non-
template only components). We should supplement the change by providing
a codemod that does this for you.</p>
<p>While this would mean that apps would not be able to immediately take
advantage of the feature, it will open the door for new template-only
components to be written in the new semantics.</p>
<p>The user can also audit the components we identified and decide to
delete the JavaScript and migrate them on a case-by-case basis.</p>
<p>The codemod can also come with a more aggressive (and unsound) mode that
simply wraps each template in a <code>&lt;div&gt;</code> (to avoid breaking layout in most
cases). This might be acceptable for smaller apps.</p>
<p>For what it's worth, the Ember CLI component blueprint always generate a
JavaScript and a template file, so it might not be that common to find
existing template-only components in an average app.</p>
<a class="header" href="print.html#implementation-plan" id="implementation-plan"><h2>Implementation Plan</h2></a>
<p>Finally, for the actual implementation, this would be implemented using
the internal Component Manager API that has already been available for a long
time (and how Curly Components, outlets etc are implemented internally).</p>
<p>It should be very straightforward implementation  essentially just a
Component Manager that requires no capabilities and returns <code>null</code> in
<code>getSelf</code>.</p>
<a class="header" href="print.html#how-we-teach-this-22" id="how-we-teach-this-22"><h1>How We Teach This</h1></a>
<p>Going forward, the &quot;Outer HTML&quot; semantics will be the default for
template-only components, Glimmer Components and other custom component
types (when the Component Manager API is available), so over time it
should feel quite natural. The experience from the Glimmer experiment
has also proven that this is the more natural programming model for
components.</p>
<p>In the mean time, we still have to deal with the consequence that
existing <code>Ember.Component</code> comes with a wrapper element by default. The
mental model for users to understand this is that the <code>Ember.Component</code>
class is what is giving you the wrapper element (therefore, template-only
components, which is not an <code>Ember.Component</code> does not get one of those).</p>
<p>This should feel quite natual, as the component class is where you
configure the wrapper element (and where you would lookup the API
documentation). You could imagine that the <code>Ember.Component</code> is doing
something like this under-the-hood as a convenience feature (which turned
out to be not very convenient after all, but that's a different story):</p>
<pre><code class="language-js">export const Component = Object.extend({
  tagName: &quot;div&quot;,
  classNames: [&quot;ember-view&quot;],

  // This is not real code that exists in the implementation
  render(buffer, template) {
    buffer.append(`&lt;${this.tagName} class=&quot;${this.classNames.join(' ')}&quot;&gt;`);
    buffer.append(template(this));
    buffer.append(`&lt;/${this.tagName}&gt;`);
  }
});
</code></pre>
<a class="header" href="print.html#drawbacks-41" id="drawbacks-41"><h1>Drawbacks</h1></a>
<p>In general, we avoid flags that puts Ember into very different &quot;modes&quot; as
they causes complication across the whole addon ecosystem. However, as
mentioned above, we don't believe this would be the case here.</p>
<a class="header" href="print.html#alternatives-40" id="alternatives-40"><h1>Alternatives</h1></a>
<p>We could keep the current semantics for template-only components. However,
this is usually undesirable, and would only grow to feel more unnatural
as Glimmer Components and friends adopt the &quot;Outer HTML&quot; semantics.</p>
<p>Alternatively, we can make this opt-in per template using a pragma or magic
comment. However, this would be needed for a lot of templates and become
very noisy, and the alternative strategy proposed here (by keeping around
the <code>Ember.Component</code> JavaScript file as needed) would be able to accomplish
the same goal with less noise.</p>
<ul>
<li>Start Date: 2017-12-11</li>
<li>RFC PR: https://github.com/emberjs/rfcs/pull/280</li>
<li>Ember Issue: https://github.com/emberjs/ember.js/pull/15981</li>
</ul>
<a class="header" href="print.html#summary-42" id="summary-42"><h1>Summary</h1></a>
<p>Introduce a low-level &quot;flag&quot; to remove the automatic wrapper <code>&lt;div&gt;</code> around
Ember apps and tests.</p>
<a class="header" href="print.html#motivation-43" id="motivation-43"><h1>Motivation</h1></a>
<p>In Ember applications today, applications are anchored to some existing HTML
element in the page. Usually, this element is the <code>&lt;body&gt;</code> of the document, but it
can be configured to be a different one when the application is defined,
passing a CSS selector to the <code>rootElement</code> property:</p>
<pre><code class="language-js">export default Ember.Application.extend({
  rootElement: '#app'
});
</code></pre>
<p>However, whatever the root is, the application adds another <code>&lt;div&gt;</code> wrapper
that is not required anymore. It's a vestigial remainder of some implementation
detail of how views worked in Ember 1.x. Some sort of wisdom tooth of the original
rendering system that serves no purpose today.</p>
<p>Furthermore, much like a wisdom tooth, it can give us problems. In the past, this element
was configurable using the <code>ApplicationView</code>, but when views were removed we lost that
ability. Right now we are stuck with a wrapper element we can't remove nor customize,
which is why some apps target the selector <code>body &gt; .ember-view</code> to style this element.</p>
<p>Similarly, in testing there is another <code>.ember-view</code> wrapper inside the
<code>#ember-testing</code> container for no good reason.</p>
<p>This RFC proposes to add a global flag to remove those wrapper elements,
effectively making the <code>application.hbs</code> template have &quot;Outer HTML&quot; semantics, which aligns
well with <a href="https://github.com/emberjs/rfcs/pull/278">the changes recently proposed</a>
for template-only components, as well as the way Glimmer apps work.</p>
<p>The same flag will also remove the unnecessary extra wrapper inside the testing
container.</p>
<a class="header" href="print.html#detailed-design-35" id="detailed-design-35"><h1>Detailed design</h1></a>
<a class="header" href="print.html#api-surface-1" id="api-surface-1"><h2>API Surface</h2></a>
<p>The proposed approach is identical to the one proposed in #278, quoted below:</p>
<blockquote>
<p>We should not expose the flag directly as a public API. Instead, we should
abstract the flag with a &quot;privileged addon&quot; whose only purpose is to enable
the flag. Applications will enable the flag by installing this addon. This
will allow for more flexibility in changing the flag's implementation (the
location, naming, value, or even the existence of it) in the future. From the
user's perspective, it is the addon that provides this functionality. The
flag is simply an internal implementation detail.</p>
</blockquote>
<blockquote>
<p>We have done this before in other cases (such as the legacy view addon during
the 2.0 transition period), and it has generally worked well.</p>
</blockquote>
<blockquote>
<p>When landing this feature, it will be entirely opt-in for existing apps, but
the Ember CLI application blueprint should be updated to include the addon by
default. At a later time, we should provide another addon that <em>disables</em> the
flag explicitly (installing both addons would be an install-time error). At
that time, we will issue a deprecation warning if the flag is <em>not set</em>, with
a message that directs the user to install one of the two addons.</p>
</blockquote>
<a class="header" href="print.html#migration-path-1" id="migration-path-1"><h2>Migration Path</h2></a>
<p>Given that this change only affects one single point in your application,
I do not believe we need any specific strategy. If the users want to bring
back the wrapper because it breaks their styles or some other reason,
they can just add it manually on the <code>application.hbs</code> template, with
any class or id they want.</p>
<a class="header" href="print.html#how-we-teach-this-23" id="how-we-teach-this-23"><h1>How We Teach This</h1></a>
<p>This addon will be opt-in, but at some point it will become part of
the default blueprint. This change, rather than introducing a new concept, <em>removes</em>
an old one. Users won't have to google what is the way to remove or customize
the implicit application wrapper of the app (to sadly discover that is not
even possible), but instead they will add a wrapper only if they want,
and in the same way they would add a wrapper in any other point of their application,
with regular Handlebars.</p>
<a class="header" href="print.html#drawbacks-42" id="drawbacks-42"><h1>Drawbacks</h1></a>
<p>There is a possibility that removing the wrapper can break styles for some apps,
but since adding the wrapper back is just editing the <code>application.hbs</code> template,
that is probably a minor drawback.</p>
<p>There is also a non-zero chance that some testing addon is relying on the <code>#ember-testing &gt; .ember-view</code>
HTML hierarchy for some reason, and those addons would have to be updated.</p>
<a class="header" href="print.html#alternatives-41" id="alternatives-41"><h1>Alternatives</h1></a>
<p>Leave things as they are today.</p>
<ul>
<li>Start Date: 2017-12-12</li>
<li>RFC PR: https://github.com/emberjs/rfcs/pull/281</li>
<li>Ember Issue: (leave this empty)</li>
</ul>
<a class="header" href="print.html#summary-43" id="summary-43"><h1>Summary</h1></a>
<p>Install ES5 getters for computed properties on object prototypes, thus
eliminating the need to use <code>this.get()</code> or <code>Ember.get()</code> to access them.</p>
<p>Before:</p>
<pre><code class="language-js">import Object, { computed } from '@ember/object';

const Person = Object.extend({
  fullName: computed('firstName', 'lastName', function() {
    return `${this.get('firstName')} ${this.get('lastName')}`;
  })
});

let chancancode = Person.create({ firstName: 'Godfrey', lastName: 'Chan' });

chancancode.get('fullName'); // =&gt; 'Godfrey Chan'

chancancode.set('firstName', 'po');

chancancode.get('fullName'); // =&gt; 'po Chan'

let { firstName, lastName, fullName } = chancancode.getProperties('firstName', 'lastName', 'fullName');
</code></pre>
<p>After:</p>
<pre><code class="language-js">import Object, { computed } from &quot;@ember/object&quot;;

const Person = Object.extend({
  fullName: computed('firstName', 'lastName', function() {
    return `${this.firstName} ${this.lastName}`;
  })
});

let chancancode = Person.create({ firstName: 'Godfrey', lastName: 'Chan' });

chancancode.fullName; // =&gt; 'Godfrey Chan'

chancancode.set('firstName', 'po');

chancancode.fullName; // =&gt; 'po Chan'

let { firstName, lastName, fullName } = chancancode; // No problem!
</code></pre>
<a class="header" href="print.html#motivation-44" id="motivation-44"><h1>Motivation</h1></a>
<p>Ember inherited its computed properties functionality from <a href="http://guides.sproutcore.com/core_concepts_kvo.html">SproutCore</a>.
The feature was designed at a time before <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/get">ES5 getters</a>
were widely available. This necessitated using a special function such as
<code>this.get()</code> or <code>Ember.get()</code> to access the values of computed properties.</p>
<p>Since all of our <a href="https://github.com/emberjs/rfcs/pull/252">target browsers</a>
support ES5 getters now, we can drop the need of this special function,
improving developer ergonomics and interoperability between other libraries
and tooling (such as TypeScript).</p>
<p>Note that at present, using <code>this.set()</code> or <code>Ember.set()</code> is still mandatory
for the property to recompute properly. In the future, we might be able to
loosen this requirement, perhaps with the help of ES5 setters. However, that
would require more design and is out-of-scope for this RFC.</p>
<p><code>this.get()</code> and <code>Ember.get()</code> will still work. This RFC does not propose
removing or deprecating them in the near term. They support other use cases
that ES5 getters do not, such as &quot;safe&quot; path chaining (<code>get('foo.bar.baz')</code>)
and <code>unknownProperty</code> (and Proxies by extension), so any future plans to
deprecate them would have to take these features into account.</p>
<p>Addon authors would likely need to continue using <code>Ember.get()</code> for at least
another two LTS cycles (8 releases) to support older versions of Ember (and
possibly longer to support proxies). It is, however, very unlikely that the
everyday user would need to use this.</p>
<a class="header" href="print.html#detailed-design-36" id="detailed-design-36"><h1>Detailed design</h1></a>
<p>The computed property function, along with any caches, can be stored in the
object's &quot;meta&quot;. We will then define a getter on the object's prototype to
compute the value.</p>
<p>One caveat is that the computed property function is currently stored on the
instances for implementation reasons that are no longer relevant. However,
it is possible that some developers have observed their existance and have
accidentally relied on these private semantics (e.g. <code>chancancode.fullName.get()</code>
or <code>chancancode.fullName.isDescriptor</code>).</p>
<p>Before landing this change, we should turn the property into an assertion
so that in these unlikely scenarios, developers will at least receive
some warning.</p>
<p>Another thing to consider is that there is this Little Known Trick to add
Computed Properties to POJOs:</p>
<pre><code class="language-js">import { computed, get } from &quot;@ember/object&quot;;

let foo = {
  bar: computed(function() { return 'bar'; })
};

get(foo, 'bar'); // =&gt; 'bar'
</code></pre>
<p>In this case, there is no opportunity for us to install an ES5 getter, and
<code>Ember.get</code> is the only solution. This is very rare in practice and is more
or less just a party trick. We should deprecate this use case (in <code>Ember.get</code>)
and suggest the alternative:</p>
<pre><code class="language-js">import Object, { computed } from &quot;@ember/object&quot;;

let foo = Object.extend({
  bar: computed(function() { return 'bar'; })
}).create();

foo.bar; // =&gt; 'bar'
</code></pre>
<p>Or simply...</p>
<pre><code class="language-js">let foo = {
  get bar() {
    return 'bar';
  }
};

foo.bar; // =&gt; 'bar'
</code></pre>
<a class="header" href="print.html#how-we-teach-this-24" id="how-we-teach-this-24"><h1>How We Teach This</h1></a>
<p>For the most part, this RFC <em>removes</em> a thing that we need to teach new
users.</p>
<p>It might, however, come across as slightly strange that <code>set()</code> is still
required. However, many other libraries share the same model, and
empricially, this does not appear to be an issue. For example, in React,
you can freely access <code>this.state.foo</code> but must use <code>this.setState('foo', ...)</code>
to update it. Even Vue has <a href="https://vuejs.org/v2/api/#Vue-set">the same API</a>
for some cases.</p>
<p>The mental model for this is that you must use the <code>set()</code> in order for
Ember to notice your mutations, so that it can update the caches, rerender
things on the screen, etc.</p>
<p>As for users who already learned to use <code>get()</code> everywhere, that would
continue to work. Ideally, this would be a Cool Trick they pick up some day
(as in &quot;Oh, I don't have to do <em>that</em> anymore? Cool.&quot;), at which point the
old habit would quickly die. If this turned out to be too confusing, we
could always explore deprecating <code>this.get()</code>; we will just have to weigh
the cost-benefits of the confusion (if any) versus churn.</p>
<a class="header" href="print.html#drawbacks-43" id="drawbacks-43"><h1>Drawbacks</h1></a>
<p>As mentioned, not removing <code>set()</code> at the same time might be a source of
confusion. However, removing <code>set()</code> would require significantly more
upfront design work, and it <a href="https://vuejs.org/v2/guide/reactivity.html#Change-Detection-Caveats">might not even be possible</a>
to completely remove the need of <code>set()</code> (as the system is designed today)
in all cases (see <code>Vue.set()</code>).</p>
<p>Since removing <code>get()</code> would unlock so many benefits, and since there are
plenty of other libraries that uses the same model, the case for decoupling
the two seems overwhemlingly positive.</p>
<a class="header" href="print.html#alternatives-42" id="alternatives-42"><h1>Alternatives</h1></a>
<ul>
<li>Hold off until we also remove <code>set</code></li>
<li>Hold off until we transition to something like <a href="https://glimmerjs.com/guides/tracked-properties">Glimmer's <code>@tracked</code></a></li>
</ul>
<p>In my opinion, these alternatives do not make a lot of sense, as neither
of these hypothetical systems appear to require (or would benefit from)
having a user-land getter system.</p>
<ul>
<li>Start Date: 2017-12-21</li>
<li>RFC PR: https://github.com/emberjs/rfcs/pull/286</li>
<li>Ember Issue: https://github.com/emberjs/ember.js/pull/16076</li>
</ul>
<a class="header" href="print.html#block-let-template-helper" id="block-let-template-helper"><h1>Block <code>let</code> template helper</h1></a>
<a class="header" href="print.html#summary-44" id="summary-44"><h2>Summary</h2></a>
<p>Introduce the <code>let</code> template helper in block form.</p>
<a class="header" href="print.html#motivation-45" id="motivation-45"><h2>Motivation</h2></a>
<p>The goal of this RFC is to introduce a <code>let</code> template helper that allows to create new bindings in templates.
The design of this helper is similar to <code>with</code>,
but without the conditional rendering of the block depending on the values passed into the helper.</p>
<p>While the conditional semantics of <code>with</code> are coherent with the other built-in helpers like <code>each</code> and <code>if</code>,
users often find this unexpected.
The fact that only the first positional parameter of <code>with</code> controls whether the block is rendered might also add to the confusion.</p>
<p>Taking an example from <a href="https://github.com/emberjs/rfcs/pull/200">RFC #200</a>,
let's consider we have the following template:</p>
<pre><code class="language-handlebars">Welcome back {{concat (capitalize person.firstName) ' ' (capitalize person.lastName)}}

Account Details:
First Name: {{capitalize person.firstName}}
Last Name: {{capitalize person.lastName}}
</code></pre>
<p>Because you have to know to capitalize every time you want to display a name,
errors might be introduced if we forget to do it when adding the name somewhere else in the template.
Using the <code>let</code> helper, this could be done like so:</p>
<pre><code class="language-handlebars">{{#let (capitalize person.firstName) (capitalize person.lastName)
  as |firstName lastName|
}}
  Welcome back {{concat firstName ' ' lastName}}

  Account Details:
  First Name: {{firstName}}
  Last Name: {{lastName}}
{{/let}}
</code></pre>
<p>Now you can use <code>firstName</code> and <code>lastName</code> inside the <code>let</code> block with the knowledge that that logic is in a single place.</p>
<p>With the introduction of template-only components in <a href="https://github.com/emberjs/rfcs/pull/278">RFC #278</a>,
having the capability to create additional bindings in the template would prove useful.
Another aspect to consider is related to the <a href="https://github.com/emberjs/rfcs/blob/master/text/0226-named-blocks.md">Named Blocks RFC</a>.
In both the case of named blocks and block let, you can achieve most of the same functionality by using components.
The components approach has its own drawbacks, which are explored in Alternatives below.</p>
<a class="header" href="print.html#detailed-design-37" id="detailed-design-37"><h2>Detailed design</h2></a>
<p>The <code>let</code> helper should be implemented as a built-in helper, with the following semantics:</p>
<ul>
<li><strong>Only</strong> the block form is available</li>
<li>The block is always rendered</li>
<li>It should support however many positional arguments are passed to the helper</li>
<li>Positional arguments passed to the helper should be yielded back out in the same order</li>
<li>Inline form issues an error, linking users to documentation</li>
</ul>
<p>There already exists <a href="https://github.com/emberjs/ember.js/blob/9536e137b9e1a39411b7fd4e8ca0e7fbb341ef17/packages/ember-glimmer/tests/integration/syntax/experimental-syntax-test.js#L6-L37">an implementation in the codebase</a> that can be used as a basis.</p>
<a class="header" href="print.html#how-we-teach-this-25" id="how-we-teach-this-25"><h2>How We Teach This</h2></a>
<p>The introduction of the <code>let</code> helper brings no new concepts.
It touches on the concepts of block helpers, how to pass arguments to them,
and how to use block parameters (<code>as |foo|</code>), which should already be introduced in the literature.</p>
<p>Current Ember developers should find it familiar to use <code>let</code>, as it is very similar to <code>with</code>.</p>
<p>JavaScript developers should also be familiar with <code>let</code> bindings,
as recent specifications of the language introduced that keyword.</p>
<p>The Guides already possess a section dedicated to Templates, with multiple mentions of helpers.
<code>let</code> would likely be documented in the <a href="https://guides.emberjs.com/v2.17.0/templates/built-in-helpers/">Built-in Helpers</a> guide alongside the others.</p>
<p>If this RFC is approved, the <code>let</code> will initially only support the block form.
This means that only the following form is available for users:</p>
<pre><code class="language-handlebars">{{#let 1 2 3 as |one two three|}}
  A, B, C, easy as {{one}}, {{two}}, {{three}}
{{/let}}
</code></pre>
<p>This could also be enforced by issuing a helpful error when <code>let</code> is used in the inline form.</p>
<a class="header" href="print.html#drawbacks-44" id="drawbacks-44"><h2>Drawbacks</h2></a>
<p>As is the case when adding any sort of API, we will be increasing the cognitive load of learners and users,
as it is one more piece of information to obtain and retain.</p>
<p>The cost of learning this API is mitigated by the fact that its effects are very localized.
It is a template helper, so it will only affect templates.
It is not required for general usage of Ember, unlike something like <code>link-to</code>,
so you can learn the helper at your own pace.</p>
<p>And lastly, if you do use it or encounter it in code, only the markup inside the <code>{{#let}}{{/let}}</code> block is affected,
making it easier to reason about.</p>
<a class="header" href="print.html#alternatives-43" id="alternatives-43"><h2>Alternatives</h2></a>
<a class="header" href="print.html#inline-form" id="inline-form"><h3>Inline form</h3></a>
<p>At the moment, the only way to introduce a new binding in a template is through block params.
For example, if you are iterating over an array with <code>each</code>, you
introduce a binding named <code>item</code> for the item currently being iterated:</p>
<pre><code class="language-handlebars">{{#each myArray as |item|}}
  I am item {{item}}.
{{/each}}
</code></pre>
<p>The inline form of <code>let</code> would be an additional way of introducing bindings in templates.
Using the names example from the RFC, it would look like the following in inline form:</p>
<pre><code class="language-handlebars">{{let
  firstName=(capitalize person.firstName)
  lastName=(capitalize person.lastName)
}}

Welcome back {{concat firstName ' ' lastName}}

Account Details:
First Name: {{firstName}}
Last Name: {{lastName}}
</code></pre>
<p>This syntax raises questions about the semantics of the inline form,
such as what is the scope of the binding, that are better left to a subsequent RFC.</p>
<a class="header" href="print.html#using-components" id="using-components"><h3>Using components</h3></a>
<p>In a similar situation to <a href="https://github.com/emberjs/rfcs/blob/master/text/0226-named-blocks.md">Named Blocks RFC</a>,
it is also possible to replicate some of the behavior of the proposed <code>let</code> helper using components.
However, using components also presents some drawbacks.</p>
<p>You can extract the template and do:</p>
<pre><code class="language-handlebars">// app/templates/components/person-tile.hbs
Welcome back {{concat firstName ' ' lastName)}}

Account Details:
First Name: {{firstName}}
Last Name: {{lastName}}
</code></pre>
<pre><code class="language-handlebars">{{person-tile firstName=(capitalize person.firstName) lastName=(capitalize person.lastName)}}
</code></pre>
<p>This addresses not having to repeat <code>capitalize</code> wherever the names are used,
but splits the content into multiple files for the sake of it.
While <a href="https://github.com/emberjs/rfcs/blob/master/text/0143-module-unification.md">module unification</a> mitigates the locality problem by putting related files in the same folder,
there is still the overhead of having to consult multiple files.</p>
<p>You can instead use a block version of the component as a wrapper to the content.
Some variations are possible: you can pass data into the component as either positional or named arguments;
you can export either an object with the arguments as keys, or export multiple block parameters.</p>
<p>Passing positional arguments to components is onerous,
and necessitates having a JavaScript file to define which positional arguments it accepts.</p>
<p>Passing named arguments to components would be the closest to <code>let</code>,
but it would still require a componente template file which would yield them as block parameters.</p>
<p>Yielding out the values is where it gets tricky in components,
regardless of returning a hash or multiple block parameters,
due to the lack of a &quot;splat&quot; operator in Handlebars.</p>
<p>Since you cannot do something like this at the moment:</p>
<pre><code class="language-handlebars">// app/templates/components/person-tile.hbs
{{yield ...arguments}}
</code></pre>
<p>You would have to explicitly encode all of the arguments:</p>
<pre><code class="language-handlebars">// app/templates/components/person-tile.hbs
{{yield firstName lastName}}
</code></pre>
<p>Or</p>
<pre><code class="language-handlebars">// app/templates/components/person-tile.hbs
{{yield args=(hash firstName=firstName lastName=lastName)}}
</code></pre>
<p>Leading to some repetition of names.</p>
<p>This makes the solution of using components brittle to changes,
as typos or ordering mistakes can introduce silent errors in your application.</p>
<a class="header" href="print.html#adding-named-arguments-to-with" id="adding-named-arguments-to-with"><h3>Adding named arguments to <code>with</code></h3></a>
<p><a href="https://github.com/emberjs/rfcs/pull/202">RFC #202</a> proposes to add named arguments to <code>with</code>.</p>
<p>I feel it is less practical to add a new mode to the helper where it always renders,
when its semantics are already confusing to users.
The RFC #202 proposal also presents the problem of bringing back context-switching helpers,
as it proposes omitting block arguments (<code>as |bar|</code> in <code>{{#with foo as |bar|}}</code>).</p>
<a class="header" href="print.html#remove-the-conditional-behavior-of-with" id="remove-the-conditional-behavior-of-with"><h3>Remove the conditional behavior of <code>with</code></h3></a>
<p>Making the <code>with</code> helper unconditionally render the block would be a major breaking change of its semantics,
and would likely affect existing applications in insidious ways.
For this reason, I reject this alternative out of the gate.</p>
<a class="header" href="print.html#support-let-via-the-ember-let-addon" id="support-let-via-the-ember-let-addon"><h3>Support <code>let</code> via the <code>ember-let</code> addon</h3></a>
<p>There is an <a href="https://github.com/thefrontside/ember-let"><code>ember-let</code></a> addon which implements both the block and the inline forms of <code>let</code>.
To implement the necessary functionality, the addon had to resort to private API usage, which is brittle and subject to breakage.</p>
<p>Having <code>let</code> available from Ember itself would make sure that it would not be subject to breakage the same way,
and the end user would not have to worry about version compatibility.</p>
<a class="header" href="print.html#unresolved-questions-29" id="unresolved-questions-29"><h2>Unresolved questions</h2></a>
<p>None.</p>
<a class="header" href="print.html#future-work" id="future-work"><h2>Future work</h2></a>
<a class="header" href="print.html#deprecating-with" id="deprecating-with"><h3>Deprecating <code>with</code></h3></a>
<p>With the introduction of the <code>let</code> helper, <code>with</code> should likely be deprecated.</p>
<a class="header" href="print.html#if-let-let-and-others" id="if-let-let-and-others"><h3><code>if-let</code>, <code>let*</code> and others</h3></a>
<p>RFC #200 also proposes the <code>if-let</code> and <code>let*</code> helpers.</p>
<p><code>if-let</code> mimics the behaviour of <code>with</code>,
enabling the user to introduce bindings and conditionally rendering the block.
The advantage of introducing <code>if-let</code> over using <code>with</code> would be to define its semantics without worrying about making breaking changes to <code>with</code>.</p>
<p><code>let*</code> would allow bindings to happen sequentially, that is,
<code>let</code> (<code>{{let* a=1 b=(sum a 5)}}</code> would be valid instead of throwing an error about <code>a</code> in <code>(sum a 5)</code>.</p>
<p>These could also be addressed in subsequent RFCs, focused on the specificities of each proposal.</p>
<ul>
<li>Start Date: 2017-12-22</li>
<li>RFC PR: https://github.com/emberjs/rfcs/pull/287</li>
<li>Ember Issue: (leave this empty)</li>
</ul>
<a class="header" href="print.html#summary-45" id="summary-45"><h1>Summary</h1></a>
<p>Promote the private API <code>{{-in-element}}</code> to public API as <code>{{in-element}}</code>.</p>
<a class="header" href="print.html#motivation-46" id="motivation-46"><h1>Motivation</h1></a>
<p>Sometimes developers need to render content out of the regular HTML flow. This concept is often also
called &quot;portals&quot;. Some components like dropdowns and modals use this technique to render stuff close
to the root of the page to bypass CSS overflow rules. Some apps that are embedded into static pages
even use this technique to update parts of the page <strong>outside</strong> the app itself.</p>
<p>This need need has been covered by solutions developed in the user space but it was so common that
glimmer baked it into the VM in the form of <code>{{-in-element}}</code>, but it remains private (or <em>intimate</em>) API.
People is usually wary of using private APIs (and for good reason) as they may get removed at any time.</p>
<p>If the core team and the community is happy with the current behavior of <code>{{-in-element}}</code> it's
time to make it public.</p>
<a class="header" href="print.html#detailed-design-38" id="detailed-design-38"><h1>Detailed design</h1></a>
<p>The existing API of <code>{{-in-element}}</code> is very simple:</p>
<ul>
<li>It takes a single positional param <code>destinationElement</code> that is a DOM element, and a block.</li>
<li>The given block is rendered not where it is located, but inside the given <code>destination</code> element, at
the end of it if there is any other content on the destination element.</li>
<li>If <code>destinationElement</code> is null/undefined then it doesn't render anything but it doesn't error.</li>
<li>If <code>destinationElement</code> is false/0/&quot;&quot; it raises an assertion in development but fails silently in production.</li>
<li>If <code>destinationElement</code> changes the block is removed from the previous destination and added to the new one. This
process tears down the rendered content on the initial destination and renders it again on the new one, meaning
that any component withing the block will be destroyed and instantiated again (calling the appropiate lifecycle hooks),
so transient HTML state like the value of an input will be lost unless manually preserved somewhere else, like a service.</li>
<li>If the destination element is an invalid value (a string, a number ...) it throws an <code>parent.insertBefore is not a function</code> error. I think
that throwing an error is correct but the error message could be improved.</li>
<li>If the destination element has a different context (like SVG) the content will be appended normally by the glimmer VM,
which doesn't try to validate the correctness of the generated HTML. This is normal behavior in Glimmer, not
an exception, and users must be aware that rendering invalid markup might be interpreted or auto-corrected in
unexpected ways by the browser when in SSR mode.</li>
<li>Rendering into a foreign object (an element within an <code>&lt;iframe&gt;</code>) should be disallowed initially. If someone
asks for this feature it would require an RFC to explore the consequences.</li>
</ul>
<p>Example usage:</p>
<pre><code class="language-hbs">{{#-in-element destinationElement}}
  &lt;div&gt;Some content&lt;/div&gt;
{{/-in-element}}
</code></pre>
<p>The current implementation only suggests creating a new <code>{{in-element}}</code> construct that is a simple
alias of <code>{{-in-element}}</code> with the exact same params and behavior, and then, after a while, remove
the private one.</p>
<p>Although <code>{{-in-element}}</code> is technically private, there there is enough people using it to deserve
a deprecation. I suggest keeping the deprecated private API will until the first LTS release of the
3.X cycle (3.4) to be finally removed in the next one (3.5).</p>
<a class="header" href="print.html#small-proposed-changes" id="small-proposed-changes"><h3>Small proposed changes</h3></a>
<p>There is however one part of the behavior that the core team wants to make explicit before promoting
the private API to public, and that is how the content is added to the destination when there is other
content already there.</p>
<p>The desired behavior is that, by default, the rendered content will <strong>replace all the content of the destination</strong>,
effectively becoming the its <code>innerHTML</code>.
In the current behaviour the rendered content is appended as the end of any existing content. This will still
be supported by passing <code>insertBefore=null</code>, but it will not be the default anymore.
Any other value passed to <code>insertBefore</code> must produce an error.</p>
<a class="header" href="print.html#how-we-teach-this-26" id="how-we-teach-this-26"><h1>How We Teach This</h1></a>
<p>This will be a new build-in helper and must be added to the guides and the API.
For most usages, it will replace some community solution created with the same goal, like
<a href="https://github.com/yapplabs/ember-wormhole">ember-wormhole</a> or <a href="https://github.com/ef4/ember-elsewhere">ember-elsewhere</a>.
It would be for the best to let the authors of those addons know about this feature so they can
deprecate their packages if they feel there is no longer a need for them, or at least update their
Readme files to let their users know that there is a built-in solution in Ember that might cover
their needs.</p>
<a class="header" href="print.html#drawbacks-45" id="drawbacks-45"><h1>Drawbacks</h1></a>
<p>By augmenting the public API of the framework, the framework is committing to support it for the lifespan
of an entire mayor version (Ember 4.0).</p>
<a class="header" href="print.html#alternatives-44" id="alternatives-44"><h1>Alternatives</h1></a>
<p>We can decide that the framework does not want to make public and support this feature, and continue
to rely on community-built addons like we've done until today.</p>
<a class="header" href="print.html#unresolved-questions-30" id="unresolved-questions-30"><h1>Unresolved questions</h1></a>
<p>Do we want to make any improvement to <code>{{-in-element}}</code> before making it public API?</p>
<p>Some possible ideas:</p>
<ul>
<li>Allow to <em>conditionally</em> render the block in place. See https://github.com/DockYard/ember-maybe-in-element</li>
<li>Allow to receive not only DOM elements as first argument, but also strings, representing the ID of
other CSS selector.</li>
<li>Modify or improve the way it behaves during SSR using ember-fastboot.</li>
</ul>
<ul>
<li>Start Date: 2018-01-10</li>
<li>RFC PR: (leave this empty)</li>
<li>Ember Issue: (leave this empty)</li>
</ul>
<a class="header" href="print.html#summary-46" id="summary-46"><h3>Summary</h3></a>
<p>Currently, incrementally experimenting with Ember Data internals is hard both for addon authors
and Ember Data contributors. This RFC rationalizes the internals and establishes clear boundaries
for record data storage and manipulation allowing us to expose a public api for addon authors to experiment with.</p>
<a class="header" href="print.html#motivation-47" id="motivation-47"><h3>Motivation</h3></a>
<p>Externally, addons can customize how apps communicate with the server by implementing the Adapter/Serializer APIs but changing how ED deals with relationships, attribute buckets, rollbacks, dirtyness
and similar issues is extremely challenging and impossible without extremely internal hacks. One can look at popular addons like EmberDataModelFragments
and see how many private APIs they had to override and hack to implement their funcionality.</p>
<p>Internally, while ED is reasonably well factored between data coming into the system through
Adapter/Serializers/IdentityMap/Store and data going out through DS.Model/Snapshots/Adapters/Serializers
, internal handling of the data including relationships and attributes has extremely fuzzy and unclear boundaries.</p>
<p>Data currently lives in internalModels, relationship state objects, computed property caches, relationship
payload caches, etc.</p>
<a class="header" href="print.html#before" id="before"><h4>before</h4></a>
<p><img src="https://user-images.githubusercontent.com/715175/33340994-6380c66a-d432-11e7-9f00-ed905e78915a.png" alt="image" /></p>
<p>This RFC proposes rationalizing and extracting ED's core record data handling layer into a RecordData class.</p>
<a class="header" href="print.html#after" id="after"><h4>after</h4></a>
<p><img src="https://user-images.githubusercontent.com/715175/33341155-e5f170c2-d432-11e7-9c50-4a3e977331fe.png" alt="image" /></p>
<p>This will allow us to rationalize internal ED APIs, establish clearer internal boundaries,
allow experimentation by addon authors, and create a path for internal ED experimentation.</p>
<p>You can think of Record Data as a layer that can receive JSON api payloads for a record,
apply local changes to it, and can be queried for the current state of the data.</p>
<p>Examples of things this would enable:</p>
<ol>
<li>
<p>By shipping a custom RecordData, EmberDataModelFragments can implement a large part of their
funcionality without relying on private apis. Spike at <a href="https://github.com/igorT/ember-data.model-fragments/tree/igor/model-data">model fragments</a></p>
</li>
<li>
<p>A spike of Ember Data backed by Orbit, can be implemented as an addon, where most of the work
is in implementing a Record Data backed by Orbit. Spike at <a href="https://github.com/igorT/data-orbit/tree/orbit-model-data">data-orbit</a></p>
</li>
<li>
<p>By using an ES6 class for Record Data implementation, this brings us closer to an Emberless
Ember Data running.</p>
</li>
<li>
<p>If you needed to implement a GraphQL like projection API, Adapters and Serializers would be enough
for the loading data, but currently there is no good place to handle client side data interactions.
RecordData would make it much easier to have a GraphQL ED addon</p>
</li>
<li>
<p>Certain apps and models have a large amount of read only data, which is currently very performance heavy
to implement in ED. They could use a read only fast record data addon, which would enable a large perf win.</p>
</li>
<li>
<p>Experimenting with schemaless approaches is currently very hard in ED, because internal
models encode assumptions of how attributes and relationships work. Having a swappable RecordData would
make it easier for us to implement schemaless approaches in addons.</p>
</li>
<li>
<p>By having Record Data fully expressed in JSON API apis, the current state of the store becomes serializable.</p>
</li>
</ol>
<p>By designing a public interface for RecordData that dosen't rely on any other part of EDs current system,
we can use RecordData as the main building block around which we can refactor the rest of ED.</p>
<a class="header" href="print.html#detailed-design-39" id="detailed-design-39"><h3>Detailed design</h3></a>
<a class="header" href="print.html#high-level-design" id="high-level-design"><h4>High level design</h4></a>
<p>Ember Data would define a RecordData interface, and ship a default implementation. Addons would
be able to swap their own implementation of the RecordData interface.</p>
<p>RecordData is an interface defining the api for how the store and DS.Models
store and apply changes to data. RecordDatas hold
the backing data for each record, and act as a bridge between the Store, DS.Model, and Snapshots.
It is per record, and defines apis that respond to
store api calls like <code>pushData</code>, <code>adapterDidCommit</code> and DS.Model updates like <code>setAttribute</code>.
RecordData represents the bucket of state that is backing a particular DS.Model.</p>
<p>The store instantiates the RecordData, feeds it JSON API data coming from the server and
tells it about state changes. DS.Model queries the RecordData for the attribute
and relationship values and sends back the updates the user has made.</p>
<p>Other than the <code>storeApisWrapper</code> passed to it, RecordData does not assume existence of
any other Ember or Ember Data object. It is a fully self contained system, that might serve
as a basic building block of non Ember/ED data libraries and could be extracted into a separate
library.</p>
<a class="header" href="print.html#interface" id="interface"><h4>Interface</h4></a>
<p>The interface for RecordData is:</p>
<pre><code class="language-js">export default class RecordData {
  constructor(modelName: string, clientId?: string, id?: string, storeApisWrapper: StoreApisWrapper) {
    /*
      Exposing the entire store api to the RecordData seems very risky and would 
      limit the kind of refactors we can do in the future. We would provide a wrapper
      to the RecordData that would enable funcionality MD absolutely needs 
    */
  }


  /*
    Hooks through which the store tells the Record Data about the data
    changes. They all take JSON API and return a list of keys that the 
    record will need to update
  */

  pushData(data: JsonApi, shouldCalculateChanges: boolean/* if false, don't need to return changed keys*/) {
  }

  adapterDidCommit(data: JsonApi) {
  }

  didCreateLocally(properties) {
  }

  /*
    Hooks through which the store tells RecordData about the lifecycle of the data,
    allowing it to keep track of dirtyness
  */

  adapterWillCommit(modelName: string, id?: string, clientId?: string) {
  }

  saveWasRejected(modelName: string, id?: string, clientId?: string) {
  }

  adapterDidDelete(modelName: string, id?: string, clientId?: string) {
  }

  recordUnloaded(modelName: string, id?: string, clientId?: string) {
  }


  /*
   Rollback handling
  */

  rollbackAttributes(modelName: string, id?: string, clientId?: string) {
  }

  rollbackAttribute(modelName: string, id?: string, clientId?: string, attribute: string) {
  }

  changedAttributes(modelName: string, id?: string, clientId?: string) {
  }

  hasChangedAttributes(modelName: string, id?: string, clientId?: string) {
  }


  /*
    Methods through which DS.Model interacts with RecordData, by setting and getting local state
  */

  setAttr(modelName: string, id?: string, clientId?: string, key: string, value: string) {
  }

  getAttr(modelName: string, id?: string, clientId?: string, key: string) {
  }

  hasAttr(modelName: string, id?: string, clientId?: string, key: string) {
  }

  /*
    Relationships take and return json api resource objects
    The store takes those references and decides whether it needs to load them, or
    it can serve them from the cache
  */

  getHasMany(modelName: string, id?: string, clientId?: string, key: string) {
  }
  
  addToHasMany(modelName: string, id?: string, clientId?: string, key: string, jsonApiResources, idx: number) {
  }

  removeFromHasMany(modelName: string, id?: string, clientId?: string, key: string, jsonApiResources) {
  }

  setHasMany(modelName: string, id?: string, clientId?: string, key: string, jsonApiResources) {
  }

  getBelongsTo(modelName: string, id?: string, clientId?: string, key: string) {
  }

  setBelongsTo(modelName: string, id?: string, clientId?: string, key: string, jsonApiResource) {
  }

</code></pre>
<pre><code class="language-js">
export default class StoreApiWrapper {
  /* clientId is used as a fallback in the case of client side creation */
  createRecordDataFor(modelName, id, clientId)
  notifyPropertyChanges(modelName, id, clientId, keys)
  /* 
  in order to not expose ModelClasses to RecordData, we need to supply it with
  model schema information. Because a schema design is out of scope for this RFC,
  for now we expose these two methods we intend to deprecate once we have a schema
  interpretation
   */
  attributesDefinitionFor(modelName, id)
  relationshipsDefinitionFor(modelName, id)

}
</code></pre>
<a class="header" href="print.html#eds-usage-of-recorddata" id="eds-usage-of-recorddata"><h4>ED's usage of RecordData</h4></a>
<p>We would refactor internal models, DS.Models and Snapshots to use RecordData's apis.</p>
<p>Reimplementation of ED current internals on top of RecordData apis would consist of the store
pushing the json api payload to the backing record data and the record data setting up internal
data tracking, as well as storing relationship data on any additional needed recordDatas.</p>
<pre><code class="language-js">let data = {
  data: {
    id:1,
    type: 'user',
    attributes: { name: 'Clemens' },
    relationships: { houses: { data: [{ id: 5, type: 'house' }], links: { related: '/houses' } } }
  }
};

store.push(data);

// internal store method
_internalMethod() {
  let recordData = store.recordDataFor('user', 1, this._storeWrapperApi)
  recordData.pushData(data, false)
}

-&gt;

// model-data.js
pushData(data, shouldCalculateChanges) {
  this._data = this.data.attributes;
  this._setupRelationships(data);
}
-&gt;
// model-data.js
_setupRelationships(data) {
  this.storeWrapperApi.recordDataFor('house', 1);
  ....
}
</code></pre>
<p>The DS.Model interactions would look like:</p>
<pre><code class="language-js">let user = store.peekRecord('user', 1);
user.get('name');
-&gt;
// DS.Model
get(key) {
  let recordData = _internalMethodForGettingTheCorrespondingRecordData(this);
  return recordData.getAttr('name');
}
</code></pre>
<a class="header" href="print.html#relationships" id="relationships"><h4>Relationships</h4></a>
<a class="header" href="print.html#basic-loading-of-relationships" id="basic-loading-of-relationships"><h5>Basic loading of relationships</h5></a>
<p>RecordData's relationship hooks would receive and return json api relationship objects with
additional metadata meaningful to Ember Data.</p>
<p>Lets say that we started off with the same user data as above</p>
<pre><code class="language-js">let data = {
  data: {
    id:1,
    type: 'user',
    attributes: { name: 'Clemens' },
    relationships: { houses: { data: [{ id: 5, type: 'house' }], links: { related: '/houses' } } }
  }
};
let clemens = store.push(data);
</code></pre>
<p>Getting a relationships from Clemens would trace a path from the DS.Model to backing record data,
which would then give the store a json api object, and the store would instantiate a ManyArray
with the records</p>
<pre><code class="language-js">clemens.get('houses');
// DS.Model
get() {
  let clemensRecordData = _internalApiGetsUsTheRecordDataFromIDMMAP();
  return clemens.getHasMany('houses');
}
-&gt;
// Record Data returns
{[ 
  data: { id: 5, type: 'house'},
  links: { related: '/houses' },
  meta: { realMetaFromServer: 'hi', _ED: { hasAllIds: true, needToLoadLink: false } }
}
-&gt; //store takes the above, figures out that it needs to fetch house with id 5
  // and returns a promise which resolves into a ManyArray

</code></pre>
<p>ED extends the relationship payload with a custom meta, which gives the store information
about whether we have information about the entire relationship (we couldn't be sure we
have all the ids if we loaded from the belongsTo side) and whether the link should be refetched
(we might need to refetch the link in the case it potentially changed)</p>
<a class="header" href="print.html#setting-relationship-data-locally" id="setting-relationship-data-locally"><h5>Setting relationship data locally</h5></a>
<p>Similarly to the attributes, changing relationships locally tells record data to update
the backing data store</p>
<pre><code class="language-js">let anotherHouse = store.push({data: { type: 'house', id: '5' }});
clemens.get('houses').then((houses) =&gt; {
  houses.pushObject(anotherHouse);
  -&gt; 
  // internally
  clemensRecordData.addToHasMany('houses', { data: { type: 'house', id: '5' } })
});
</code></pre>
<a class="header" href="print.html#dealing-with-newly-created-records-in-relationships" id="dealing-with-newly-created-records-in-relationships"><h5>Dealing with newly created records in relationships</h5></a>
<p>Unfortunately, because ED does not have first class clientId support, we need a special case
for handling locally created records, and pushing them to relationships.</p>
<p>We extend JSON API resource object with a <code>clientId</code> meta field.
A locally created record, will also have a ED specific internal client id, which will take preference;</p>
<pre><code class="language-js">let newHouse = store.createRecord('house');
clemens.get('houses').then((houses) =&gt; {
  houses.pushObject(newHouse);
  -&gt;
  // internally
  clemensRecordData.addToHasMany('houses', { data: { type: 'house', id: null, { meta: _ED: { clientId: 1}} } })
});
clemens.get('houses') -&gt;
{ data: 
  [ { id: 5, type: 'house'}, 
    { id: null, type: 'house', meta: { _ED: { clientId: 1 } } }],
  links: { related: '/hi' },
  meta: { realMetaFromServer: 'hi', _ED: { loaded: true, needToLoadLink: false } }
}
</code></pre>
<p>ED internals would keep a separate cache of client ID and resolve the correct record</p>
<a class="header" href="print.html#addon-usage" id="addon-usage"><h4>Addon usage</h4></a>
<p>The Store provides a public api for looking up a recordData which the store has not seen before.</p>
<pre><code>recordDataFor(modelName, id, options) {

}
</code></pre>
<p>If an Addon wanted to implement custom data handling functionality, it would subclass the store
and implement their own RecordData handler.</p>
<p>There are three main reasons to do this.</p>
<ol>
<li>Full replacement of Ember Data's data handling mechanisms</li>
</ol>
<p>Best example would be the Ember Data backed by Orbit.js experiment. EmberDataOrbit Addon replaces
Ember Data's backing data implementation with Orbit.js. Most of this work can be done by EmberDataOrbit
replacing ED's Record Data implementation</p>
<pre><code>recordDataFor(modelName, id, options, storeWrapper) {
  return new OrbitRecordData(modelName, id, storeApisWrapper) 
}
</code></pre>
<ol start="2">
<li>Per Model replacement of Ember Data's data handling</li>
</ol>
<p>If a large app was loading thousands of instances of a particular record type, which was read-only,
it could use a read only ED addon, which implemented a simplified RecordData without any change tracking.</p>
<p>The addon would implement a <code>recordDataFor</code> on the store as</p>
<pre><code>recordDataFor(modelName, id, options, storeWrapper) {
  if (addonDecidesIfReadOnly(modelName))  {
    return new ReadOnlyRecordData(modelName, id, storeApisWrapper) 
  }
  return this._super(modelName, id, options, storeWrapper);
}
</code></pre>
<ol start="3">
<li>Adding common funcionality to all ED models</li>
</ol>
<p>Ember Data Model Fragments Addon adds support for handling of embedded data fragments.
In order to manage the handling of fragments, Model Fragments would compose ED's default
RecordData with it's own for handling fragments.</p>
<pre><code class="language-js">recordDataFor(modelName, id, options, storeWrapper) {
  let EDRecordData = this._super(modelName, id, options, storeWrapper);
  return new ModelFragmentsRecordData(modelName, id, options, storeWrapper, EDRecordData);
}
</code></pre>
<p>When receiving a payload, ModelFragments would handle the fragment part and delegate the rest
to ED's implementation</p>
<pre><code class="language-js">pushData(data, shouldCalculateChanges) {
  let keysThatChanged = this.extractAndHandleFragments(data);
  return keysThatChanged.concat(this.EDRecordData.pushData(data, shouldCalculateChanges))
}
</code></pre>
<a class="header" href="print.html#how-we-teach-this-27" id="how-we-teach-this-27"><h3>How we teach this</h3></a>
<p>These APIs are not meant to be used by most users, or app level code, and should be hidden away and
described in an api/guides section meant for ED addon authors. Currently there are a few widely used
addons which would greatly benefit from this, so we can also reach out in person. I have already implemented
a spike of ModelFragments using RecordData. Having couple addons implement different RecordDatas would be
a great way to teach new addon authors about the purpose and implementation of the API.</p>
<a class="header" href="print.html#drawbacks-46" id="drawbacks-46"><h3>Drawbacks</h3></a>
<a class="header" href="print.html#defines-a-bigger-api-surface-area" id="defines-a-bigger-api-surface-area"><h4>Defines a bigger API surface area</h4></a>
<p>This change would increase the public API surface area, in a codebase that is already pretty complex.
However, this would codify and simplifyA APIs addon authors have already had to interact with, while
creating a path for future simplification of the codebase.</p>
<a class="header" href="print.html#it-allows-people-to-do-very-non-standard-changes-that-will-complexify-their-app-needlessly" id="it-allows-people-to-do-very-non-standard-changes-that-will-complexify-their-app-needlessly"><h4>It allows people to do very non-standard changes that will complexify their app needlessly</h4></a>
<p>The main mitigation, is only giving RecordData access to a small amount of knowledge of the external world,
and keeping most APIs pull only thus discouraging trying to do innapropriate work in the RecordData layer</p>
<a class="header" href="print.html#the-new-json-api-interaction-might-preclude-performance-improvements-or-reduce-current-performance" id="the-new-json-api-interaction-might-preclude-performance-improvements-or-reduce-current-performance"><h4>The new JSON api interaction might preclude performance improvements, or reduce current performance</h4></a>
<a class="header" href="print.html#alternatives-45" id="alternatives-45"><h3>Alternatives</h3></a>
<a class="header" href="print.html#we-could-do-this-work-as-an-internal-refactor-and-not-expose-it-to-public" id="we-could-do-this-work-as-an-internal-refactor-and-not-expose-it-to-public"><h4>We could do this work as an internal refactor, and not expose it to public.</h4></a>
<p>I believe that this approach is valid as an internal architecture, so would like to do it even if
we did not expose any of it to addons/apps.</p>
<a class="header" href="print.html#make-recorddatas-looked-up-from-the-resolver" id="make-recorddatas-looked-up-from-the-resolver"><h4>Make RecordData's looked up from the resolver</h4></a>
<p>Currently RecordData is a dumb ES6 class and does not live in the Ember resolver system, for performance
and simplicity reasons. We could alternatively look it up from the resolver, allowing people
to mock it and inject into it easier.</p>
<a class="header" href="print.html#dont-expect-a-per-record-record-data" id="dont-expect-a-per-record-record-data"><h4>Don't expect a per record Record Data</h4></a>
<p>Currently, the MD layer semantics mimics current ED's data storage, where data is stored per record in
internalModels. You could alternatively do this using an app wide cache, like Orbit.js does, or
using any number of other approaches. This approach while valid, would be harder to implement and
it's apis would not map as well to ED behavior.</p>
<a class="header" href="print.html#open-questions" id="open-questions"><h3>Open Questions</h3></a>
<a class="header" href="print.html#versioning-and-stability" id="versioning-and-stability"><h4>Versioning and stability</h4></a>
<p>Our current implementation of <code>internalModel</code> is deeply monkeypatched by at least few addons. I think
we have to consider it as an semi-intimate api, even though it literally has <code>internal</code> in the name(I've been told adding couple undescores to the name would have helped).
Because the number of addons monkeypatching it is limited, we can manually migrate them onto the new
apis. However this requires us to make the new apis public from the get go, and doesn't allow for a long period of api evolution.</p>
<p>The following options are available, none of them great:</p>
<ol>
<li>
<p>Feature flag RecordData work. The scope of this refactor is large enough, that doing a full feature
flagging would be an enourmous burden to bear, and I would advise against it. We can proxy some basic
things, to allow for simpler changes and as a way of warning/deprecating</p>
</li>
<li>
<p>Move from the internals to public RecordData in a single release cycle, and hope public apis we created
make sense, and will not be performance issues in the future. I am reasonably confident having implemented
several addons using RecordData that the basic design works, but things can always come up.</p>
</li>
<li>
<p>Move from private internals to private RecordData, and then feature flag the public apis over couple
versions. In this case the addons monkeypatching the internals, would monkeypatch the new nicer apis
for a while, and then easily switch to the public api. This feel a bit like SemVer cheating.</p>
</li>
</ol>
<a class="header" href="print.html#clientid-passing-to-store-api-methods" id="clientid-passing-to-store-api-methods"><h4>ClientID passing to store api methods</h4></a>
<p>We use <code>recordDataFor(modelName, id, clientId)</code> as the api to look up recordDatas. Passing an often
null clientId seems annoying. Orbit.js uses an identity object instead, and if we did the api would look like <code>recordDataFor(identityObject)</code>, where <code>identityObject</code> would look like <code>{ type, id, meta: { _ED: { clientId }}}</code>. This seem a bit more correct, but doesn't look like any existing ED api, and could create
a lot of allocations.</p>
<a class="header" href="print.html#recorddatas-might-need-to-do-some-global-setupcommunication-how-does-that-work" id="recorddatas-might-need-to-do-some-global-setupcommunication-how-does-that-work"><h4>RecordDatas might need to do some global setup/communication, how does that work?</h4></a>
<p>Normally you would do this in an initializer, but becasue MDs aren't resolved, the only way would be
to do it in RecordDataFor or by using a singleton import. Some ceremony being required to using RecordData
isn't super bad, because it will discourage app authors from customizing it for trivial/innapropriate
things.</p>
<a class="header" href="print.html#what-do-we-do-with-the-record-state-management" id="what-do-we-do-with-the-record-state-management"><h4>What do we do with the record state management?</h4></a>
<p>Currently RecordData has no interaction with the state machine. I think we should punt on this
for now.</p>
<a class="header" href="print.html#-meta--_ed--props-here----alternatives" id="-meta--_ed--props-here----alternatives"><h4>{ meta: { _ED: { props here } } } alternatives?</h4></a>
<p>We could put the ED internal data outside of meta, and keep meta only for actual meta that comes from
the server.</p>
<a class="header" href="print.html#naming-of-everything" id="naming-of-everything"><h4>Naming of everything</h4></a>
<p>Please help with better names for things if you have ideas</p>
<a class="header" href="print.html#snapshot-interface" id="snapshot-interface"><h4>Snapshot interface</h4></a>
<p>How does a Snapshot ask Record Data for it's attributes</p>
<a class="header" href="print.html#real-life-perf-impact" id="real-life-perf-impact"><h4>Real life perf impact</h4></a>
<p>Need benchmarks</p>
<ul>
<li>Start Date: 2018-01-11</li>
<li>RFC PR: github.com/emberjs/rfcs/pull/294</li>
<li>Ember Issue: (leave this empty)</li>
</ul>
<a class="header" href="print.html#make-jquery-optional" id="make-jquery-optional"><h1>Make jQuery optional</h1></a>
<a class="header" href="print.html#summary-47" id="summary-47"><h2>Summary</h2></a>
<p>For the past Ember has been relying and depending on jQuery. This RFC proposes making jQuery optional and having a well
defined way for users to opt-out of bundling jQuery.</p>
<a class="header" href="print.html#motivation-48" id="motivation-48"><h2>Motivation</h2></a>
<a class="header" href="print.html#why-we-dont-need-jquery-any-more" id="why-we-dont-need-jquery-any-more"><h3>Why we don't need jQuery any more</h3></a>
<p>One of the early goals of jQuery was cross-browser normalization, at a time where browser support for web standards was
incomplete and inconsistent, and Internet Explorer 6 was the dominating browser. It provided a useful and convenient
API for DOM traversal and manipulation as well as event handling, that hid the various browser differences and bugs from
the user. For example <code>document.querySelector</code> wasn't a thing at that time, and browsers were using very different event
models (<a href="https://en.wikipedia.org/wiki/DOM_events#Event_handling_models">DOM Level 0, DOM Level 2 and IE's own proprietary model</a>).</p>
<p>But this level of browser normalization is not required anymore, as today's browsers all support the basic DOM APIs well
enough. Even more so that the upcoming Ember 3.0 will drop support for all versions of Internet Explorer except 11.</p>
<p>Furthermore Ember users will need to directly traverse and modify the DOM or manually attach event listeners in very
special cases only. Most of these low level interactions are taken care of by Ember's templates and its underlying
Glimmer rendering engine, as well as action helpers or the component's event handler methods.</p>
<p>So having jQuery included by default does not provide that much value to users most of the time, and Ember itself is
expected to be fully functional and tested without jQuery, presumably for the upcoming 3.0 stable release.</p>
<a class="header" href="print.html#what-are-the-drawbacks-of-bundling-jquery" id="what-are-the-drawbacks-of-bundling-jquery"><h3>What are the drawbacks of bundling jQuery</h3></a>
<p>The major drawback is the increased bundle size, which amounts to <a href="https://mathiasbynens.be/demo/jquery-size">~29KB</a>
(minified and gzipped). This not only increases the loading time, but also parse and compile times, thus increasing the
total time to interactive. This is especially true for mobile devices, where slow connectivity and weak CPU performance
is not uncommon.</p>
<p>Having jQuery not included will improve the suitability of Ember for mobile applications considerably. Even
if the raw number is not that huge, it all adds up. And it plays together with other efforts to make leaner Ember builds
possible, like enabling tree shaking with the new <a href="https://github.com/emberjs/rfcs/blob/master/text/0176-javascript-module-api.md">Module API</a>,
moving code from core to addons (e.g. the <a href="https://github.com/emberjs/rfcs/blob/master/text/0236-deprecation-ember-string.md"><code>Ember.String</code> deprecation</a>)
or the <a href="https://github.com/emberjs/rfcs/blob/explode/text/0000-explode.md">&quot;Explode RFC&quot;</a>. In that regard removing the
dependency on jQuery is a rather low hanging fruit with an high impact.</p>
<a class="header" href="print.html#but-this-is-already-possible-why-this-rfc" id="but-this-is-already-possible-why-this-rfc"><h3>But this is already possible, why this RFC?</h3></a>
<p>There is indeed a somewhat quirky way to build an <a href="https://github.com/rwjblue/no-jquery-app">app without jQuery</a> even
today.
Although this <em>happens</em> to work, it is not sufficient to consider this officially supported for these reasons:</p>
<ul>
<li>Ember itself must be fully tested to work without jQuery</li>
<li>the public APIs that depend on and/or expose jQuery need to have some well defined behavior when jQuery is not
available</li>
<li>there should be a way to technically opt-out (other than fiddling with <a href="https://github.com/rwjblue/no-jquery-app/commit/34c40fc2cfc5e2ce0c39e5e906448c46af699d26"><code>vendorFiles</code></a>)
that is easier to use, understand and maintain</li>
<li>addons should mostly default to not use jQuery, to make removing jQuery practically possible for their consuming
apps</li>
</ul>
<a class="header" href="print.html#detailed-design-40" id="detailed-design-40"><h2>Detailed design</h2></a>
<a class="header" href="print.html#remove-internal-jquery-usage" id="remove-internal-jquery-usage"><h3>Remove internal jQuery usage</h3></a>
<p>As of writing this, there are <a href="https://github.com/emberjs/ember.js/issues/16058">major efforts</a> underway to remove and
cleanup the Ember codebase and especially its tests from jQuery usage. Having a way to fully test Ember without jQuery
is a prerequisite to officially support jQuery being optional. When this is done, it will enable a &quot;no jQuery&quot; mode,
that will make it not use jQuery anymore, but only native DOM APIs.</p>
<a class="header" href="print.html#add-an-opt-out-flag" id="add-an-opt-out-flag"><h3>Add an opt-out flag</h3></a>
<p>There should be a global flag that will toggle the optional jQuery integration (true by default). When this is disabled,
it will make Ember CLI's build process <em>not</em> include jQuery into the <code>vendor.js</code> bundle, <em>and</em> it will explicitly put
Ember itself into its &quot;no jQuery&quot; mode.</p>
<p>The flag itself will not be made a public API. Rather it will be handled by a privileged addon, that will allow to
disable the integration flag, thus to opt out from jQuery integration. This approach is in line with
<a href="https://github.com/emberjs/rfcs/pull/278">RFC 278</a> and <a href="https://github.com/emberjs/rfcs/pull/280">RFC 280</a>, to allow
for some better implementation flexibility.</p>
<a class="header" href="print.html#introduce-emberjquery-package" id="introduce-emberjquery-package"><h3>Introduce <code>@ember/jquery</code> package</h3></a>
<p>Currently Ember CLI itself is importing jQuery into the app's <code>vendor.js</code> file. To decouple it from this task, and
to allow for some better flexibility in the future, the responsibility for importing jQuery is moved to a dedicated
<code>@ember/jquery</code> addon.</p>
<p>To not create any breaking changes, Ember CLI will have to check the app's dependencies for the presence of this addon.
If it is not present, it will continue importing jQuery <em>unless</em> the jQuery integration flag is disabled.
If it is present, it will stop importing jQuery at all, and delegate this responsibility to the addon.</p>
<p>To nudge users to install <code>@ember/jquery</code> when they need jQuery, some warning/deprecation messages should be issued when
the addon is <em>not</em> installed and the integration flag is either not specified or is set to true. To ease
migration the addon should be placed in the default blueprint (until an eventual more aggressive deprecation of
jQuery). Only in the case the app is actively opting out of jQuery integration the addon is not needed.</p>
<p>The addon itself has to make sure the Ember CLI version in use is at least the one that introduced the above mentioned
logic, to prevent importing jQuery twice.</p>
<a class="header" href="print.html#assertions-for-jquery-based-apis" id="assertions-for-jquery-based-apis"><h3>Assertions for jQuery based APIs</h3></a>
<p>Apart from testing (see below), Ember features some APIs that directly expose jQuery, which naturally cannot continue
to work without it. For these APIs some assertions have to be added when running in &quot;no jQuery&quot; mode (and not in
production), that provide some useful error messages for the developer:</p>
<ul>
<li><code>Ember.$()</code>
should throw an assertion stating that jQuery is not available.</li>
<li><code>this.$()</code> in components
should throw an assertion stating that jQuery is not available and that <code>this.element</code> and native DOM APIs should be
used instead.</li>
</ul>
<a class="header" href="print.html#introducing-ember-jquery-legacy-and-deprecating-jqueryevent-usage" id="introducing-ember-jquery-legacy-and-deprecating-jqueryevent-usage"><h3>Introducing <code>ember-jquery-legacy</code> and deprecating <code>jQuery.Event</code> usage</h3></a>
<p>Event handler methods in components will usually receive an instance of <a href="http://api.jquery.com/category/events/event-object/"><code>jquery.Event</code></a> as an argument, which is very
similar to native event objects, but not exactly the same. To name a few differences, not all properties of the native
event are mapped to the jQuery event, on the other hand a jquery event has a <code>originalEvent</code> property referencing the
native event.</p>
<p>The updated event dispatcher in Ember 3.0 is capable of working without jQuery (similar to what
<code>ember-native-dom-event-dispatcher</code> provided for Ember 2.x). When jQuery is not available, it will naturally not be
able to pass a <code>jquery.Event</code> instance but a native event instead. This creates some ambiguity for addons, as they
cannot know in advance how the consuming app is built (with or without jQuery).</p>
<p>For code that does not rely on any <code>jQuery.Event</code> specific API, there is no need to change anything as it will continue
to work with native DOM events.</p>
<p>But there are cases where jQuery specific properties have to be used (when jQuery events are passed). This is especially
true for the <code>originalEvent</code> property, for example to access <code>TouchEvent</code> properties that are not exposed on the
<code>jQuery.Event</code> instance itself. So there has to be a way to make the code work with either jQuery events or native
events being passed to the event handler (especially important for addons). Moreover this should be done in a way that
uses native DOM APIs only, to support the migration away from jQuery coupled code.</p>
<p>To solve this issue another addon <code>ember-jquery-legacy</code> will be introduced, which for now will only expose a single
<code>normalizeEvent</code> function. This function will accept a native event as well as a jQuery event (possibly distinguishing
between those two modes at build time, based on the jQuery integration flag), but will always return a native event
only.</p>
<p>This will allow addon authors to work with both event types, but start to only use native DOM APIs:</p>
<pre><code class="language-js">import Component from '@ember/component';
import { normalizeEvent } from 'ember-jquery-legacy';

export default Component.extend({
  click(event) {
    let nativeEvent = normalizeEvent(event);
    // from here on use only native DOM APIs...
  }
})
</code></pre>
<p>To encourage addon authors to refactor their jQuery coupled event code, the use of <code>jQuery.Event</code> specific APIs used for
jQuery events passed to component event handlers should be deprecated and a deprecation message be shown when accessing
them (e.g. <code>event.originalEvent</code>). Care must be taken though that this warning will not be issued when <code>normalizeEvent</code>
has to access <code>originalEvent</code>.</p>
<p>Also for apps that do not want to transition away from jQuery and would be overloaded with unnecessary warnings, the
deprecations should be silenced when the jQuery integration flag is explicitly set to true (and not just true by
default). By doing so users effectively state their desire to continue using jQuery, thus any needless churn should
be avoided for them.</p>
<a class="header" href="print.html#testing-1" id="testing-1"><h3>Testing</h3></a>
<p>Ember's test harness has been based on jQuery for a long time. Most global acceptance test helpers like <code>find</code> or
<code>click</code> rely on jQuery. For integration tests the direct use of jQuery like <code>this.$('button').click()</code> to trigger
events or assert the state of the DOM is still the standard, based on <code>this.$()</code> returning a jQuery object representing
the rendered result of the tests <code>render</code> call.</p>
<p>To be able to reliably run tests in a jQuery-less world, we need to run our tests without jQuery being included,
so our test harness has to work without jQuery as well.</p>
<p>Fortunately this is well underway already. <a href="https://github.com/cibernox/ember-native-dom-helpers">ember-native-dom-helpers</a>
introduced native DOM test helpers for integration and acceptance tests as an user space addon. The recent acceptance
testing <a href="https://github.com/emberjs/rfcs/blob/master/text/0268-acceptance-testing-refactor.md">RFC 268</a> provides
similar test helpers, implemented in the <code>@ember/test-helpers</code> package, and envisages deprecating the global test
helpers.</p>
<p>However while the existing jQuery based APIs are still available, when these are used without jQuery they have to throw
an assertion with some meaningful error message:</p>
<ul>
<li>
<p>global acceptance test helpers that expect jQuery selectors (which are a potentially incompatible superset of standard
CSS selectors)</p>
</li>
<li>
<p><code>this.$()</code> in component tests, provided currently by <code>@ember/test-helpers</code> in <code>moduleForComponent</code> and
<code>setupRenderingTest</code></p>
</li>
</ul>
<p>In both cases the error message should state that jQuery is not available and that the native DOM based test helpers
of the <code>@ember/test-helpers</code> package should be used instead.</p>
<p>The transitioning to these new test helpers can be eased through a codemod. For <code>ember-native-dom-helpers</code> there already
exists  <a href="https://github.com/simonihmig/ember-native-dom-helpers-codemod">ember-native-dom-helpers-codemod</a>, which
could be adapted to the very similar RFC 268 based interaction helpers in <code>@ember/test-helpers</code>.</p>
<a class="header" href="print.html#implementation-outline" id="implementation-outline"><h3>Implementation outline</h3></a>
<p>The following outlines how a possible implementation of the jQuery integration flag <em>could</em> look like. This
is just to provide some additional context, but is <em>intentionally not</em> meant to be normative, to allow some flexibility
for the actual implementation.</p>
<p>The addon that will handle the flag is expected to be <a href="https://github.com/emberjs/ember-optional-features">ember-optional-features</a>,
which will read from and write to a <code>config/optional-features.{js,json}</code> file. This will hold the <code>jquery-integration</code>
flag (amongst others). This flag in turn will be added to the <code>EmberENV</code> hash, which will make Ember go into its
&quot;no jQuery&quot; mode when set to <code>false</code>.</p>
<p>Ember CLI and the <code>@ember/jquery</code> addon will also look for <code>jquery-integration</code> in this configuration file, and will
opt-out of importing jQuery when this file is present and the flag is set to <code>false</code>.</p>
<a class="header" href="print.html#how-we-teach-this-28" id="how-we-teach-this-28"><h2>How we teach this</h2></a>
<a class="header" href="print.html#guides" id="guides"><h3>Guides</h3></a>
<p>The existing &quot;Managing Dependencies&quot; chapters in the Ember Guides as well as on ember-cli.com provide a good place to
explain users how to set the jQuery integration flag by means of the mentioned <a href="print.html#add-an-opt-out-flag">privileged addon</a>
that handles this flag.</p>
<p>The section on components should be updated to remove any eventually remaining references to <code>this.$</code>, to not let users
fall into the trap of creating an implicit dependency on jQuery by &quot;accidental&quot; use of it. These should be changed to
refer to their native DOM counterparts like <code>this.element</code> or <code>this.element.querySelector()</code>.</p>
<p>The section on acceptance tests will have been updated as per <a href="https://github.com/emberjs/rfcs/blob/master/text/0268-acceptance-testing-refactor.md">RFC 268</a>
to use the new <code>@ember/test-helpers</code> based test helpers instead of the jQuery based global helpers.</p>
<p>The section on component tests should not use <code>this.$()</code> anymore as well, and instead also according to <a href="https://github.com/emberjs/rfcs/blob/master/text/0268-acceptance-testing-refactor.md">RFC 268</a>
use <code>this.element</code> to refer to the component's root element, and use the new DOM interaction helpers instead of jQuery
events triggered through <code>this.$()</code>.</p>
<a class="header" href="print.html#deprecation-guide" id="deprecation-guide"><h3>Deprecation guide</h3></a>
<p>The deprecation warnings introduced for using <code>jQuery.Event</code> specific APIs should explain the use of the
<code>normalizeEvent</code> helper function to migrate towards native DOM APIs on the one side, and on the other side the effect of
setting the jQuery integration flag to explicitly opt into jQuery usage thus suppressing the warnings.</p>
<a class="header" href="print.html#addon-migration" id="addon-migration"><h3>Addon migration</h3></a>
<p>One of the biggest problems to easily opt-out of jQuery is that many addons still depend on it. Many of these usages
seem to be rather &quot;accidental&quot;, in that the full power of jQuery is not really needed for the given task, and could
be fairly easily refactored to use only native DOM APIs.</p>
<p>For this reason this RFC encourages addon authors to not use jQuery anymore and to refactor existing usages whenever
possible! This certainly does not apply categorically to all addons, e.g. those that wrap jQuery plugins as
components and as such cannot drop this dependency.</p>
<a class="header" href="print.html#ember-try" id="ember-try"><h4>ember-try</h4></a>
<p><code>ember-try</code>, which is used to test addons in different scenarios with different dependencies, should provide some means
to define scenarios without jQuery, based on the jQuery integration flag introduced in this RFC.</p>
<p>Furthermore the Ember CLI blueprint for addons should be extended to include no-jQuery scenarios by default, to make
sure addons don't cause errors when jQuery is not present.</p>
<a class="header" href="print.html#emberobservercom" id="emberobservercom"><h4>emberobserver.com</h4></a>
<p>It would be very helpful to have a clear indication on <a href="https://emberobserver.com/">emberobserver.com</a> which
addons depend on jQuery and which not. This would benefit users as to know which addons they can use without
jQuery, but also serve as an incentive for authors to make their addons work without it.</p>
<p>Given the jQuery integration flag introduced in this RFC, this paves the way to automatically detect addons that are
basically declaring their independence from jQuery by having this flag set to <code>false</code>  (in their own repository).</p>
<a class="header" href="print.html#drawbacks-47" id="drawbacks-47"><h2>Drawbacks</h2></a>
<a class="header" href="print.html#churn-2" id="churn-2"><h3>Churn</h3></a>
<p>A vast amount of addons still depend on jQuery. While as far as this RFC is concerned no jQuery based APIs will be
deprecated and the default will still be to include jQuery, addons are nevertheless encouraged to remove their
dependency on jQuery, which will add some considerable churn to the addon ecosystem. As of writing this, there are:</p>
<ul>
<li><a href="https://emberobserver.com/code-search?codeQuery=Ember.%24">475 addons</a> using <code>Ember.$</code></li>
<li><a href="https://emberobserver.com/code-search?codeQuery=this.%24&amp;fileFilter=addon%2Fcomponents">479 addons</a> using <code>this.$</code> in
components</li>
<li><a href="https://emberobserver.com/code-search?codeQuery=this.%24&amp;fileFilter=tests">994 addons</a> using <code>this.$</code> in tests</li>
</ul>
<p>Among these are still some very essential addons like <code>ember-data</code>, which still relies on <code>$.ajax</code>, see
<a href="https://github.com/emberjs/data/issues/5320">#5320</a>.</p>
<p>A good amount of that churn can be mitigated by having a codemod that migrates tests (see &quot;Testing&quot; above).</p>
<a class="header" href="print.html#alternatives-46" id="alternatives-46"><h2>Alternatives</h2></a>
<p>Continue to depend on jQuery.</p>
<a class="header" href="print.html#unresolved-questions-31" id="unresolved-questions-31"><h2>Unresolved questions</h2></a>
<p>None so far.</p>
<ul>
<li>2018-01-17</li>
<li>RFC PR: 0297</li>
<li>Ember Issue: https://github.com/emberjs/ember.js/issues/16231</li>
</ul>
<a class="header" href="print.html#deprecation-of-emberlogger" id="deprecation-of-emberlogger"><h1>Deprecation of Ember.Logger</h1></a>
<a class="header" href="print.html#summary-48" id="summary-48"><h2>Summary</h2></a>
<p>This RFC recommends the deprecation and eventual removal of <code>Ember.Logger</code>.</p>
<a class="header" href="print.html#motivation-49" id="motivation-49"><h2>Motivation</h2></a>
<p>There are a variety of features of Ember designed to support old browsers,
features that are no longer needed. <code>Ember.Logger</code> came into being because
the browser support for the console was inconsistent. In some browsers,
like Internet Explorer 9, the console only existed when the developer tools
panel was open, which caused null references and program crashes when run
with the console closed. <code>Ember.Logger</code> provided methods that would route to
the console when it was available.</p>
<p>With Ember 3.x, Ember no longer supports these older browsers, and hence this
feature no longer serves a purpose. Removing it will make Ember smaller and
lighter.</p>
<a class="header" href="print.html#detailed-design-41" id="detailed-design-41"><h2>Detailed design</h2></a>
<p>For the most part, this is a 1:1 substitution of the global <code>console</code> object
for <code>Ember.Logger</code>.</p>
<p>Node only added support for <code>console.debug</code> in Node version 9. Where we wish
to support earlier versions of Node, we will need to use <code>console.log</code>, rather than
<code>console.debug</code>, as the replacement for <code>Logger.debug</code>. Apps and addons
which don't care about Node or are specifying Node version 9 as their minimum can
use <code>console.debug</code>.</p>
<p>Internet Explorer 11 and Edge both require console methods to be bound to the
console object when the developer tools are not showing. This diverges from the
expectations of other browsers. Direct calls to console methods will work correctly,
but constructs which involve explicitly or implicitly binding the console methods to
other objects or using them unbound will fail. This is straightforward to work around.</p>
<p>You can address the issue by binding the method to the console object:</p>
<pre><code class="language-javascript">// Before - assigning raw method to a variable for later use
var print = Logger.log; // assigning method to variable
print('Message');

// After - assigning console-bound method to variable for later use
var print = console.log.bind(console);
print('Message');
</code></pre>
<p>In some cases, you can use rest parameter syntax to avoid the issue entirely:</p>
<pre><code class="language-javascript">// Before
Logger.info.apply(undefined, arguments); // or
Logger.info.apply(null, arguments); // or
Logger.info.apply(this, arguments); // or

// After
console.info(...arguments);
</code></pre>
<a class="header" href="print.html#within-the-framework" id="within-the-framework"><h3>Within the framework</h3></a>
<p>Remove the following direct uses of <code>Ember.Logger</code> from the ember.js and
ember-data projects:</p>
<ul>
<li><code>ember-debug</code>:
<ul>
<li>deprecate (<code>ember-debug\lib\deprecate.js</code>) - <code>Logger.warn</code></li>
<li>debug (<code>ember-debug\lib\index.js</code>) - <code>Logger.info</code></li>
<li>warn (<code>ember-debug\lib\warn.js</code>) - <code>Logger.warn</code></li>
</ul>
</li>
<li><code>ember-routing</code> (<code>ember-routing\lib\system\router.js</code>):
<ul>
<li>transitioned to - <code>Logger.log</code></li>
<li>preparing to transition to - <code>Logger.log</code></li>
<li>intermediate-transitioned to - <code>Logger.log</code></li>
</ul>
</li>
<li><code>ember-testing</code>:
<ul>
<li>Testing paused (<code>ember-testing\lib\helpers\pause_test.js</code>) - <code>Logger.info</code></li>
<li>Catch-all handler (<code>ember-testing\lib\test\adapter.js</code>) - <code>Logger.error</code></li>
</ul>
</li>
<li><code>ember-data</code>:
<ul>
<li><code>tests\test-helper.js</code>- <code>Logger.log</code></li>
</ul>
</li>
</ul>
<p>Adjust all test code that redirects logging and sets it back:</p>
<ul>
<li><code>ember\tests\routing\basic_test.js</code> (adjust)</li>
<li><code>ember-application\tests\system\dependency_injection\default_resolver_test.js</code> (adjust)</li>
<li><code>ember-application\tests\system\logging_test.js</code> (remove?)</li>
<li><code>ember-glimmer\tests\integration\helpers\log-test.js</code> (remove?)</li>
</ul>
<p>Note: None of the uses of <code>Ember.Logger</code> in <code>ember.js</code> or <code>ember-data</code> involve
<code>Ember.debug</code>, so that issue doesn't affect the Ember.js code directly.</p>
<p>Add deprecation warnings to the implementation: <code>ember-console\lib\index.js</code>.
Bear in mind that <code>Ember.deprecate</code> in <code>ember-debug</code> currently calls
<code>Logger.warn</code>, so the <code>ember-debug</code> code should be changed <em>first</em> or adding
the deprecation warning will create a deep recursion.</p>
<p>The <code>Ember.assert</code>, <code>Ember.warn</code>, <code>Ember.info</code>, <code>Ember.debug</code>, and
<code>Ember.deprecate</code> methods suppress their output on production builds.
However, they are suppressing them in the <code>ember-debug</code> module, which
currently consumes <code>Ember.Logger</code>, <em>not</em> by <code>Ember.Logger</code> itself. Hence,
replacing calls to <code>Ember.Logger</code> with direct calls to the console will not
affect this behavior.</p>
<a class="header" href="print.html#add-on-developers" id="add-on-developers"><h3>Add-On Developers</h3></a>
<p>The following high-impact add-ons (9 or 10 or a * on EmberObserver) use
<code>Ember.Logger</code> and should probably be given an early heads-up to adjust
their code to use <code>console</code> before this RFC is implemented. This will limit
the level of pain that their users experience when the deprecation is released.</p>
<p>Add-ons that need to also support Ember 2.x will need to make their console
references conditional on console being &quot;truthy&quot;, of course, to support Internet
Explorer 9.</p>
<p>In the order of their number of references to <code>Ember.Logger</code>:</p>
<ul>
<li><code>ember-concurrency</code> (15)</li>
<li><code>ember-cli-deprecation-workflow</code> (9)</li>
<li><code>ember-stripe-service</code> (9)</li>
<li><code>semantic-ui-ember</code> (7)</li>
<li><code>ember-resolver</code> (6)</li>
<li><code>ember-cli-page-object</code> (4)</li>
<li><code>ember-cli-sentry</code> (3)</li>
<li><code>ember-islands</code> (3)</li>
<li><code>ember-states</code> (3)</li>
<li><code>ember-cli-pagination</code> (2)</li>
<li><code>ember-cli-clipboard</code> (1)</li>
<li><code>ember-cli-fastboot</code> (1)</li>
<li><code>ember-elsewhere</code> (1)</li>
<li><code>ember-i18n</code> (1)</li>
<li><code>ember-simple-auth-token</code> (1)</li>
<li><code>ember-svg-jar</code> (1)</li>
<li><code>liquid-fire</code> (1)</li>
</ul>
<p>For details, see https://emberobserver.com/code-search?codeQuery=Ember.Logger.</p>
<a class="header" href="print.html#how-we-teach-this-29" id="how-we-teach-this-29"><h2>How we teach this</h2></a>
<a class="header" href="print.html#communication-of-change" id="communication-of-change"><h3>Communication of change</h3></a>
<p>We need to inform users that <code>Ember.Logger</code> will be deprecated and in what
release it will occur.</p>
<a class="header" href="print.html#official-code-bases-and-documentation-1" id="official-code-bases-and-documentation-1"><h3>Official code bases and documentation</h3></a>
<p>We do not currently actively teach the use of <code>Ember.Logger</code>. We will need to
remove any passing references to <code>Ember.Logger</code> from the Ember guides
from the Super Rentals tutorial, and anywhere else it appears on the website.</p>
<p>Once it is gone from the code, we also need to verify it no longer appears in
the API listings.</p>
<p>We must provide an entry in the deprecation guide for this change:</p>
<ul>
<li>describing relevant divergences remaining in the handling of the console in
Internet Explorer 11 and Edge browsers.</li>
<li>describing the issue with using console.debug on node versions
earlier than Node 9.</li>
<li>describing alternative ways of dealing with eslint's <code>no-console</code> messages.</li>
</ul>
<a class="header" href="print.html#drawbacks-48" id="drawbacks-48"><h2>Drawbacks</h2></a>
<p>191 add-ons in Ember Inspector are using <code>Ember.Logger</code>. It has been there and
documented for a long time. So this deprecation will cause some level of change
on many projects.</p>
<p>This, of course, can be said for almost any deprecation, and Ember's
disciplined approach to deprecation has been repeatedly shown to ease things.
These particular changes are proving easy to locate and replace by hand. Also,
only twenty of those add-ons have more than six references to <code>Ember.Logger</code>.
If this is characteristic of the user base, the level of effort to make
the change, even by hand, should be very small for most users.</p>
<p>Those using <code>Logger.debug</code> as something different from <code>Logger.log</code> may have
at least a theoretical concern. Under the covers <code>Logger.debug</code> only calls
<code>console.debug</code> if it exists, calling <code>console.log</code> otherwise. The only
platform where the difference between the two is visible in the console is on
Safari. We can encourage folks with a tangible, practical concern about this to
speak up during the comment period, but I don't anticipate this will have much
impact.</p>
<a class="header" href="print.html#alternatives-47" id="alternatives-47"><h2>Alternatives</h2></a>
<ol>
<li>
<p>Leave things as they are, perhaps providing an <code>@ember/console</code> module
interface.</p>
</li>
<li>
<p>Extract <code>Ember.Logger</code> into its own (tiny) <code>@ember/console</code> package as
a shim for users.</p>
</li>
</ol>
<a class="header" href="print.html#unresolved-questions-32" id="unresolved-questions-32"><h2>Unresolved questions</h2></a>
<p>None at this point. The answers from prior drafts have been promoted into the text.</p>
<ul>
<li>Start Date: 2018-02-15</li>
<li>RFC PR: https://github.com/emberjs/rfcs/pull/308</li>
<li>Ember Issue:</li>
</ul>
<a class="header" href="print.html#summary-49" id="summary-49"><h1>Summary</h1></a>
<p>Beginning the transition to deprecate the fallback behavior of resolving <code>{{foo}}</code> by requiring the usage of <code>{{this.foo}}</code> as syntax to refer to properties of the templates' backing component. This would be the default behavior in Glimmer Components.</p>
<p>For example, given the following component class:</p>
<pre><code class="language-js">import Component from '@ember/component';
export default Component.extends({
  init() {
    super(...arguments);
    this.set('greeting', 'Hello');
  }
});
</code></pre>
<p>One would refer to the <code>greeting</code> property as such:</p>
<pre><code class="language-hbs">&lt;h1&gt;{{this.greeting}}, Chad&lt;/h1&gt;
</code></pre>
<p>Ember will render &quot;Hello, Chad&quot;.</p>
<p>To make this deprecation tractable, we will provide a codemod for migrating templates.</p>
<a class="header" href="print.html#motivation-50" id="motivation-50"><h1>Motivation</h1></a>
<p>Currently, the way to access properties on a components class is <code>{{greeting}}</code> from a template. This works because the component class is one of the objects we resolve against during the evaluation of the expression.</p>
<p>The first problem with this approach is that the <code>{{greeting}}</code> syntax is ambiguous, as it could be referring to a local variable (block param), a helper with no arguments, a closed over component, or a property on the component class.</p>
<a class="header" href="print.html#exemplar" id="exemplar"><h2>Exemplar</h2></a>
<p>Consider the following example where the ambiguity can cause issues:</p>
<p>You have a component class that looks like the following component and template:</p>
<pre><code class="language-js">import Component from '@ember/component';
import computed from '@ember/computed';

export default Component.extend({
  formatName: computed('firstName', 'lastName', function() {
    return `${this.firstName} ${this.lastName}`;
  });
});
</code></pre>
<pre><code class="language-hbs">&lt;h1&gt;Hello {{formatName}}!&lt;/h1&gt;
</code></pre>
<p>Given <code>{ firstName: 'Chad', lastName: 'Hietala' }</code>, Ember will render the following:</p>
<pre><code class="language-html">&lt;h1&gt;Hello Chad Hietala!&lt;/h1&gt;
</code></pre>
<p>Now some time goes on and someone adds a <code>formatName</code> helper at <code>app/helpers/fortmatName.js</code> that looks like the following:</p>
<pre><code class="language-js">export default function formatName([firstName, lastName]) {
  return `${firstName} ${lastName}`;
}
</code></pre>
<p>Due to the fact that helpers take precedence over property lookups, our <code>{{formatName}}</code> now resolves to a helper. When the helper runs it doesn't have any arguments so our template now renders the following:</p>
<pre><code class="language-html">&lt;h1&gt;Hello !&lt;/h1&gt;
</code></pre>
<p>This can be a refactoring hazard and can often lead to confusion for readers of the template. Upon encountering <code>{{greeting}}</code> in a component's template, the reader has to check all of these places: first, you need to scan the surrounding lines for block params with that name; next, you check in the helpers folder to see if there is a helper with that name (it could also be coming from an addon!); finally, you check the component's JavaScript class to look for a (computed) property.</p>
<p>Like <a href="https://github.com/emberjs/rfcs/blob/68812bf2d439c6bb77ad491e0159b371b68c5c35/text/0276-named-args.md">RFC#0276</a> made argument usage explicit through the <code>@</code> prefix, the <code>this</code> prefix will resolve the ambiguity and greatly improve clarity, especially in big projects with a lot of files (and uses a lot of addons).</p>
<p>As an aside, the ambiguity that causes confusion for human readers is also a problem for the compiler. While it is not the main goal of this proposal, resolving this ambiguity also helps the rendering system. Currently, the &quot;runtime&quot; template compiler has to perform a helper lookup for every <code>{{greeting}}</code> in each template. It will be able to skip this resolution process and perform other optimizations (such as reusing the internal <a href="https://github.com/glimmerjs/glimmer-vm/blob/master/guides/04-references.md">reference</a>
object and caches) with this addition.</p>
<p>Furthermore, by enforcing the <code>this</code> prefix, tooling like the <a href="https://github.com/emberwatch/ember-language-server">Ember Language Server</a> does not need to know about fallback resolution rules. This makes common features like <a href="https://code.visualstudio.com/docs/editor/editingevolved#_go-to-definition">&quot;Go To Definition&quot;</a> much easier to implement since we have semantics that mean &quot;property on class&quot;.</p>
<a class="header" href="print.html#transition-path-8" id="transition-path-8"><h1>Transition Path</h1></a>
<p>We intend this to be a <em>very slow</em> process as we understand it is a large change. Because of this we will be doing a phased rollout to help guide people in transtion. Below is an outline of how we plan to roll this change out.</p>
<p><strong>Phase 1:</strong></p>
<ul>
<li>Add <a href="https://github.com/ember-template-lint/ember-template-lint/pull/392">template lint rule</a> to <a href="https://github.com/ember-template-lint/ember-template-lint">ember-template-lint</a> as an <strong>opt-in</strong> rule</li>
<li>Document the <a href="https://github.com/dyfactor/dyfactor">codemod infrastructure</a> and <a href="https://github.com/dyfactor/dyfactor-plugin-disambiguate-locals">codemod</a>. Make it available for early adopters</li>
<li>Start updating docs to use <code>this.</code></li>
</ul>
<p><strong>Phase 2:</strong></p>
<ul>
<li>Add the lint rule by default <em>in the apps</em> <code>.template-lintrc.js</code></li>
<li>Complete doc migration to use <code>this.</code></li>
</ul>
<p><strong>Phase 3:</strong></p>
<ul>
<li>Enable the lint rule by default in the <code>recommended</code> config</li>
</ul>
<p><strong>Phase 4:</strong></p>
<ul>
<li>Introduce deprecation <strong>app only</strong> fallbacks</li>
</ul>
<p><strong>Phase 5:</strong></p>
<ul>
<li>Introduce deprecation for <strong>any</strong> fallbacks</li>
</ul>
<p><strong>Phase 6:</strong></p>
<ul>
<li>Rev major to 4.0.0</li>
<li>Add assert for fallback behavior</li>
</ul>
<p><strong>Phase 7:</strong></p>
<ul>
<li>Remove fallback functionality in 4.5, post 4.4.0 LTS</li>
</ul>
<a class="header" href="print.html#how-we-teach-this-30" id="how-we-teach-this-30"><h1>How We Teach This</h1></a>
<p><code>{{this.foo}}</code> is the way to access the properties on the component class. This also aligns with property access in JavaScript.</p>
<p>Since the <code>{{this.foo}}</code> syntax has worked in Ember.Component (which is the only kind of component available today) since the 1.0 series, we are not really in a rush to migrate the community (and the guides, etc) to using the new syntax. In the meantime, this could be viewed as a tool to improve clarity in templates.</p>
<p>While we think writing <code>{{this.foo}}</code> would be a best practice for new code going forward, the community can migrate at its own pace one component at a time. However, once the fallback functionality is eventually removed this will result in a &quot;Helper not found&quot; error.</p>
<a class="header" href="print.html#syntax-breakdown" id="syntax-breakdown"><h2>Syntax Breakdown</h2></a>
<p>The follow is a breakdown of the different forms and what they mean:</p>
<ul>
<li><code>{{@foo}}</code> is an argument passed to the component</li>
<li><code>{{this.foo}}</code> is a property on the component class</li>
<li><code>{{#with this.foo as |foo|}} {{foo}} {{/with}}</code> the <code>{{foo}}</code> is a local</li>
<li><code>{{foo}}</code> is a helper</li>
</ul>
<a class="header" href="print.html#drawbacks-49" id="drawbacks-49"><h1>Drawbacks</h1></a>
<p>The largest downside of this proposal is that it makes templates more verbose, causing developers to type a bit more. This will also create a decent amount of deprecation noise, although we feel like tools like <a href="https://github.com/mixonic/ember-cli-deprecation-workflow">ember-cli-deprecation-workflow</a> can help mitigate this.</p>
<a class="header" href="print.html#alternatives-48" id="alternatives-48"><h1>Alternatives</h1></a>
<p>This pattern of having programming model constructs to distinguish between the backing class and arguments passed to the component is not unique to Ember.</p>
<a class="header" href="print.html#what-other-frameworks-do" id="what-other-frameworks-do"><h2>What Other Frameworks Do</h2></a>
<p>React has used <code>this.props</code> to talk about values passed to you and <code>this.state</code> to mean data owned by the backing component class since it was released. However, this approach of creating a specific object on the component class to mean &quot;properties available to the template&quot;, would likely be even more an invasive change and goes against the mental model that the context for the template is the class.</p>
<p>Vue requires enumeration of <code>props</code> passed to a component, but the values in the template suffer from the ambiguity that we are trying to solve.</p>
<p>Angular relies heavily on the dependency injection e.g. <code>@Input</code> to enumerate the bindings that were passed to the component and relies heavily on TypeScript to hide or expose values to templating layer with <code>public</code> and <code>private</code> fields. Like Vue, Angular does not disambiguate.</p>
<a class="header" href="print.html#introduce-yet-another-sigil" id="introduce-yet-another-sigil"><h2>Introduce Yet Another Sigil</h2></a>
<p>We could introduce another sigil to remove ambiguity. This would address the concern about verbosity, however it is now another thing we would have to teach.</p>
<a class="header" href="print.html#change-resolution-order" id="change-resolution-order"><h2>Change Resolution Order</h2></a>
<p>The other option is to reverse the resolution order to prefer properties over helpers. However this has the reverse problem as described in the exemplar.</p>
<a class="header" href="print.html#do-nothing" id="do-nothing"><h2>Do Nothing</h2></a>
<p>I personally don't think this is an option, since the goal is to provide clarity for applications as they evolve over time and to provide a more concise mental model.</p>
<a class="header" href="print.html#unresolved-questions-33" id="unresolved-questions-33"><h1>Unresolved questions</h1></a>
<p>TBD</p>
<ul>
<li>Start Date: 2018-03-09</li>
<li>RFC PR: https://github.com/emberjs/rfcs/pull/311</li>
<li>Ember Issue: (leave this empty)</li>
</ul>
<a class="header" href="print.html#angle-bracket-invocation" id="angle-bracket-invocation"><h1>Angle Bracket Invocation</h1></a>
<a class="header" href="print.html#summary-50" id="summary-50"><h2>Summary</h2></a>
<p>This RFC introduces an alternative syntax to invoke components in templates.</p>
<p>Examples using the classic invocation syntax:</p>
<pre><code class="language-hbs">{{site-header user=this.user class=(if this.user.isAdmin &quot;admin&quot;)}}

{{#super-select selected=this.user.country as |s|}}
  {{#each this.availableCountries as |country|}}
    {{#s.option value=country}}{{country.name}}{{/s.option}}
  {{/each}}
{{/super-select}}
</code></pre>
<p>Examples using the angle bracket invocation syntax:</p>
<pre><code class="language-hbs">&lt;SiteHeader @user={{this.user}} class={{if this.user.isAdmin &quot;admin&quot;}} /&gt;

&lt;SuperSelect @selected={{this.user.country}} as |Option|&gt;
  {{#each this.availableCountries as |country|}}
    &lt;Option @value={{country}}&gt;{{country.name}}&lt;/Option&gt;
  {{/each}}
&lt;/SuperSelect&gt;
</code></pre>
<a class="header" href="print.html#motivation-51" id="motivation-51"><h2>Motivation</h2></a>
<p>The original <a href="https://github.com/emberjs/rfcs/pull/60">angle bracket components</a>
RFC focused on capitalizing on the opportunity of switching to the new syntax
as an opt-in to the &quot;new-world&quot; components programming model.</p>
<p>Since then, we have switched to a more iterative approach, favoring smaller
RFCs focusing on one area of improvment at a time. Collectively, these RFCs
have largely accomplished the goals in the original RFC without the angle
bracket opt-in.</p>
<p>Still, separate from other programming model improvements, there is still a
strong desire from the Ember community for the previously proposed angle
bracket invocation syntax.</p>
<p>The main advantage of the angle bracket syntax is clarity. Because component
invocation are often encapsulating important pieces of UI, a dedicated syntax
would help visually distinguish them from other handlebars constructs, such as
control flow and dynamic values. This can be seen in the example shown above 
the angle bracket syntax made it very easy to see the component invocations as
well as the <code>{{#each}}</code> loop, especially with syntax highlight:</p>
<pre><code class="language-hbs">&lt;SuperSelect @selected={{this.user.country}} as |Option|&gt;
  {{#each this.availableCountries as |country|}}
    &lt;Option @value={{country}}&gt;{{country.name}}&lt;/Option&gt;
  {{/each}}
&lt;/SuperSelect&gt;
</code></pre>
<p>This RFC proposes that we adopt the angle bracket invocation syntax to Ember as
an alternative to the classic (&quot;curlies&quot;) invocation syntax.</p>
<p>Unlike the original RFC, the angle bracket invocation syntax proposed here is
purely syntatical and does not affect the semantics. The invocation style is
largely transparent to the invokee and can be used to invoke both classic
components as well as <a href="https://github.com/emberjs/rfcs/pull/213">custom components</a>.</p>
<p>Since the original angle bracket RFC, we have worked on a few experimental
implementation of the feature, both and in Ember and Glimmer. These experiments
allowed us to attempt using the feature in real apps, and we have learned some
valuable insights throught these usage.</p>
<p>The original RFC proposed using the <code>&lt;foo-bar ...&gt;</code> syntax, which is the same
syntax used by web components (custom elements). While Ember components and web
components share a few similarities, in practice, we find that there are enough
differences that causes the overload to be quite confusing for developers.</p>
<p>In addition, the code needed to render Ember components is quite different
from what is needed to render web components. If they share the same syntax,
the Glimmer template compiler will not be able to differentiate between the two
at build time, thus requiring a lot of extra runtime code to support the
&quot;fallback&quot; scenario.</p>
<p>In conclusion, the ideal syntax should be similar to HTML syntax so it doesn't
feel out of place, but different enough that developers and the compiler can
easier tell that they are not just regular HTML elements at a glance.</p>
<a class="header" href="print.html#detailed-design-42" id="detailed-design-42"><h2>Detailed design</h2></a>
<a class="header" href="print.html#tag-name" id="tag-name"><h3>Tag Name</h3></a>
<p>The first part of the angle bracket invocation syntax is the tag name. While
web components use the &quot;dash rule&quot; to distinguish from regular HTML elements,
we propose to use capital letters to distinguish Ember components from regular
HTML elements and web components.</p>
<p>The invocation <code>&lt;FooBar /&gt;</code> is equivalent to <code>{{foo-bar}}</code>. The tag name will
be normalized using the <code>dasherize</code> function, which is the same rules used by
existing use cases, such as service injections. This allows existing components
to be invoked by the new syntax.</p>
<p>Another benefit of the capital letter rule is that we can now support component
names with a single word, such as <code>&lt;Button&gt;</code>, <code>&lt;Modal&gt;</code> and <code>&lt;Tab&gt;</code>.</p>
<blockquote>
<p>Note: Some day, we may want to explore a file system migration to remove the
need for the normalization rule (i.e. also use capital case in filenames).
However, that is out-of-scope for this RFC, as it would require taking into
consideration existing code (like services), transition paths and codemods.</p>
</blockquote>
<a class="header" href="print.html#arguments" id="arguments"><h3>Arguments</h3></a>
<p>The next part of the invocation is passing arguments to the invoked component.
We propose to use the <code>@</code> syntax for this purpose. For example, the invocation
<code>&lt;FooBar @foo=... @bar=... /&gt;</code> is equivilant to <code>{{foo-bar foo=... bar=...}}</code>.
This matches the <a href="https://github.com/emberjs/rfcs/pull/276">named arguments syntax</a>
in the component template.</p>
<p>If the argument value is a constant string, it can appear verbatim after the
equal sign, i.e. <code>&lt;FooBar @foo=&quot;some constant string&quot; /&gt;</code>. Other values should
be enclosed in curlies, i.e. <code>&lt;FooBar @foo={{123}} @bar={{this.bar}} /&gt;</code>.
Helpers can also be used, as in <code>&lt;FooBar @foo={{capitalize this.bar}} /&gt;</code>.</p>
<a class="header" href="print.html#reserved-names-1" id="reserved-names-1"><h4>Reserved Names</h4></a>
<p><code>@args</code>, <code>@arguments</code> and anything that does not start with a lowercase letter
(such as <code>@Foo</code>, <code>@0</code>, <code>@!</code> etc) are reserved names and cannot be used. These
restrictions may be relaxed in the future.</p>
<a class="header" href="print.html#positional-arguments" id="positional-arguments"><h4>Positional Arguments</h4></a>
<p>Positional arguments (<code>{{foo-bar &quot;first&quot; &quot;second&quot;}}</code>) are not supported.</p>
<a class="header" href="print.html#html-attributes" id="html-attributes"><h3>HTML Attributes</h3></a>
<p>HTML attributes can be passed to the component using the regular HTML syntax.
For example, <code>&lt;FooBar class=&quot;btn btn-large&quot; role=&quot;button&quot; /&gt;</code>. HTML attributes
can be interleaved with named arguments (it does not make any difference). This
is a new feature that is not available in the classic invocation style.</p>
<p>These attributes can be accessed from the component template with the new
<code>...attributes</code> syntax, which is available only in element positions, e.g.
<code>&lt;div ...attributes /&gt;</code>. Using <code>...attributes</code> in any other positions, e.g.
<code>&lt;div&gt;{{...attributes}}&lt;/div&gt;</code>, would be a syntax error. It can also be used on
multiple elements in the same template. If attributes are passed but the
component template does not contain <code>...attributes</code> (i.e. the invoker passed
some attributes, but the invokee does not take them), it will be a development
mode error.</p>
<p>It could be thought of that the attributes in the invocation side is stored in
an internal block, and <code>...attributes</code> is the syntax for yielding to this
internal block. Since the <code>yield</code> keyword is not available in element position,
a dedicated syntax is needed.</p>
<p>Classic components (<code>Ember.Component</code>) will implicitly have an <code>...attributes</code>
added to the end of the wrapper element (if <code>tagName</code> is not an empty string),
after any attributes added by the component itself (using <code>attributeBindings</code>,
<code>classNames</code> etc). This means that attributes provided by the caller will
override (replace) those added by the component (except for <code>class</code>, which is
merged).</p>
<a class="header" href="print.html#block" id="block"><h3>Block</h3></a>
<p>A block can be passed to the invokee using the angle bracket invocation syntax.
For example, the invocation <code>&lt;FooBar&gt;some content&lt;/FooBar&gt;</code> is equivalent to
<code>{{#foo-bar}}some content{{/foo-bar}}</code>. As with the classic invocation style,
this block will be accessible using the <code>{{yield}}</code> keyword, or the <code>@main</code>
named argument per the <a href="https://github.com/emberjs/rfcs/blob/master/text/0226-named-blocks.md">named blocks RFC</a>.</p>
<p>Block params are supported as well, i.e. <code>&lt;FooBar as |foo bar|&gt;...&lt;/FooBar&gt;</code>.</p>
<p>There is no dedicated syntax for passing an &quot;else&quot; block directly. If needed,
that can be passed using the named blocks syntax.</p>
<a class="header" href="print.html#closing-tag" id="closing-tag"><h3>Closing Tag</h3></a>
<p>The last piece of the angle bracket invocation syntax is the closing tag, which
is mandatory. The closing tag should match the tag name portion of the opening
tag exactly. If no block is passed, the self-closing tag syntax <code>&lt;FooBar /&gt;</code>
can also be used (in which case <code>{{has-block}}</code> will be false).</p>
<a class="header" href="print.html#dynamic-invocations" id="dynamic-invocations"><h3>Dynamic Invocations</h3></a>
<p>In additional to the static invocation described above (where the tag name is a
statically known component name), it is also possible to use the angle bracket
invocation syntax for dynamic invocations.</p>
<p>The most common use case is for invoking &quot;contextual components&quot;, as shown in
the first example:</p>
<pre><code class="language-hbs">&lt;SuperSelect @selected={{this.user.country}} as |Option|&gt;
  {{#each this.availableCountries as |country|}}
    &lt;Option @value={{country}}&gt;{{country.name}}&lt;/Option&gt;
  {{/each}}
&lt;/SuperSelect&gt;
</code></pre>
<p>Because <code>Option</code> is the name of a local variable (block param), the <code>&lt;Option&gt;</code>
invocation will invoke the yielded value instead of looking for a component
named &quot;option&quot;.</p>
<p>Similar to curly invocations, most valid Handlebars path expressions are
invokable in this manner:</p>
<pre><code class="language-hbs">{{!-- LOCAL VARIABLES --}}

{{#form-for model=user as |f|}}
  {{f.fieldset}}
    {{f.input name=&quot;username&quot; type=&quot;text&quot;}}
    {{f.input name=&quot;password&quot; type=&quot;password&quot; }}
  {{/f.fieldset}}

  {{!-- is equivilant to --}}

  &lt;f.fieldset&gt;
    &lt;f.input @name=&quot;username&quot; @type=&quot;text&quot; /&gt;
    &lt;f.input @name=&quot;password&quot; @type=&quot;text&quot; /&gt;
  &lt;/f.fieldset&gt;
{{/form-for}}

{{!-- NAMED BLOCKS OR CURRIED COMPONENTS --}}

{{@content}}

{{!-- is equivilant to --}}

&lt;@content /&gt;

{{!-- THIS LOOKUP --}}

{{#this.container}}
  {{this.child}}
{{/this.container}}

&lt;this.container&gt;
  &lt;this.child /&gt;
&lt;/this.container&gt;
</code></pre>
<blockquote>
<p>Note: The <a href="https://github.com/emberjs/rfcs/blob/master/text/0226-named-blocks.md">named blocks RFC</a>
proposed to use the <code>&lt;@foo&gt;...&lt;/@foo&gt;</code> syntax on the invocation side to mean
providing a block named <code>@foo</code>, which creates a conflict with this proposal.
<a href="https://github.com/emberjs/rfcs/pull/317">RFC #317</a> propose to change the
block-passing syntax to <code>&lt;@foo=&gt;...&lt;/@foo&gt;</code> to avoid this conflict.</p>
</blockquote>
<p>Notably, based on the rules laied out above, the following is perfectly legal:</p>
<pre><code class="language-hbs">{{!-- DON'T DO THIS --}}

{{#let (component &quot;my-div&quot;) as |div|}}
  {{!-- here, &lt;div /&gt; referes to the local variable, not the HTML tag! --}}
  &lt;div id=&quot;my-div&quot; class=&quot;lol&quot; /&gt;
{{/let}}
</code></pre>
<p>From a programming language's perspective, the semantics here is quite clear. A
local variable is allowed to override (&quot;shadow&quot;) another varible on the outer
scope (the &quot;global&quot; scope, in this case), similar to what is possible in
JavaScript:</p>
<pre><code class="language-js">let console = {
  log() {
    alert(&quot;I win!&quot;);
  }
};

console.log(&quot;Hello!&quot;); // shows alert dialog instead of logging to the console
</code></pre>
<p>While this is semantically unambigious, it is obviously very confusing to the
human reader, and we don't recommend anyone actually doing this.</p>
<p>A previous version of this RFC recommended statically disallowing these cases.
However, after giving it more thoughts, we realized it should not be the
programming language's job to dictate what are considered &quot;good&quot; programming
patterns. By statically disallowing arbitrary expressions, it actually makes it
more difficult to learn and understand the underlying programming model.</p>
<p>Instead, we recommend <a href="https://github.com/ember-cli/rfcs/pull/114">including a template linter</a>
in the default stack and defer to the linter to make such recommendations. At
minimum, we recommend liniting against invoking local variables with lowercase
names without a path segment, regarless of whether the name actually collide
with a known HTML tag  human readers of an Ember template should be able to
safely assume lowercase tags refer to HTML.</p>
<p>Eventually, we might want to provide stronger guidance with via the linter. For
example, we may want to recommend capitalizing invokable local variables, as in
<code>&lt;F.Input /&gt;</code>. We will let the community experiment and coalesce around these
conventions before recommending them by default.</p>
<p>Finally, there are two exceptions to the general rule where certain technically
valid Handlebars path expressions are not supported for dynamic invocations:</p>
<ul>
<li>Implicit <code>this</code> lookups (a.k.a. &quot;property fallback&quot; in <a href="https://github.com/emberjs/rfcs/pull/308">RFC #308</a></li>
<li>Slash lookups</li>
</ul>
<p>First, while <code>{{foo}}</code> or <code>{{Foo}}</code> can normally refer to <code>{{this.foo}}</code> or
<code>{{this.Foo}}</code> normally, allowing this implicitly lookup will mean <em>any</em> tag
in the template (i.e. <code>&lt;foo /&gt;</code> or <code>&lt;Foo /&gt;</code>) can possibly refer to a property
on the current <code>this</code> context.</p>
<p>This ambiguity is highly undesirable for both human readers and the compiler,
therefore implicitly <code>this</code> lookup is not allowed in angle bracket invocations.
This explicit form, <code>&lt;this.foo /&gt;</code> and <code>&lt;this.Foo /&gt;</code> is required.</p>
<p>This requirement aligns well with <a href="https://github.com/emberjs/rfcs/pull/308">RFC #308</a>
and the current curly invocation semantics, due to the <a href="https://github.com/emberjs/rfcs/blob/master/text/0064-contextual-component-lookup.md#component-helper-shorthand">&quot;dot rule&quot;</a>
that requires a dot in the path. Note that this is actually more restrictive
than the proposed angle bracket invocation semantics, since it is not possible
to invoke a local variable without a dot:</p>
<pre><code class="language-hbs">{{#super-select selected={{this.user.country}} as |option|&gt;
  {{#each this.availableCountries as |country|}}
    {{!-- this is not legal today, since `option` does not contain a dot --}}
    {{#option value=country}}{{country.name}}{{/option}}
  {{/each}}
{{/super-select}}
</code></pre>
<p>We propose to relax that rule to match the proposed angle bracket invocation
semantics (i.e. allowing local variables without a dot, as well as <code>@names</code>,
but disallowing implicit <code>this</code> lookup).</p>
<p>Second, while Handlebars technically allows <code>{{foo/bar}}</code> as an equivilant
alternative to the <code>{{foo.bar}}</code> path lookup (and therefore <code>foo/bar</code> is
technically a valid Handlebars path expression), it will not be supported in
angle bracket invocation. This is both because the <code>/</code> conflicts with the HTML
closing tag syntax, and the fact that Ember overrides that syntax with a
different semantic.</p>
<p>In today's semantics, <code>{{foo/bar}}</code> does not try to lookup <code>this.foo.bar</code> and
invoke it as a component. Instead, it is used as a filesystem scoping syntax.
Since this feature will be rendered unnecessary with <a href="https://github.com/emberjs/rfcs/blob/master/text/0143-module-unification.md">Module Unification</a>,
we recommend apps using &quot;slash components&quot; to migrate to alternatives provided
by Module Unification (or, alternatively, keep using curly invocations for this
purpose).</p>
<a class="header" href="print.html#how-we-teach-this-31" id="how-we-teach-this-31"><h2>How we teach this</h2></a>
<p>Over time, we will switch to teaching angle bracket invocation as the primary
invocation style for components. The HTML-like syntax should make them feel
more familiar for new developers.</p>
<p>Classic invocation is here to stay  the ability to accept positional arguments
and &quot;else&quot; blocks makes them ideal for control-flow like components such as
<code>{{liquid-if}}</code>.</p>
<a class="header" href="print.html#drawbacks-50" id="drawbacks-50"><h2>Drawbacks</h2></a>
<p>Because angle bracket invocation is designed for the future in mind, allowing
angle bracket invocations on classic components might introduce some temporary
incoherence (such as the interaction between the attributes passing feature and
the &quot;inner HTML&quot; semantics). However, in our opinion, the upside of allowing
incremental migration outweighs the cons.</p>
<a class="header" href="print.html#alternatives-49" id="alternatives-49"><h2>Alternatives</h2></a>
<p>We could just stick with the classic invocation syntax.</p>
<ul>
<li>Start Date: 2018-03-24</li>
<li>RFC PR: https://github.com/emberjs/rfcs/pull/318</li>
<li>Ember Issue: (leave this empty)</li>
</ul>
<a class="header" href="print.html#array-helper" id="array-helper"><h1><code>array</code> helper</h1></a>
<a class="header" href="print.html#summary-51" id="summary-51"><h2>Summary</h2></a>
<p>This RFC proposes to add an <code>array</code> template helper for creating arrays in templates.</p>
<p>The helper would be invoked as <code>(array arg1 ... argN)</code> and return the value <code>[arg1, ..., argN]</code>. For example, <code>(array 'a' 'b' 'c')</code> would return the value <code>['a', 'b', 'c']</code>.</p>
<a class="header" href="print.html#motivation-52" id="motivation-52"><h2>Motivation</h2></a>
<p>Objects (or hashes) and arrays are the two main data structures in JavaScript. Ember already has a <code>hash</code> helper for building objects, so it makes sense to also include an <code>array</code> helper for building arrays.</p>
<a class="header" href="print.html#detailed-design-43" id="detailed-design-43"><h2>Detailed design</h2></a>
<p>The design is straightforward and mirrors the design of the <code>hash</code> helper. In particular, the important thing to note is that if any of the arguments to the <code>array</code> helper change then an entirely new array will be returned, rather than updating the existing array in place.</p>
<p>The implementation would also mirror the <a href="https://github.com/emberjs/ember.js/blob/ec9f4e5e5f4099a77a73bc5a9aa41916f0d15d6d/packages/ember-glimmer/lib/helpers/hash.ts#L49-L51">implementation of the <code>hash</code> helper</a> and would simply capture the positional arguments instead.</p>
<a class="header" href="print.html#how-we-teach-this-32" id="how-we-teach-this-32"><h2>How we teach this</h2></a>
<p>This helper is not an important part of the programming model and can just be mentioned in the <a href="https://emberjs.com/api/ember/release/classes/Ember.Templates.helpers">API docs</a> like its sibling the <code>hash</code> helper.</p>
<a class="header" href="print.html#drawbacks-51" id="drawbacks-51"><h2>Drawbacks</h2></a>
<p>As usual, adding new helpers increases the surface area of the API and file size but in this case it is justified because the file size change is extremely small and its actually filling an existing hole in the API.</p>
<a class="header" href="print.html#alternatives-50" id="alternatives-50"><h2>Alternatives</h2></a>
<p>This helper could be left to addons, and indeed there are addons that include this helper. It's also trivial to generate
your own <code>array</code> helper with <code>ember generate helper array</code>. Humorously, the default helper blueprint generates a helper that already acts like the <code>array</code> helper ;)</p>
<p>Nevertheless, I believe it's preferable to include this helper in Ember to fill the hole in Ember's API.</p>
<ul>
<li>2018-03-24</li>
<li>RFC PR: 322</li>
<li>Ember Issue: (leave this empty)</li>
</ul>
<a class="header" href="print.html#deprecation-of-embercopy-and-embercopyable" id="deprecation-of-embercopy-and-embercopyable"><h1>Deprecation of Ember.copy and Ember.Copyable</h1></a>
<a class="header" href="print.html#summary-52" id="summary-52"><h2>Summary</h2></a>
<p>This RFC recommends the deprecation and eventual removal of <code>Ember.copy</code> and the <code>Ember.Copyable</code> mixin.</p>
<a class="header" href="print.html#motivation-53" id="motivation-53"><h2>Motivation</h2></a>
<p>A deep-copy mechanism is certainly useful, but it is a general JavaScript problem. Ember itself doesn't need to offer one, especially one that Ember itself isn't using internally. This function and its accompanying mixin arrived with SproutCore, a long time ago, and are not used by Ember itself, even though they currently reside in <code>@ember/object/internals</code>.</p>
<p><code>ember-data</code> uses <code>Ember.copy</code> to do deep-copies. However, the <code>ember-data</code> team finds its needs would be better served by a private deep-copy mechanism that doesn't flow inadvertently through external interfaces into the <code>Ember.copy</code> methods of user-supplied objects. These interfaces are not designed to support deep copies of user-supplied data, and it can raise havoc in the form of hard-to-diagnose bugs, especially in test scenarios.</p>
<p>Since <code>ember</code> and <code>ember-data</code> do not intend to use this mechanism going forward, it would be better to remove it from the Ember codebase and extract it into an add-on for those who wish to continue to use it.</p>
<a class="header" href="print.html#detailed-design-44" id="detailed-design-44"><h2>Detailed design</h2></a>
<p>There are four steps to deprecating any function:</p>
<ul>
<li>logging the deprecation in the call</li>
<li>removal of calls to the function from ember and any add-ons that ship with ember-cli</li>
<li>extraction to an add-on</li>
<li>eventual removal of the feature in the stated release (in this case 4.0.0).</li>
</ul>
<p>This RFC deprecates the <code>copy</code> function and <code>Copyable</code> mixin of <code>@ember/object/internals</code>.</p>
<p>Shallow copies of the form  <code>copy(x)</code>  or <code>copy(x, false)</code> can be replaced mechanically with <code>Object.assign({}, x)</code>. The simplest way to deal with deep copies in any situation depends upon the nature of the data involved.</p>
<a class="header" href="print.html#current-internal-uses" id="current-internal-uses"><h3>Current internal uses</h3></a>
<a class="header" href="print.html#ember-source" id="ember-source"><h4><code>ember-source</code></h4></a>
<p>This following modules in <code>packages/ember-runtime/lib</code> implement the code being deprecated:</p>
<ul>
<li><code>copy.js</code> contains the <code>copy()</code> function that will log the deprecation before executing,</li>
<li><code>mixins/copyable.js</code> provides the <code>Copyable</code> mixin, but it contains no executable code to deprecate.</li>
<li><code>mixins/array.js</code> - The <code>NativeArray</code> mixin extends the <code>Copyable</code> mixin and implements <code>copy()</code>.</li>
</ul>
<p>The following tests in <code>packages/ember-runtime/tests</code> use the implementation above:</p>
<ul>
<li><code>core/copy_test.js</code> tests the <code>copy()</code> method itself.</li>
<li><code>copyable-array/copy-test.js</code> tests the <code>copy()</code> method of a <code>NativeArray</code> for identical results.</li>
<li><code>helpers/array.js</code> provides the arrays used by the <code>NativeArray</code> test above.</li>
<li><code>system/native_array/copyable_suite_test.js</code> tests the independence of the results of deep copying a <code>NativeArray</code></li>
</ul>
<p>The route  <code>packages/ember-routing/lib/system/route.js</code> has one shallow copy, but the test  <code>packages/ember/tests/routing/decoupled_basic_test</code> is using deep copy.</p>
<p>The <code>copy()</code> methods in <code>packages/ember-metal/lib/map.js</code> and  <code>chains.js</code> and their use in <code>meta.js</code>, and  <code>map_test.js</code> are unrelated.</p>
<p>At present, the handling of arrays in <code>Ember.copy</code> is inconsistent. <code>NativeArray</code> uses the <code>Copyable</code> mixin and implements a <code>copy</code> method. When calling <code>Ember.copy</code>, passing a <code>NativeArray</code>, it will note that the passed parameter uses <code>Copyable</code> and call the copy method inside  <code>NativeArray</code>. However, the recursive <code>_copy</code> method that <code>Ember.copy</code> calls for other objects has its own generic mechanism for copying arrays. If <code>copy</code> is passed a non-<code>Copyable</code> object that contains a <code>NativeArray</code> as a member, when the recursion gets to that member, it will use the generic mechanism rather than delegating to the <code>copy</code> method within the  <code>NativeArray</code>.</p>
<p>The recursive  <code>_copy</code> method also has an assertion that will fail if it is called with any <code>EmberObject</code> that is not also <code>Copyable</code>. This assertion occurs before (and hence affects) the code which handles arrays, even though, for arrays, the object's <code>copy</code> method isn't then used.</p>
<p>During the deprecation period, the <code>Ember.copy</code> method and the <code>NativeArray.copy</code> methods will carry a deprecation warning. We will remove <code>Copyable</code> from <code>NativeArray</code> and change  <code>Ember.copy</code> to consistently use the common array copy mechanism to copy arrays rather than sometimes delegating. We will move the assertion that an <code>EmberObject</code> must be  <code>Copyable</code> to the clause that handles non-array objects.</p>
<p>We need a way to deprecate use of the <code>Copyable</code> mixin. If the penalty for adding code in such a common place isn't too high, we could have <code>core_object.extend()</code>  check for <code>Copyable</code> and deprecate accordingly. We will also supply a new eslint warning that flags the deprecated use of <code>Copyable</code>. (This may be our first eslint check for deprecations. We may want to consider adding others at the same time.)</p>
<p>Those using the add-on will need to mechanically adjust any uses of  <code>myArray.copy(deep)</code> to  <code>copy(myArray, deep)</code> in order to avoid the deprecation message.</p>
<p>At the end of this period, we will remove the deprecated copy() method, the Copyable mixin, and the deprecated NativeArray.copy() method.</p>
<a class="header" href="print.html#ember-data" id="ember-data"><h4><code>ember-data</code></h4></a>
<p>The following code in <code>ember-data</code> uses <code>copy()</code>, but only for shallow copies:</p>
<ul>
<li><code>addon/-private/system/model/internal-model.js</code> - one use</li>
<li><code>addon/-private/system/snapshot.js</code> - two uses</li>
<li><code>addon/-private/system/store.js</code> - one use</li>
</ul>
<p>All of the following uses in tests perform deep copies:</p>
<ul>
<li><code>tests/integration/adapter/build-url-mixin-test.js</code> - two uses</li>
<li><code>tests/integration/adapter/rest-adapter-test.js</code> - two uses</li>
<li><code>tests/integration/store-test.js</code> - two uses</li>
<li><code>tests/unit/system/relationships/polymorphic-relationship-payloads-test.js</code> - four uses</li>
</ul>
<p>The <code>copy()</code> methods referenced in <code>addon/-private/system.map.js</code> and  <code>addon/-private/system/relationships/state/relationship.js</code> are unrelated.</p>
<p>It would appear that deep copy is used within these packages only during testing, and generally to ensure fresh test data without side-effects.</p>
<a class="header" href="print.html#current-external-uses" id="current-external-uses"><h3>Current external uses</h3></a>
<p>The key considerations for add-ons or apps looking for an alternative to copy() and Copyable are:</p>
<ul>
<li>Do they call <code>copy()</code> to do shallow copies or deep copies?</li>
<li>If deep copies are being performed, are the objects involved POJOs or are they derived from <code>EmberObject</code>?</li>
<li>Do they provide objects that use the <code>Copyable</code> mixin with <code>copy()</code> methods intended for use in deep copies by other classes?</li>
<li>Is the data you are copying the sort of thing where you can do the copy in its behalf, or does it require collaboration from the object itself? Or are the contents so open-ended that you can't possibly know?</li>
</ul>
<p>Shallow copies are directly supported by ES6. It's easy to perform recursive deep copies for most simple POJOs without delegating work to the object you are copying. For more complex data, you may need some kind of recursive delegation. <code>Copyable</code> is a delegation mechanism, and apps and add-ons that require delegation will probably want to use the proposed add-on.</p>
<p>The Code Search capabilities of emberobserver are a wonderful way to get a glimpse of how code in the wild is using particular features.</p>
<p>A quick search of the top-scoring add-on packages revealed that most, but by no means all, of the uses of <code>copy()</code> in the modules were for shallow copies that can be accomplished using Object.assign, so a lot of the code affected by this deprecation can rely on a simple substitution.</p>
<p>Very few packages used <code>Copyable</code> - only 9 across the whole set - and most used the feature for only one class.   <code>ember-data-copyable</code> is probably most wedded to the mechanism: it delivers a  <code>Copyable</code>-based mixin for asynchronous copying.  <code>ember-data-model-fragments</code> has pretty open-ended properties. These add-ons would be likely to use the proposed add-on moving forward.   <code>ember-restless</code>, and <code>ember-calendar</code> appear more bounded. Any deep copy mechanism for POJOs may meet their needs.</p>
<a class="header" href="print.html#add-on" id="add-on"><h3>Add-on</h3></a>
<p>The add-on will supply the <code>copy()</code> function and the <code>Copyable</code> mixin based on the existing code, modified as indicated above for handling of arrays.</p>
<p>We could treat the add-on as the extraction of a feature from the monolithic <code>ember-source</code>, as was recently done for strings. If we choose to frame it in that way, the naming should follow the conventions set out for extracting elements of Ember into their own packages. If we choose not to frame it that way, then naming is one of the things this section should specify clearly.</p>
<a class="header" href="print.html#how-we-teach-this-33" id="how-we-teach-this-33"><h2>How we teach this</h2></a>
<a class="header" href="print.html#communication-of-change-1" id="communication-of-change-1"><h3>Communication of change</h3></a>
<p>We need to inform users that <code>Ember.copy</code> and <code>Ember.Copyable</code> will be dprecated and in what release it will occur. This notification should also point them to the add-on for those who need it.</p>
<a class="header" href="print.html#official-code-bases-and-documentation-2" id="official-code-bases-and-documentation-2"><h3>Official code bases and documentation</h3></a>
<p>We do not actively teach the use of <code>Ember.copy</code>. It doesn't appear anywhere in our guides, website, or tutorial. Once it is gone from the code, we also need to verify it no longer appears in the API listings.</p>
<p>We must provide an entry in the deprecation guide for this change:</p>
<ul>
<li>describing the use of <code>to = Object.assign({},from)</code> for shallow copies.</li>
<li>pointing out viable alternatives for deep copies.</li>
<li>directing heavy users of deep copies to the addon.</li>
</ul>
<a class="header" href="print.html#drawbacks-52" id="drawbacks-52"><h2>Drawbacks</h2></a>
<p>The primary drawback is the API churn of people pulling it out of their code. However, for most uses, the change will be straightforward, and the add-on will be available for the foreseeable future for those who want to continue with the implementation.</p>
<a class="header" href="print.html#alternatives-51" id="alternatives-51"><h2>Alternatives</h2></a>
<p>We could simply leave it in place as a utility for others to use. Even then, it would make sense to split it out into its own module, as has already been done for strings, so the work would be much the same.</p>
<a class="header" href="print.html#unresolved-questions-34" id="unresolved-questions-34"><h2>Unresolved questions</h2></a>
<p>None at the moment...</p>
<ul>
<li>Start Date: 2018-03-28</li>
<li>RFC PR: https://github.com/emberjs/rfcs/pull/324</li>
<li>Ember Issue:</li>
</ul>
<a class="header" href="print.html#summary-53" id="summary-53"><h1>Summary</h1></a>
<p>The aim of this RFC is to deprecate the component's <code>isVisible</code> property.
It is not used by Ember internally and left undefined unless manually set.
It's poorly documented and component visibility it better managed in
template space rather than JS.</p>
<a class="header" href="print.html#motivation-54" id="motivation-54"><h1>Motivation</h1></a>
<p>Setting the isVisible property on a component instance as a way to toggle
the visibility of the component is confusing. The majority of its usage
predates even Ember 1.0.0, and modern Ember applications already completely
avoid using isVisible in favor of simpler conditionals in the template
space.</p>
<p>In addition, when <code>isVisible</code> is used today it often introduces subtle (and
difficult to track down) bugs due to its interaction with the <code>style</code>
attribute (toggling <code>isVisible</code> clobbers any existing content in <code>style</code>).</p>
<p>Simply put, removing <code>isVisible</code> will reduce confusion amongst users.</p>
<a class="header" href="print.html#transition-path-9" id="transition-path-9"><h1>Transition Path</h1></a>
<p>Whenever <code>isVisible</code> is used a deprecation will be issued with a link to
the deprecation guide explaining the deprecation and how to refactor in order
to avoid it.</p>
<p>Given that <code>Component#isVisible</code> is a public API, deprecating now would
schedule for removal in the next major version release (4.0).</p>
<p>There are several options available to hiding elements
such as <code>&lt;div hidden={{boolean}}&gt;&lt;/div&gt;</code>(hidden is valid for all elements
and is semantically correct) or wrapping the component in a template
conditional <code>{{#if}}</code> statement. Components <code>classNames</code> and <code>classNameBindings</code>
could also be used to add hidden classes.</p>
<a class="header" href="print.html#how-we-teach-this-34" id="how-we-teach-this-34"><h1>How We Teach This</h1></a>
<p>The <code>isVisible</code> property is rarely used, the deprecation along with a mention
in a future blog post would be sufficient.</p>
<p>We should consider adding documentation on hiding components to the Ember
guides with the conditional handlebar helper or via the widely supported <code>hidden</code>
attribute.</p>
<pre><code class="language-hbs">{{#if showComponent}}
  {{component}}
{{/if}}

{{! or }}
&lt;div hidden={{isHidden}}&gt;&lt;/div&gt;
</code></pre>
<a class="header" href="print.html#alternatives-52" id="alternatives-52"><h1>Alternatives</h1></a>
<p>An alternative option would be to to keep <code>isVisible</code>.</p>
<ul>
<li>Start Date: (fill me in with today's date, 2018-04-18)</li>
<li>RFC PR: #326</li>
<li>Ember Issue: (leave this empty)</li>
</ul>
<a class="header" href="print.html#ember-data-filter-deprecation" id="ember-data-filter-deprecation"><h1>Ember Data Filter Deprecation</h1></a>
<a class="header" href="print.html#summary-54" id="summary-54"><h2>Summary</h2></a>
<p>Deprecate the <code>store.filter</code> API. This API was previously gated
behind a private <code>ENV</code> variable that was enabled by the addon
<a href="https://github.com/ember-data/ember-data-filter/tree/b62c992186c00dce8cc81f1fb0cf5e2e6fee0f6b#ember-data-filter"><code>ember-data-filter</code></a>.</p>
<a class="header" href="print.html#motivation-55" id="motivation-55"><h2>Motivation</h2></a>
<p>The <code>filter</code> API was a &quot;memory leak by design&quot;. <a href="https://github.com/ember-data/ember-data-filter#recommended-refactor-guide">Patterns exist</a>
with no-worse ergonomics that have better performance and do not incur memory leak penalties.</p>
<p>While the change in ergonomics for end consumers in minimal, the change to <code>ember-data</code> is substantial.
The code for this feature required significant amounts of confusing internal plumbing to ensure that
filters were rerun every time any form of mutation (update, addition, deletion) occurred to any record.</p>
<p>In addition to maintenance costs, this plumbing negatively affects the performance of all <code>RecordArray</code>s,
and slow any operations that count as mutations (such as pushing new records into the store).</p>
<p>By removing this feature, we significantly simplify and streamline the core of <code>Ember Data</code>.</p>
<a class="header" href="print.html#detailed-design-45" id="detailed-design-45"><h2>Detailed design</h2></a>
<p>We will provide 3 new deprecations with links to a <a href="https://github.com/ember-data/ember-data-filter#recommended-refactor-guide">guide on how to refactor</a>.
These deprecations will target <code>3.5</code>, meaning that the <code>ember-data-filter</code> addon will continue to
work and be supported through the release of ember-data <code>3.4</code>.</p>
<p><strong>Deprecation: ember-data-filter:filter</strong></p>
<p>Deprecate the primary case (<code>store.filter('posts', filterFn)</code>).
Instead, users can combine <code>store.peekAll</code> with a computed property.</p>
<p><strong>Deprecation: ember-data-filter:query-for-filter</strong></p>
<p>This deprecation is specific to folks providing a <code>query</code> to be requested the
first time a filter is run. To do this better, users can separate their usage
of <code>filter</code> from their usage of <code>query</code>.</p>
<p><strong>Deprecation: ember-data-filter:empty-filter</strong></p>
<p>In the case that users were creating a <code>filter</code> with no method for filtering by,
a deprecation is printed letting them know that the easiest path forward is to
use <code>peekAll</code>, which would return the same record result set.</p>
<a class="header" href="print.html#how-we-teach-this-35" id="how-we-teach-this-35"><h2>How we teach this</h2></a>
<p>The <code>filter</code> API is rarely used, having been discouraged for many years. A simple post
alerting users to it's deprecation should be sufficient. The refactoring guide is
sufficiently simple that teaching folks a better way should not be much of a hurdle.</p>
<a class="header" href="print.html#drawbacks-53" id="drawbacks-53"><h2>Drawbacks</h2></a>
<p>Minor churn for folks that did use this API; however, the end result will improve the
performance of apps using filters more so than anyone else.</p>
<a class="header" href="print.html#alternatives-53" id="alternatives-53"><h2>Alternatives</h2></a>
<p>There's been some talk of an API for local querying; however, said alternative RFC
would only result in deprecating this API as well.</p>
<a class="header" href="print.html#unresolved-questions-35" id="unresolved-questions-35"><h2>Unresolved questions</h2></a>
<p>None</p>
<ul>
<li>Start Date: 2018-05-01</li>
<li>RFC PR: (leave this empty)</li>
<li>Ember Issue: (leave this empty)</li>
</ul>
<a class="header" href="print.html#deprecate-usage-of-ember-evented-in-ember-data" id="deprecate-usage-of-ember-evented-in-ember-data"><h1>Deprecate Usage of Ember Evented in Ember Data</h1></a>
<a class="header" href="print.html#summary-55" id="summary-55"><h2>Summary</h2></a>
<p><code>Ember.Evented</code> functionality on <code>DS.Model</code>, <code>DS.ManyArray</code>,
<code>DS.Errors</code>, <code>DS.RecordArray</code>, and <code>DS.PromiseManyArray</code> will be
deprecated and eventually removed in a future release. This includes
the following methods from the
<a href="https://www.emberjs.com/api/ember/2.15/classes/Ember.Evented/methods/on?anchor=off">Ember.Evented</a>
class: <code>has</code>, <code>off</code>, <code>on</code>, <code>one</code>, and <code>trigger</code>. Additionally the
following lifecycle methods on <code>DS.Model</code> will also be deprecated:
<code>becameError</code>, <code>becameInvalid</code>, <code>didCreate</code>, <code>didDelete</code>, <code>didLoad</code>,
<code>didUpdate</code>, <code>ready</code>, <code>rolledBack</code>.</p>
<a class="header" href="print.html#motivation-56" id="motivation-56"><h2>Motivation</h2></a>
<p>The use of <code>Ember.Evented</code> is mostly a legacy from the pre 1.0 days of
Ember Data when events were a core part of the Ember Data programming
model. Today there are better ways to do everything that once needed
events. Removing the usage of the <code>Ember.Evented</code> mixin will make it
easier for Ember Data to eventually transition to using native ES2015
JavaScript classes and will reduce the surface area of APIs that Ember
Data must support in the long term.</p>
<a class="header" href="print.html#detailed-design-46" id="detailed-design-46"><h2>Detailed design</h2></a>
<p><code>Ember.Evented</code> mixin will be scheduled to be removed from the
following classes in a future Ember Data release: <code>DS.Model</code>,
<code>DS.ManyArray</code>, <code>DS.Errors</code>, <code>DS.RecordArray</code>, and
<code>DS.PromiseManyArray</code>.</p>
<p>The <code>has</code>, <code>off</code>, <code>on</code>, <code>one</code>, and <code>trigger</code> methods will be trigger a
deprecation warning when called and will be completly in a future
Ember Data release.</p>
<p>A special deprecation will be logged when users of a
<code>DS.adapterPopulatedRecordArray</code> attempt to listen to the <code>didLoad</code>
event. This depecations will prompt users to use a computed property
instead of the <code>didLoad</code> event.</p>
<p><code>DS.Model</code> will also recieve deprecation warnings when a model is
defined with the following methods: <code>becameError</code>, <code>becameInvalid</code>,
<code>didCreate</code>, <code>didDelete</code>, <code>didLoad</code>, <code>didUpdate</code>, <code>ready</code>,
<code>rolledBack</code>.</p>
<p>When a model is instantiated for the first time with any of these
methods a deprecation warning will be logged notifiying the user that
this method will be deprecated and the user should use an computed or
overide the model's init method instead.</p>
<a class="header" href="print.html#how-we-teach-this-36" id="how-we-teach-this-36"><h2>How we teach this</h2></a>
<p>Today we do not teach the use of any of the Ember Data lifecycle
events in the guides. They are referenced in the API docs but they
will be updated to mark the APIs as deprecated and show alternative
examples of how to achieve the same functionality using a non event
pattern.</p>
<p>The deprecation guide app will be updated with examples showing how to
migrate away from an evented pattern to using a computed or imperative
method to achieve the same results.</p>
<a class="header" href="print.html#drawbacks-54" id="drawbacks-54"><h2>Drawbacks</h2></a>
<p>The drawback to making this change is existing code that takes
advantage of the Ember Data lifecycle events will need to be updated
to use a different pattern.</p>
<a class="header" href="print.html#alternatives-54" id="alternatives-54"><h2>Alternatives</h2></a>
<p>We could leave the <code>Ember.Evented</code> mixin on all of the Ember Data
objects that currently support it and continue to support this
interface for the foreseeable future. However, Ember Data itself
doesn't require these events internally. There is only one place in
the <code>DS.Error</code> code that takes advantage of the <code>Ember.Evented</code> system
and that code can be easilly re-written to avoid <code>Ember.Evented</code> APIs.</p>
<a class="header" href="print.html#unresolved-questions-36" id="unresolved-questions-36"><h2>Unresolved questions</h2></a>
<p>None</p>
<ul>
<li>Start Date: 2018-05-08</li>
<li>RFC PR: https://github.com/emberjs/rfcs/pull/331</li>
<li>Ember Issue: (leave this empty)</li>
</ul>
<a class="header" href="print.html#summary-56" id="summary-56"><h1>Summary</h1></a>
<p>Deprecate all use of:</p>
<ul>
<li>Ember Globals Resolver (looks up a class via a global namespace such as &quot;App&quot;)</li>
<li>Creation of a Global Namespace (<code>var App = Ember.Namespace.create();</code>)</li>
<li>Ember.TEMPLATES array</li>
<li>&lt;script type=&quot;text/handlebars&quot; data-template-name=&quot;path/to/template&quot;&gt;</li>
</ul>
<p>Use of any of the above should trigger a deprecation warning, with a target
of version 4.0</p>
<a class="header" href="print.html#motivation-57" id="motivation-57"><h1>Motivation</h1></a>
<p>Over the past years we have transitioned to using Ember-CLI as the main way
to compile Ember apps. The globals resolver is a holdover and primarily
facilitates use of Ember without Ember-CLI.</p>
<a class="header" href="print.html#the-globals-resolver" id="the-globals-resolver"><h1>The Globals Resolver</h1></a>
<p>For those who are not aware, the globals resolver is available via <code>@ember/globals-resolver</code> or
<code>Ember.DefaultResolver</code>. For more information, see the
<a href="https://www.emberjs.com/api/ember/release/classes/GlobalsResolver/properties">api</a>.
Using it looks like the following:</p>
<pre><code class="language-js">// app.js
var App = Ember.Application.create();

App.Router.map(function() {
  this.route('about');
});

App.AboutRoute = Ember.Route.extend({
  model: function() {
    return ['red', 'yellow', 'blue'];
  }
});
</code></pre>
<pre><code class="language-html">// index.html
&lt;script type=&quot;text/x-handlebars&quot; data-template-name=&quot;about&quot;&gt;
  &lt;ul&gt;
    {{#each model as |item|}}
      &lt;li&gt;{{item}}&lt;/li&gt;
    {{/each}}
  &lt;/ul&gt;
&lt;/script&gt;
</code></pre>
<a class="header" href="print.html#implementation-details-1" id="implementation-details-1"><h1>Implementation Details</h1></a>
<p>One small detail required to implement this RFC: ember-cli's own default resolver,
<a href="https://github.com/ember-cli/ember-resolver">ember-resolver</a>
currently still extends from the globals resolver.
In order to implement this RFC, the ember-cli resolver will need to be changed
so that it does <em>not</em> extend from the globals resolver, or otherwise ember-cli users
will get a deprecation warning as well.
However, changing the base class of the ember cli classic resolver is a breaking change,
so prior to ember/ember-cli version 4.0 we need to take another step.
In the ember-cli classic resolver, deprecate any runtime calls where there is fallback to the globals mode resolver. This would be a deprecation in ember-cli's resolver. We could bump a major version of ember-cli-resolver removing the base class and release it in ember-cli after an LTS of ember-cli.</p>
<a class="header" href="print.html#transition-path-10" id="transition-path-10"><h1>Transition Path</h1></a>
<p>Primarily, the transition path is to recommend using Ember-CLI.</p>
<p>During the 3.x timeframe, it MAY become increasingly difficult to use this old functionality.
For example, with the release of 3.0, we already stopped publishing builds that support
globals mode. Here are some of the changes that have impacted or may soon impact users of globals mode:</p>
<a class="header" href="print.html#impact-of-es6-modules" id="impact-of-es6-modules"><h2>Impact of ES6 modules</h2></a>
<p>Users of ES6 modules must use their own build tooling to convert them to named AMD modules via Babel.
No support is provided for &lt;script type=&quot;module&quot;&gt; at this time, although that may change.</p>
<a class="header" href="print.html#impact-of-new-module-imports" id="impact-of-new-module-imports"><h2>Impact of New Module Imports</h2></a>
<p>Globals based apps are only able to use new module imports via the polyfill available at
https://github.com/ember-cli/babel-plugin-ember-modules-api-polyfill No build support for this is provided.</p>
<a class="header" href="print.html#impact-of-not-publishing-globals-builds" id="impact-of-not-publishing-globals-builds"><h2>Impact of not publishing globals builds</h2></a>
<p>It is necessary to get a globals build of Ember.js from the npm package now that globals builds
are no longer published to S3, builds.emberjs.com, and CDNs.</p>
<a class="header" href="print.html#impact-of-not-generating-a-globals-build-in-emberjs-package" id="impact-of-not-generating-a-globals-build-in-emberjs-package"><h2>Impact of not Generating a Globals Build in Ember.js Package</h2></a>
<p>At some point during the 3.x cycle, it may be that we no longer publish a globals build in the
npm package. At that point, it may become necessary to use Ember-CLI to generate a globals build
of Ember.js</p>
<a class="header" href="print.html#impact-of-package-splitting" id="impact-of-package-splitting"><h2>Impact of Package Splitting</h2></a>
<p>Work has started on package splitting. It is likely that the globals resolver may not be included
in a default partial build of Ember.js and may be moved to its own package for easy removal.</p>
<a class="header" href="print.html#impact-of-tree-shaking" id="impact-of-tree-shaking"><h2>Impact of Tree Shaking</h2></a>
<p>If the globals resolver is moved to a separate package, it will likely not be included in a build
of Ember.js by default unless tree shaking is turned off.</p>
<a class="header" href="print.html#how-we-teach-this-37" id="how-we-teach-this-37"><h1>How We Teach This</h1></a>
<p>We already do teach this and don't teach the globals resolver. No changes required here.</p>
<a class="header" href="print.html#deprecation-guide-1" id="deprecation-guide-1"><h2>Deprecation Guide</h2></a>
<p>A draft deprecation guide has been pull requested at https://github.com/ember-learn/deprecation-app/pull/155</p>
<a class="header" href="print.html#drawbacks-55" id="drawbacks-55"><h1>Drawbacks</h1></a>
<p>A drawback is that people may want alternate build tooling to Ember-CLI.
We have mitigated this by openly publishing the ember-cli resolver and all parts of the
ember-cli ecosystem under the MIT license.
Alternate build tooling may simply use this open source code to build a competing
infrastructure to ember-cli.</p>
<a class="header" href="print.html#alternatives-55" id="alternatives-55"><h1>Alternatives</h1></a>
<p>Without doing this, we will have to continue to ship and maintain this rarely used functionality.
We don't believe this is a reasonable alternative.</p>
<a class="header" href="print.html#unresolved-questions-37" id="unresolved-questions-37"><h1>Unresolved questions</h1></a>
<p>There has never been a transition guide for transitioning an old codebase to Ember-CLI.
Do we want to create one at this late date?</p>
<ul>
<li>Start Date: 2018-10-24</li>
<li>RFC PR: https://github.com/emberjs/rfcs/pull/332</li>
<li>Ember Issue:</li>
</ul>
<a class="header" href="print.html#ember-data-record-links--meta" id="ember-data-record-links--meta"><h1>Ember Data Record Links &amp; Meta</h1></a>
<a class="header" href="print.html#summary-57" id="summary-57"><h2>Summary</h2></a>
<p>Enable users to associate <code>links</code> and <code>meta</code> information with individual records
in a manner accessible via the template.</p>
<a class="header" href="print.html#motivation-58" id="motivation-58"><h2>Motivation</h2></a>
<p>Sometimes users have meta or links information to associate with a specific record.
Users of the <code>json-api</code> specification will commonly understand this information as
belonging to an individual <code>resource</code>.</p>
<p>While <code>ember-data</code> allows for this information to exist on relationships, it does
not allow for it to exist on records, which has to this point been a glaring omission
for users of <code>json-api</code> and similar specifications.</p>
<a class="header" href="print.html#detailed-design-47" id="detailed-design-47"><h2>Detailed design</h2></a>
<p>In keeping with the current design of the <code>store.push</code> API which expects the <code>json-api</code> format,
users would include optional <code>meta</code> and <code>links</code> information as member properties of a resource.</p>
<pre><code class="language-js">store.push({
  data: {
    type: 'contributor',
    id: '1',
    attributes: {},
    relationships: {},
    meta: {
      // ... &lt;any&gt;
    },
    links: {
      self: './person/1', // ... &lt;String&gt;
    }
  }
});
</code></pre>
<hr />
<p><code>links</code> and <code>meta</code> will be accepted anywhere a <code>resource</code> may be encountered in a payload.</p>
<pre><code class="language-js">store.push({
  data: [
    {
      type: 'contributor',
      id: '1',
      attributes: {},
      relationships: {
        projects: {
          data: [
            { type: 'project', id: '1' }
          ]
        }
      },
      meta: {
        // ... &lt;any&gt;
      },
      links: {
        self: './person/1', // ... &lt;String&gt;
      }
    }
  ],
  included: [
    {
      type: 'project',
      id: '1',
      attributes: {},
      relationships: {
        contributors: {
          data: [
            { type: 'contributor', id: '1' }
          ]
        }
      },
      meta: {
        // ... &lt;any&gt;
      },
      links: {
        self: './github-projects/1', // ... &lt;String&gt;
      }
    }
  ]
})
</code></pre>
<hr />
<p>Links &amp; Meta on objects used as <code>ResourceIdentifiers</code> (e.g. to link to another resource within a relationship)
will not be used for the associated resource and will be silently ignored.</p>
<pre><code class="language-js">let record = store.push({
  data: {
    type: 'contributor',
    id: '1',
    attributes: {},
    relationships: {
      projects: {
        data: [
          {
            type: 'project',
            id: '1',         
            meta: {}, // ignored
            links: {} // ignored
          }
        ]
      }
    },
  }
});
</code></pre>
<hr />
<p>Links &amp; Meta on objects provided for <code>Relationships</code> will continue to work (as they do today).</p>
<pre><code class="language-js">let record = store.push({
  data: {
    type: 'contributor',
    id: '1',
    attributes: {},
    relationships: {
      projects: {
        data: [
          {
            type: 'project',
            id: '1',         
          }
        ],
        meta: {}, // available on the Record's hasMany relationship
        links: {} // available on the Record's hasMany relationship
      }
    },
  }
});
</code></pre>
<hr />
<p><code>links</code> and <code>meta</code> properties will be exposed as getters on instances of <code>DS.Model</code> and will default to <code>null</code> if
no <code>meta</code> or <code>links</code> have been provided.</p>
<pre><code class="language-js">let record = store.push({
  data: {
    type: 'person',
    id: '1',
    attributes: { name: '@runspired' },
    meta: {
      expiresDate: '2018-05-10'
    },
    links: {
      self: './people/runspired'
    }
  }
});

record.meta.expiresDate; // '2018-05-10'
record.links.self; // './people/runspired'
</code></pre>
<hr />
<p><code>links</code> and <code>meta</code> will similarly be exposed as on instances of <code>Snapshot</code> given to
adapter and serializer methods. In keeping with <code>Snapshot#attributes()</code>, they will
be exposed as methods.  Should users desire to reload a record via link, they could
achieve such by utilizing the <code>links()</code> method to check for a link when making a request.</p>
<pre><code class="language-js">class Snapshot {
  links() {}
  meta() {}
}
</code></pre>
<hr />
<a class="header" href="print.html#the-shared-namespace-problem-and-interop-with-existing-workaround-for-links-and-meta" id="the-shared-namespace-problem-and-interop-with-existing-workaround-for-links-and-meta"><h4>The shared namespace problem and interop with existing workaround for <code>links</code> and <code>meta</code>.</h4></a>
<p>The <code>json-api</code> spec places <code>type</code>, <code>id</code>, and all members of <code>attributes</code> and <code>relationships</code> into
a single shared flattened namespace.  This flattened namespace is what <code>records</code> expose.</p>
<p>The spec does not put <code>links</code> and <code>meta</code> into this namespace, and it is valid to have <code>links</code> and <code>meta</code>
as member names of either <code>attributes</code> or <code>relationships</code>.</p>
<p>Some apps have taken advantage of this to move <code>links</code> and <code>meta</code> into <code>attributes</code> on their serializer
and to expose them via <code>DS.attr</code> on their records.</p>
<p>The <code>getter</code> we are proposing adding to <code>DS.Model</code> would be overwriteable. In the case that there is a
conflict, the version defined by the end user model would win. It would be up to consuming apps to
decide whether they wish to avoid this conflict by renaming the non-resource <code>links</code> and <code>meta</code> either
in their serializer or in their API responses.</p>
<a class="header" href="print.html#how-we-teach-this-38" id="how-we-teach-this-38"><h2>How we teach this</h2></a>
<p>Documentation for <code>DS.Model</code> should be updated to reflect these properties, the potential conflict
(and the default conflict resolution) explained in said documentation, and guides on working with
Models should reflect this capability.</p>
<a class="header" href="print.html#drawbacks-56" id="drawbacks-56"><h2>Drawbacks</h2></a>
<p>Users may sometimes encounter confusion when <code>links</code> or <code>meta</code> is a member of attributes or
relationships.</p>
<a class="header" href="print.html#alternatives-56" id="alternatives-56"><h2>Alternatives</h2></a>
<ul>
<li>
<p>Rename <code>links</code> and <code>meta</code> to a name less likely to collide and which we fully reserve, such as
<code>recordLinks</code> and <code>recordMeta</code>. We felt this would be confusing.</p>
</li>
<li>
<p>Enforce accessing <code>links</code> and <code>meta</code> via some other object such as the <code>Reference</code> API. In addition
to being cumbersome and confusing, this would lack discoverability and be unergonomic in templates.</p>
</li>
<li>
<p>Enforce accessing <code>links</code> and <code>meta</code> via some imported helper, e.g. <code>recordMetaFor(record)</code> or <code>recordLinksFor(record)</code>.
We felt this would be confusing and unergonomic for templates.</p>
</li>
</ul>
<a class="header" href="print.html#unresolved-questions-38" id="unresolved-questions-38"><h2>Unresolved questions</h2></a>
<p>None</p>
<ul>
<li>Start Date: 2018-05-29</li>
<li>RFC PR: https://github.com/emberjs/rfcs/pull/335</li>
<li>Ember Issue: (leave this empty)</li>
</ul>
<a class="header" href="print.html#deprecate-sendaction" id="deprecate-sendaction"><h1>Deprecate <code>.sendAction</code></h1></a>
<a class="header" href="print.html#summary-58" id="summary-58"><h2>Summary</h2></a>
<p>In old versions of Ember (&lt; 1.13) <code>component#sendAction</code> was the only way for a component to call an
action on a parent scope. In 1.13 with the so called <em>closure actions</em> a more intuitive and flexible
way of calling actions was introduced, yielding the old way redundant.</p>
<a class="header" href="print.html#motivation-59" id="motivation-59"><h2>Motivation</h2></a>
<p>With the new <em>closure actions</em> being the recommended way, <code>component#sendAction</code> is not even
mentioned in the guides.
With the goal of simplifying the framework I think we should remove what is not considered the
current best practice.
<em>Closure actions</em> have been available since 1.13. That is 3 years ago, so deprecating <code>sendAction</code>
should not cause too much pain and yet addons can support still support the last version of the 1.X
cycle if they really want to.</p>
<p>It is out of the scope of this RFC to enumerate the reasons why <em>closure actions</em> are preferred over
<em>sendAction</em> but you can find an in depth explanation of <em>closure actions</em> in <a href="http://miguelcamba.com/blog/2016/01/24/ember-closure-actions-in-depth">this blog post from 2016</a>.</p>
<a class="header" href="print.html#detailed-design-48" id="detailed-design-48"><h2>Detailed design</h2></a>
<p>A deprecation message will appear when <code>sendAction</code> is invoked. The feature will be removed in
Ember 4.0. The deprecation message will use the arguments passed to <code>sendAction</code> to generate a dynamic
explanation that will make super-easy for developers to migrate to closure actions.</p>
<p>As it is mandatory with new deprecations, a new entry in the deprecation guides will be added
explaining the migration path in depth.</p>
<p>To refresh what the migration path would look like in the typical use case.</p>
<p><strong>BEFORE</strong></p>
<pre><code class="language-js">// parent-component.js
export default Component.extend({
  actions: {
    sayHi() {
      alert('Hello user!');
    }
  }
})
</code></pre>
<pre><code class="language-hbs">{{!-- parent-component.hbs --}}
{{child-component salute=&quot;sayHi&quot;}}
</code></pre>
<pre><code class="language-js">// child-component.js
export default Component.extend({
  actions: {
    sendSalute() {
      this.sendAction('salute');
    }
  }
});
</code></pre>
<pre><code class="language-hbs">{{!-- child-component.hbs --}}
&lt;button {{action &quot;sendSalute&quot;}}&gt;Send salute&lt;/button&gt;
</code></pre>
<p><strong>AFTER</strong></p>
<pre><code class="language-js">// parent-component.js
export default Component.extend({
  actions: {
    sayHi() {
      alert('Hello user!');
    }
  }
})
</code></pre>
<pre><code class="language-hbs">{{!-- parent-component.hbs --}}
{{child-component salute=(action &quot;sayHi&quot;)}}
</code></pre>
<pre><code class="language-js">// child-component.js
export default Component.extend({
  actions: {
    sendSalute() {
      this.salute();
      // if the salute action is optional you'll have to guard in case it's undefined:
      // if (this.salute) {
      //   this.salute()
      // }
      // 
      // Alternatively, you can also define a noop salute function:
      // salute() {}
      //
      // This allows you to remove the guard while provinding an obvious place to add
      // docs for that action.
    }
  }
});
</code></pre>
<pre><code class="language-hbs">{{!-- child-component.hbs --}}
&lt;button {{action &quot;sendSalute&quot;}}&gt;Send salute&lt;/button&gt;
</code></pre>
<p>However <em>closure actions</em> allow to be less verbose, so the same behavior could be attained using
less intermediate calls</p>
<pre><code class="language-js">// parent-component.js
export default Component.extend({
  actions: {
    sayHi() {
      alert('Hello user!');
    }
  }
})
</code></pre>
<pre><code class="language-hbs">{{!-- parent-component.hbs --}}
{{child-component salute=(action &quot;sayHi&quot;)}}
</code></pre>
<pre><code class="language-hbs">{{!-- child-component.hbs --}}
&lt;button onclick={{@salute}}&gt;Send salute&lt;/button&gt;
</code></pre>
<a class="header" href="print.html#how-we-teach-this-39" id="how-we-teach-this-39"><h2>How we teach this</h2></a>
<p>There are no new concepts to teach, but the removal of an old concept now considered outdated.</p>
<a class="header" href="print.html#drawbacks-57" id="drawbacks-57"><h2>Drawbacks</h2></a>
<p>There might be some churn following the deprecation, specially comming from addons that haven't been
updated in a while.
Addons that want to support the latest versions of Ember without deprecation messages and still work
past Ember 1.13 will have to do some gymnastics to do so.</p>
<a class="header" href="print.html#alternatives-57" id="alternatives-57"><h2>Alternatives</h2></a>
<p>Wait longer to deprecate it and keep <code>sendAction</code> undocumented until it's usage is yet more minoritary
than it is today, to lower the churn.</p>
<ul>
<li>Start Date: 2018-06-14</li>
<li>RFC PR: (leave this empty)</li>
<li>Ember Issue: (leave this empty)</li>
</ul>
<a class="header" href="print.html#native-class-constructor-update" id="native-class-constructor-update"><h1>Native Class Constructor Update</h1></a>
<a class="header" href="print.html#summary-59" id="summary-59"><h2>Summary</h2></a>
<p>Update the behavior of EmberObject's constructor to defer object
initialization.</p>
<a class="header" href="print.html#motivation-60" id="motivation-60"><h2>Motivation</h2></a>
<p>Using native class syntax with EmberObject has almost reached full feature
parity, meaning soon we'll be able to ship native classes and begin recommending
them. This will do wonders for the Ember learning story, and will bring us in
line with the wider Javascript community.</p>
<p>However, early adopters of native classes have experienced some serious
ergonomic issues due to the current behavior of the class constructor. The issue
is caused by the fact that properties passed to <code>EmberObject.create</code> are
assigned to the instance in the root class <code>constructor</code>. Due to the way that
native class fields work, this means that they are assigned <em>before</em> any
subclasses' fields are assigned, causing subclass fields to overwrite any value
passed to <code>create</code>:</p>
<pre><code class="language-js">class Foo extends EmberObject {
  bar = 'baz';
}

let foo = Foo.create({ bar: 'something different' });

console.log(foo.bar); // 'baz'
</code></pre>
<p>This has made adoption very difficult, and is a consistent stumbling block for
new users of native class syntax in Ember. Worse yet, it makes writing a codemod
for converting to native class syntax very difficult because we don't have a
clear target.</p>
<p>For instance, given the above class, how would we convert the class field? Let's
go through the various options:</p>
<pre><code class="language-js">class Foo extends EmberObject {
  // Does not work, for the reasons described above
  bar = 'baz';

  // Does not cover all cases. If we did `Foo.create({ bar: false })` it would
  // still assign the default.
  bar = this.bar || 'baz';

  // This works, but is very verbose and not ideal
  bar = this.hasOwnProperty('bar') ? this.bar : 'baz';

  // This is one of the community accepted solutions, but it requires lodash
  bar = _.defaultTo(this.bar, 'baz');

  // This is another community accepted solution, but it requires
  // @ember-decorators/argument, which is a separate library
  @argument foo = 'bar';
}
</code></pre>
<p>None of these is ideal. Instead, we can change the behavior of the constructor
and the <code>create</code> method to circumvent this issue.</p>
<p>This change <em>would</em> be a breaking change to the behavior of native classes
today, and a change from the previous class RFC. This will impact early adopters
and should be made with that in mind. It would <em>not</em> be a change that breaks the
behavior of the community solutions to class fields mentioned above, and all
other changes would be relatively easy to create a safe codemod for (essentially
converting <code>constructor</code> -&gt; <code>init</code> in affected classes), so the impact <em>should</em>
be minimal.</p>
<p>Because native classes never officially shipped as part of Ember's public API
(an announcement was not made, docs have not been written, etc), this RFC
proposes that the change would <em>not</em> be considered a breaking change <em>for the
purposes of semver</em>. This would allow us to ship the change during the Ember v3
release cycle, and prevent more code from being built on top of the previous
behavior.</p>
<a class="header" href="print.html#detailed-design-49" id="detailed-design-49"><h2>Detailed design</h2></a>
<p>One very important design constraint to making this change is that we <em>cannot</em>
break the behavior of EmberObject when used <em>without</em> native classes. To do
this, we will leverage the fact that the static <code>create</code> method is the only
public way to create an instance of EmberObject.</p>
<p>Currently, the behavior of EmberObject is the following (simplified):</p>
<pre><code class="language-js">class EmberObject {
  constructor(props) {
    // ..class setup things

    Object.assign(this, props);
    this.init();
  }

  static create(props) {
    let instance = new this(props);

    return instance;
  }
}
</code></pre>
<p>We can change it to the following (simplified):</p>
<pre><code class="language-js">class EmberObject {
  constructor(props) {
    // ..class setup things
  }

  static create(props) {
    let instance = new this(props);

    Object.assign(instance, props);
    instance.init();

    return instance;
  }
}
</code></pre>
<p>This would assign the properties <em>after</em> all of the class fields for any
subclasses have been assigned. Revisiting our previous example, the following
two class declarations would effectively be equivalent:</p>
<pre><code class="language-js">const Foo = EmberObject.extend({
  bar: 'baz'
});

class Foo extends EmberObject {
  bar = 'baz';
}
</code></pre>
<p>Much easier to codemod! There are other subtle differences between native class
fields and EmberObject properties, such as the fact that class fields are
assigned each time a class is initialized, but these are easier to work around.</p>
<a class="header" href="print.html#injections-and-the-init-hook" id="injections-and-the-init-hook"><h3>Injections and the <code>init</code> hook</h3></a>
<p>One side effect of this change is that injections will not be available on the
class instance during the <code>constructor</code> phase. This behavior is not very
commonly used - based on an informal community survey we found only a few usages
- but it <em>does</em> exist and have its use cases.</p>
<p>Figuring out the ideal behavior of injections during the constructor phase is
outside of the scope of this RFC, and is something that should be discussed in
future RFCs. For the time being, users can still rely on the <code>init</code> hook, which
will continue to be called after all injections and properties have been
assigned to the instance.</p>
<a class="header" href="print.html#new-emberobject" id="new-emberobject"><h3><code>new EmberObject()</code></h3></a>
<p>It was previously possible to use <code>new</code> syntax with EmberObject. While this
was not considered public API, it has technically worked and been under test
since the early days of Ember, and may fall under the category of intimate API.
Ideally, we would deprecate this usage as a private/intimate API, which would
mean supporting it through the next LTS version, and dropping support after
(currently, this would mean dropping it at <code>v3.5.0</code>).</p>
<p>We can continue to support this behavior in a backwards compatible way while
deprecating it with one final tweak to the change above:</p>
<pre><code class="language-js">const DEFER_INIT = new Symbol();

function initialize(instance, props) {
  Object.assign(instance, props);
  instance.init();
}

class EmberObject {
  constructor(props, maybeDefer) {
    // ..class setup things

    if (maybeDefer === DEFER_INIT) {
       return this;
    }

    deprecate('using `new` with EmberObject has been deprecated. Please use `create` instead.', false, {
      id: 'object.new-constructor',
      until: '3.5.0'
    });

    initialize(this, props);
  }

  static create(props) {
    let instance = new this(props, DEFER_INIT);
    initialize(instance, props);

    return instance;
  }
}
</code></pre>
<a class="header" href="print.html#how-we-teach-this-40" id="how-we-teach-this-40"><h2>How we teach this</h2></a>
<p>If this PR is accepted, most of the major issues with classes will have been
resolved. We can begin working on a codemod to make converting easier, and move
toward officially making native classes a finalized part of the public API of
Ember. Pending decorators and class fields moving to a late enough stage in the
TC39 process, we can also begin converting the guides to use native class
syntax.</p>
<p>We can document the exact behavior of the new constructor in the API docs for
EmberObject. Most details won't have to change since this change only affects
native class syntax, which has not been documented much officially. We can also
demonstrate the behaviors of classes throughout the guides and API docs.</p>
<p>One thing we should make clear is that EmberObject will likely be deprecated
in the near future, and that ideally for non-Ember classes (things that aren't
Components, Services, etc.) users should drop EmberObject altogether and use
native classes only.</p>
<a class="header" href="print.html#drawbacks-58" id="drawbacks-58"><h2>Drawbacks</h2></a>
<p>This would be a breaking change that could negatively affect early adopters.</p>
<a class="header" href="print.html#alternatives-58" id="alternatives-58"><h2>Alternatives</h2></a>
<ul>
<li>
<p>We could leave the behavior as is, and choose a method for defaulting to
standardize on.</p>
</li>
<li>
<p>We could make this change behind a feature flag and require users to opt-in
to the new behavior, like optional features that currently exist. This would
have to be a build time feature flag, since the area is very performance
sensitive. Given native classes are not yet public API, if we were to do this we
should probably still default to enabling the new behavior and recommending it
as the preferred path.</p>
</li>
<li>
<p>We could not deprecate <code>new EmberObject</code> altogether, and instead only
deprecate passing properties to the constructor. While this would work as a
temporary solution, it may also encourage users to continue using EmberObject
instead of switching to native classes, which is ultimately the long term goal.</p>
</li>
</ul>
<a class="header" href="print.html#unresolved-questions-39" id="unresolved-questions-39"><h2>Unresolved questions</h2></a>
<p>How do we handle DI during the construction phase?</p>
<ul>
<li>Start Date: 2018-06-19</li>
<li>RFC PR: https://github.com/emberjs/rfcs/pull/340</li>
<li>Ember Issue: (leave this empty)</li>
</ul>
<a class="header" href="print.html#deprecate-embermerge-in-favor-of-emberassign" id="deprecate-embermerge-in-favor-of-emberassign"><h1>Deprecate Ember.merge in favor of Ember.assign</h1></a>
<a class="header" href="print.html#summary-60" id="summary-60"><h2>Summary</h2></a>
<p>The goal of this RFC is to remove <code>Ember.merge</code> in favor of using <code>Ember.assign</code>.</p>
<a class="header" href="print.html#motivation-61" id="motivation-61"><h2>Motivation</h2></a>
<p><code>Ember.assign</code> has been around quite awhile, and has the same functionality as <code>Ember.merge</code>.
With that in mind, we should remove the old <code>Ember.merge</code>, in favor of just having a single function.</p>
<a class="header" href="print.html#detailed-design-50" id="detailed-design-50"><h2>Detailed design</h2></a>
<p>Ember will start logging deprecation messages that tell you to use <code>Ember.assign</code> instead of <code>Ember.merge</code>.</p>
<p>The exact deprecation message will be decided later, but something along the lines of:</p>
<pre><code>Using `Ember.merge` is deprecated. Please use `Ember.assign` instead. If you are using a version of
Ember &lt;= 2.4 you can use [ember-assign-polyfill](https://github.com/shipshapecode/ember-assign-polyfill) to make `Ember.assign`
available to you.
</code></pre>
<a class="header" href="print.html#how-we-teach-this-41" id="how-we-teach-this-41"><h2>How we teach this</h2></a>
<p>This should be a simple 1 to 1 conversion, and the deprecation message should be clear enough for all to
understand what they need to do, and convert all usages of <code>Ember.merge</code> to <code>Ember.assign</code>.</p>
<a class="header" href="print.html#deprecation-guide-2" id="deprecation-guide-2"><h3>Deprecation Guide</h3></a>
<p>An entry to the <a href="https://emberjs.com/deprecations/">Deprecation Guides</a> will be added outlining the conversion from
<code>Ember.merge</code> to <code>Ember.assign</code>.</p>
<p><code>Ember.merge</code> predates <code>Ember.assign</code>, but since <code>Ember.assign</code> has been released, <code>Ember.merge</code> has been mostly unnecessary.
To cut down on duplication, we are now recommending using <code>Ember.assign</code> instead of <code>Ember.merge</code>. If you are using a version of
Ember &lt;= 2.4 you can use <a href="https://github.com/shipshapecode/ember-assign-polyfill">ember-assign-polyfill</a> to make <code>Ember.assign</code>
available to you.</p>
<p>Before:</p>
<pre><code class="language-js">import { merge } from '@ember/polyfills';

var a = { first: 'Yehuda' };
var b = { last: 'Katz' };
merge(a, b); // a == { first: 'Yehuda', last: 'Katz' }, b == { last: 'Katz' }

</code></pre>
<p>After:</p>
<pre><code class="language-js">import { assign } from '@ember/polyfills';

var a = { first: 'Yehuda' };
var b = { last: 'Katz' };
assign(a, b); // a == { first: 'Yehuda', last: 'Katz' }, b == { last: 'Katz' }
</code></pre>
<a class="header" href="print.html#codemod" id="codemod"><h3>Codemod</h3></a>
<p>A codemod will be provided to allow automatic conversion of <code>Ember.merge</code> to <code>Ember.assign</code>.</p>
<a class="header" href="print.html#drawbacks-59" id="drawbacks-59"><h2>Drawbacks</h2></a>
<p>The only drawback, that I can think of, is people would need to convert <code>Ember.merge</code> to
<code>Ember.assign</code>, but this would be a very easy change and could easily be done via codemod.</p>
<a class="header" href="print.html#alternatives-59" id="alternatives-59"><h2>Alternatives</h2></a>
<p>The impact of not doing this, is we continue to have two functions that do basically the same thing,
which we need to maintain.</p>
<p>Another alternative, could be to remove both <code>Ember.merge</code> and <code>Ember.assign</code>, in favor of <code>Object.assign</code>
or something similar.</p>
<a class="header" href="print.html#unresolved-questions-40" id="unresolved-questions-40"><h2>Unresolved questions</h2></a>
<p>None, that I can think of.</p>
<ul>
<li>Start Date: 07/11/2018</li>
<li>RFC PR: https://github.com/emberjs/rfcs/pull/345</li>
<li>Ember Issue: (leave this empty)</li>
</ul>
<a class="header" href="print.html#rfc-to-move-the-ember-community-chat-to-discord" id="rfc-to-move-the-ember-community-chat-to-discord"><h1>RFC to move the Ember community chat to Discord</h1></a>
<a class="header" href="print.html#summary-61" id="summary-61"><h2>Summary</h2></a>
<p>Encourage the Ember community to adopt Discord for real-time chat (vs Slack or other options).</p>
<a class="header" href="print.html#motivation-62" id="motivation-62"><h2>Motivation</h2></a>
<p>Real-time chat is essential to the function of online communities, particularly in open source. Chat fosters an informal, interactive style of communication that is important for building relationships, sharing community norms, coordinating on projects, and brainstorming ideas.</p>
<p>The Ember community predominantly uses <a href="https://ember-community-slackin.herokuapp.com/">a Slack instance</a> as the gathering place of choice. While we have benefited enormously from Slack, there are significant downsides as well.</p>
<a class="header" href="print.html#loss-of-history" id="loss-of-history"><h3>Loss of History</h3></a>
<p>Because we use Slack's free plan, the entire instance is limited to 10,000 messages in history at any time. Because of this hard cap, the amount of time messages persist continues to shrink as the community grows.</p>
<p>It's hard to quantify exactly how painful this limitation is, as it means that new community members can't search for the answer to a question that was likely answered in the past. We can never go back to reference how or when a decision was made, which can mean decision-making feels less transparent that it should be.</p>
<p>This limit applies not just to chat messages, but direct messages between community members as well. This leads to annoyance, as people have to ask for the same information over again if they forgot to save it, or data loss, as useful things like code snippets vanish into the ether.</p>
<a class="header" href="print.html#performance" id="performance"><h3>Performance</h3></a>
<p>The architecture of the Slack native application relies on running a separate web application per Slack instance the user is signed into. For users who need to be in multiple Slack instances, this can add up to a significant tax on computer resources, particularly as the application starts up.</p>
<p>Once Slack is up and running, most people generally find the performance reasonable, but a solution that offers better startup and runtime performance would be ideal.</p>
<a class="header" href="print.html#privacy-concerns" id="privacy-concerns"><h3>Privacy Concerns</h3></a>
<p>Slack is very clear that their target audience is companies, who often have strict compliance rules that they must follow. Unfortunately, those needs are often at odds with concerns about privacy in an open source community.</p>
<p>In particular, Slack recently added a feature called Corporate Export that theoretically allows administrators to export all messages, including private messages, without notifying users.</p>
<p>Now, the odds of this feature being abused are extremely low. It is only available on Slack's Plus plan, which means a malicious actor would need to be granted administrator priveleges, pony up at least $150,000 to upgrade our Slack plan for that month, apply for the the Corporate Export feature, have it granted by Slack, and then perform an export without anyone noticing.</p>
<p>Because the difficulty of exploiting this feature for evil is so remote, it's not a primary concern driving this change. But all things being equal, we prefer a solution that doesn't offer export of private messages at all, so it's never a concern at the back of someone's mind.</p>
<a class="header" href="print.html#better-communication--transparency" id="better-communication--transparency"><h3>Better Communication &amp; Transparency</h3></a>
<p>Out of frustration with Slack's disappearing messages, the Ember.js core team set up a Discord server to evaluate if it might be a better fit for open source communities.</p>
<p>While this was a public Discord server that anyone could sign up for, its existence was not widely publicized because we were unsure if Discord was the right solution.</p>
<p>Over time, the core team and many contributors gravitated towards the Discord, finding that it served our needs better. Because of how valuable the Slack instance is, no one wanted to propose a move to Discord until a plan (like, say, this RFC) could be put in place.</p>
<p>Unfortunately, this state of affairs has had several undesirable outcomes.</p>
<p>First, it has caused many of the most prolific contributors to be less active in Slack. This may give the appearance of stagnation or disinterest, when momentum on Ember has never been higher. It robs lurkers of the ability to become contributors if a good opportunity to help pops up. And it prevents some of the most experienced members of the community from being around to help answer questions they might have an off-hand answer to.</p>
<p>Second, and perhaps worst of all, it undermines the transparency and open governance that we have worked hard to create. Our bar is higher than just making it possible to contributewe go out of our way to actively welcome and encourage everyone to participate, learn and contribute.</p>
<p>Finally, this is not intended to replace <a href="https://discuss.emberjs.com/">the forum</a>, and that should be made clear. The forum is still the preferred place for asyncronous, threaded conversations where in-depth discussion is desired.</p>
<a class="header" href="print.html#detailed-design-51" id="detailed-design-51"><h2>Detailed design</h2></a>
<a class="header" href="print.html#transition-plan-8" id="transition-plan-8"><h3>Transition Plan</h3></a>
<p>We will need these things to transition the community smoothly:</p>
<ul>
<li>a period of time when we use both chat platforms during the transition, put the equivalent Discord channel information in the Slack channel topic</li>
<li>a clear guide (with illustrations)</li>
<li>once all of the setup is complete, the Discord server invites can be distributed.</li>
</ul>
<p>Note: the current Discord chat will be closed while this RFC is under consideration. If the RFC is accepted, then a detailed implementation plan (mostly role/channel/server setup) &amp; invitation strategy will be carried out.</p>
<a class="header" href="print.html#initial-setup" id="initial-setup"><h4>Initial Setup</h4></a>
<p>Because Discord has fine-grained controls, we will be able to implement categories for chats.</p>
<p>We intend to have the &quot;welcome&quot; channel as the initial channel for everyone who joins the Discord server. This channel will be read-only and will list the rules for the Discord server.</p>
<p>We also intend to have a &quot;setup&quot; channel. This channel will give you a complete guide of how to take advantage of the personalization, privacy and security, and notification controls in Discord.</p>
<p><strong>Verification Level</strong>
Initially, we will be implementing the &quot;low&quot; verification level, which means users will need to have a verified email on their Discord account. If this proves to be too easy of a target for spammers, we will implement a higher level of verification (levels include amount of time a user has to be a verified member of the server before they can post).</p>
<p><strong>Explicit Content Filter</strong>
Since this is a public Discord server, we will be setting an explicit content filter- it will scan messages from all members without a role. Email-verified members will be given a community member role to start, and other roles may be added to users over time.</p>
<p><strong>Categories and Channels</strong>
Community members will then have the option of visiting the &quot;setup&quot; channel and learning more about fine-grained controls, such as:</p>
<ul>
<li>notifications</li>
<li>muting a channel</li>
<li>muting a category</li>
</ul>
<p>Because our goal is transparency, all of the channels that exist will be visible in the channel list. A lock icon will display if the user does not have the role necessary to join that channel. (<em>FWIW, the alternative is to not display locked channels at all, which we felt would be less ideal- it is better to know that there are channels where private conversations are necessary and see what they are.</em>)</p>
<p>The following proposed initial category and channel list was chosen based on the current channel needs and evaluation of the channels with the most members on Slack. <em>Additional channels may be requested in the Admin/community-feedback channel.</em></p>
<p><strong>Category/Channel List:</strong></p>
<ul>
<li>(No Category)
<ul>
<li>welcome (community guidelines are posted here) &lt;--readonly &amp; the server invite puts users in this channel first.</li>
<li>setup-profile (how to setup your profile) &lt;--readonly</li>
</ul>
</li>
<li>Admin
<ul>
<li>community-feedback (questions, comments, concerns, requests)</li>
<li>security</li>
<li>steering-committee  (locked to role steering-committee)</li>
<li>news &amp; announcements</li>
<li>ember-jobs</li>
<li>bots</li>
</ul>
</li>
<li>Core Teams
<ul>
<li>ember-js  (locked to role core-js)</li>
<li>ember-data  (locked to role core-data)</li>
<li>ember-cli  (locked to role core-cli)</li>
<li>ember-learning  (locked to role core-learning)</li>
</ul>
</li>
<li>Working on Ember
<ul>
<li>ember-cli</li>
<li>ember-data</li>
<li>ember-engines</li>
<li>ember-js</li>
<li>glimmer-vm</li>
<li>triage</li>
<li>st-* (as needed)</li>
</ul>
</li>
<li>Using Ember
<ul>
<li>general-help</li>
<li>learning-ember</li>
<li>a11y</li>
<li>backend</li>
<li>internationalization</li>
<li>jsonapi</li>
<li>mobile</li>
<li>ember-js</li>
<li>ember-data</li>
<li>ember-cli</li>
<li>ember-engines</li>
<li>fastboot</li>
<li>ember-twiddle</li>
<li>e-*</li>
</ul>
</li>
<li>Supporting Ember
<ul>
<li>documentation</li>
<li>website</li>
<li>marketing-and-advocacy</li>
<li>infrastructure</li>
</ul>
</li>
<li>Event-Chat
<ul>
<li>EmberConf</li>
<li>EmberCamps</li>
<li>EmberFest</li>
<li>Talks</li>
<li>Other Conferences</li>
<li>Meetup organizers</li>
</ul>
</li>
<li>Social
<ul>
<li>Water-cooler (random)</li>
<li>Local-*</li>
<li>Media (livestreams, videos, podcasts)</li>
<li>Pets</li>
<li>Women in Ember </li>
</ul>
</li>
</ul>
<p><strong>Integrations</strong>
Discord's integration game is strong. Discord has a <a href="https://discordapp.com/developers/docs/intro">very detailed API</a> and many integrations already exist, and with no limitation (compared to free Slack instances, that have limited numbers of integrations).</p>
<a class="header" href="print.html#how-do-we-teach-this" id="how-do-we-teach-this"><h2>How do we teach this?</h2></a>
<p>In addition to having a setup channel available upon login (with illustrated instructions), here are some links where community members can read more:</p>
<ul>
<li><a href="https://discordapp.com/open-source">Discord Loves Open Source</a></li>
<li><a href="https://discordapp.com/guidelines">Discord Community Guidelines</a></li>
<li><a href="http://www.businessinsider.com/how-to-use-discord-the-messaging-app-for-gamers-2018-5">How to use Discord</a></li>
</ul>
<a class="header" href="print.html#drawbacks-60" id="drawbacks-60"><h2>Drawbacks</h2></a>
<a class="header" href="print.html#supporting-learning-vs-supporting-development" id="supporting-learning-vs-supporting-development"><h3>Supporting Learning vs Supporting Development</h3></a>
<p>There is some concern that there is already some confusion on Slack about where to get help learning/using Ember, and where to coordinate working on Ember. We need to have a clear delineation so that the folks who are spending their volunteer time to ship Ember features can continue to concentrate and do that.</p>
<a class="header" href="print.html#losing-community-members" id="losing-community-members"><h3>Losing Community Members</h3></a>
<p>There is some concern that we may lose some community members due to this move. This could happen for a variety of reasons- the nature of OSS work means that some are not always active on the chat community, or the user doesn't want a different chat app, etc. We believe that the former is probably more likely than the latter, since many of us are on at least 2-3 chat apps already.</p>
<a class="header" href="print.html#alternatives-60" id="alternatives-60"><h2>Alternatives</h2></a>
<p>The alternative to this would be to temporarily remain on Slack until we are able to evaluate and choose another viable option. However, we believe that staying on Slack is not desirable.</p>
<p>List of Slack alternatives:</p>
<ul>
<li>riot.io</li>
<li>mattermost.org</li>
<li>rocket.chat</li>
<li>spectrum.chat</li>
</ul>
<a class="header" href="print.html#unresolved-questions--faq" id="unresolved-questions--faq"><h2>Unresolved questions &amp; FAQ</h2></a>
<ul>
<li>When will there be conversation threads? We have been told that it is in the works, but there is no ETA.</li>
<li>Disqus, Discord, Discuss? Which is which? For clarity, we will encourage the use of the terms <strong>chat</strong> (Discord), <strong>the forums</strong> (Discuss), and <strong>blog comments</strong> (Disqus)- mostly so no one has to try to remember.</li>
</ul>
<ul>
<li>Start Date: 2018-08-31</li>
<li>RFC PR: https://github.com/emberjs/rfcs/pull/370</li>
<li>Ember Issue: (leave this empty)</li>
</ul>
<a class="header" href="print.html#summary-62" id="summary-62"><h1>Summary</h1></a>
<p>Deprecate <code>computed().volatile()</code> in favor of undecorated native getters and
setters.</p>
<a class="header" href="print.html#motivation-63" id="motivation-63"><h1>Motivation</h1></a>
<p><code>computed().volatile()</code> is a commonly misunderstood API. On its surface,
declaring a computed as volatile causes the computed to recalculate every time
it is called. This actually works much like native, undecorated accessors do on
classes, with one key difference.</p>
<p>Volatile properties are meant to respresent fundamentally unobservable values.
This means that they swallow notification changes, and will not notify under any
circumstances, and that when setting a volatile value the user must notify
manually:</p>
<pre><code class="language-js">const Foo = EmberObject.extend({
  bar: computed({
    get() {
      return this._value;
    }

    set(key, value) {
      return this._value = value;
    }
  }).volatile(),

  baz: computed('bar', {
    get() {
      return this.bar;
    }
  }),
});

let foo = Foo.create();

foo.set('bar', 123);
foo.baz; // 123, it's the initial get so nothing cached yet

foo.set('bar', 456);
foo.baz; // 123, no property changes were made so the cache was not cleared
</code></pre>
<p>This behavior is useful at times for framework code, but is generally not what
users are expecting. By constrast, when using native accessors with <code>set</code> and
<code>get</code>, Ember treats them just like any other property. From its perspective,
they <em>are</em> standard properties, so it'll continue to notify as expected.</p>
<pre><code class="language-js">class Foo {
  get bar() {
    return this._value;
  }

  set bar(value) {
    this._value = value;
  }

  @computed('bar')
  get baz() {
    return this.bar;
  }
});

let foo = new Foo();

set(foo, 'bar', 123);
foo.baz; // 123, it's the initial get so nothing cached yet

set(foo, 'bar', 456);
foo.baz; // 456, cache was cleared and value was updated
</code></pre>
<p>The most common use case for volatile computeds was when users wanted a computed
to behave like a native getter/setter. Now that we (almost) <em>have</em> those in a
easy to use form, it makes more sense to deprecate the volatile API and rely
directly on native functionality.</p>
<a class="header" href="print.html#transition-path-11" id="transition-path-11"><h1>Transition Path</h1></a>
<p>Native getters and setters will <em>only</em> work on native classes, due to how the
internals of the old object model work. To ensure that users do not accidentally
try to replace volatile with getters/setters on non-native classes, we should
provide 2 deprecation warnings:</p>
<ol>
<li>
<p>Deprecation when users use volatile on a computed which tells them that the
API has been deprecated, and that they'll need to update native class syntax
to remove the volatile property.</p>
</li>
<li>
<p>Deprecation when users use volatile on a computed decorator (to be RFC'd)
which tells them to remove the computed decorator entirely from the getter.</p>
</li>
</ol>
<p>Volatile properties will be removed once native classes are the default.</p>
<a class="header" href="print.html#how-we-teach-this-42" id="how-we-teach-this-42"><h1>How We Teach This</h1></a>
<p>In general documentation should be updated to use native getters and setters
wherever <code>volatile</code> was used. This will have to happen after docs are updated to
use native classes, because native getters and setters do <em>not</em> work with the
older object model.</p>
<a class="header" href="print.html#drawbacks-61" id="drawbacks-61"><h1>Drawbacks</h1></a>
<p>Volatility is useful for framework level concerns, for instance if developing an
API or decorator that already handles notification. Addon authors may be able to
use this functionality.</p>
<p>Not having an alternative for old style classes or mixins could be problematic
for users who aren't ready to update to native class syntax.</p>
<a class="header" href="print.html#alternatives-61" id="alternatives-61"><h1>Alternatives</h1></a>
<p>We could keep <code>volatile()</code> around for any potential addons that may want to use
it, but teach native getters/setters as the preferred path for most use cases.</p>
<p>We could provide <code>volatile</code> as a separate API/decorator to distinguish it from
computed properties, and discourage use for users.</p>
<ul>
<li>Start Date: 2018-09-06</li>
<li>RFC PR: (leave this empty)</li>
<li>Ember Issue: (leave this empty)</li>
</ul>
<a class="header" href="print.html#ember-data--modelfactoryfor" id="ember-data--modelfactoryfor"><h1>ember-data | modelFactoryFor</h1></a>
<a class="header" href="print.html#summary-63" id="summary-63"><h2>Summary</h2></a>
<p>Promote the private <code>store._modelFactoryFor</code> to public API as <code>store.modelFactoryFor</code>.</p>
<a class="header" href="print.html#motivation-64" id="motivation-64"><h2>Motivation</h2></a>
<p>This RFC is a follow-up RFC for <a href="https://github.com/emberjs/rfcs/pull/293">#293 RecordData</a>.</p>
<p>Ember differentiates between <code>klass</code> and <code>factory</code> for classes registered with the container.
At times, <code>ember-data</code> needs the <code>klass</code>, at other times, it needs the <code>factory</code>. For this reason,
<code>ember-data</code> has carried two APIs for accessing one or the other for some time. The public <code>modelFor</code>
provides access to the <code>klass</code> where schema information is stored, while the private <code>_modelFactoryFor</code>
provides access to the factory for instantiation.</p>
<p>We provide access to the class with <code>modelFor</code> roughly implemented as <code>store._modelFactoryFor(modelName).klass</code>.
We instantiate records from this class roughly implemented as <code>store._modelFactoryFor(modelName).create({ ...args })</code>.</p>
<p>For symmetry, both of these APIs should be public. Making <code>modelFactoryFor</code> public would provide a hook
that consumers can override should they desire to provide a custom <code>ModelClass</code> as an alternative
to <code>DS.Model</code>.</p>
<a class="header" href="print.html#detailed-design-52" id="detailed-design-52"><h2>Detailed design</h2></a>
<p>Due to previous complexity in the lookup of models in <code>ember-data</code>, we previously had both <code>modelFactoryFor</code>
and <code>_modelFactoryFor</code>. Despite the naming, both of these methods were private. During a recent cleanup phase,
we unified the methods into <code>_modelFactoryFor</code> and left a deprecation in <code>modelFactoryFor</code>. This RFC proposes
un-deprecating the <code>modelFactoryFor</code> method and making it public, while deprecating the private <code>_modelFactoryFor</code>.</p>
<p>More precisely:</p>
<ul>
<li><code>store._modelFactoryFor</code> becomes deprecated and calls <code>store.modelFactoryFor</code>.</li>
<li><code>store.modelFactoryFor</code> becomes un-deprecated.</li>
</ul>
<a class="header" href="print.html#the-contract-for-modelfactoryfor" id="the-contract-for-modelfactoryfor"><h3>The contract for <code>modelFactoryFor</code></h3></a>
<p>The return value of <code>modelFactoryFor</code> MUST be the result of a call to <a href="https://www.emberjs.com/api/ember/3.4/classes/ApplicationInstance/methods/factoryFor?anchor=factoryFor"><code>applicationInstance.factoryFor</code></a>
where <code>applicationInstance</code> is the <code>owner</code> returned by using <code>getOwner(this)</code> to access the <code>owner</code> of the <code>store</code> instance.</p>
<pre><code class="language-typescript">interface Klass {}

interface Factory {
  klass: Klass,
  create(): Klass
}

interface FactoryMap {
    [factoryName: string]: Factory
}

declare function factoryFor&lt;K extends keyof FactoryMap&gt;(factoryName: K): FactoryMap[K];

interface Store {
  modelFactoryFor(modelName: string): ReturnType&lt;typeof factoryFor&gt;;
}
</code></pre>
<p>Users interested in providing a custom class for their <code>records</code> and who override <code>modelFactoryFor</code>,
would not need to also change <code>modelFor</code>, as this would be the <code>klass</code> accessible via the <code>factory</code>.</p>
<p>Users wishing to extend the behavior of <code>modelFactoryFor</code> could do so in the following manner:</p>
<p><strong>Example 1:</strong></p>
<p><strong>services/store.js</strong></p>
<pre><code class="language-js">import { getOwner } from '@ember/application';
import Store from 'ember-data/store';

export default Store.extend({
  modelFactoryFor(modelName) {
    if (someCustomCondition) {
      return getOwner(this).factoryFor(someFactoryName);
    }
    
    return this._super(modelName);
  }
});
</code></pre>
<a class="header" href="print.html#modelmodelname" id="modelmodelname"><h4><code>Model.modelName</code></h4></a>
<p><code>ember-data</code> currently sets <code>modelName</code> onto the <code>klass</code> accessible via the <code>factory</code>. For classes that do not
inherit from <code>DS.Model</code> this would not be done, although end users may do so themselves in their implementations
if so desired.</p>
<a class="header" href="print.html#what-is-a-valid-factory" id="what-is-a-valid-factory"><h3>What is a valid factory?</h3></a>
<p>The default export of a custom ModelClass <strong>MUST</strong> conform to the requirements of <code>Ember.factoryFor</code>. The requirements
of <code>factoryFor</code> are currently underspecified; however, in practice, this means that the default export is an
instantiable class with a static <code>create</code> method and an instance <code>destroy</code> method or that inherits from <code>EmberObject</code>
(which provides such methods).</p>
<p><strong>Example 2:</strong></p>
<pre><code class="language-javascript">import { assign } from '@ember/polyfills';

export default class CustomModel {
  constructor(createArgs) {
    assign(this, createArgs);
  }
  destroy() {
    // ... do teardown
  }
  static create(createArgs) {
    return new this(createArgs);
  }
}
</code></pre>
<p><strong>Example 3:</strong></p>
<pre><code class="language-javascript">import EmberObject from '@ember/object';

export default class CustomModel extends EmberObject {
  constructor(createArgs) {
    super(createArgs);
  }
}
</code></pre>
<p>Custom classes for models should expect their constructor to receive a single argument: an object with <em>at least</em>
the following.</p>
<ul>
<li>A <code>recordData</code> instance accessible via <code>getRecordData</code> (see below)</li>
<li>Any properties passed as the second arg to <code>createRecord</code></li>
<li>An <code>owner</code> accessible via <code>Ember.getOwner</code></li>
<li>Any DI injections</li>
<li>any other properties that <code>Ember</code> chooses to pass to a class instantiated via <code>factory.create</code> (currently none)</li>
</ul>
<a class="header" href="print.html#getrecorddata" id="getrecorddata"><h3>getRecordData</h3></a>
<p>Every <code>record</code> (instance of the class returned by <code>modelFactoryFor</code>) will have an associated <a href="https://github.com/emberjs/rfcs/pull/293">RecordData</a>
which contains the backing data for the id, type, attributes and relationships of that record.</p>
<p>This backing data can be accessed by using the <code>getRecordData</code> util on the <code>record</code> (or on the <code>createArgs</code> passed to
a record). Using <code>getRecordData</code> on a <code>record</code> is only guaranteed after the record has been instantiated. During
instantiation, this call should be made on the <code>createArgs</code> object passed into the record.</p>
<p><strong>Example 4</strong></p>
<pre><code class="language-javascript">import { getRecordData } from 'ember-data';

export default class CustomModel {
  constructor(createArgs) {
    // during instantiation, `recordData` is available by calling `getRecordData` on createArgs
    let recordData = getRecordData(createArgs);
  }
  someMethod() {
    // post instantiation, `recordData` is available by calling `getRecordData` on the instance
    let recordData = getRecordData(this);
  }
  destroy() {
    // ... do teardown
  }
  static create(createArgs) {
    return new this(createArgs);
  }
}
</code></pre>
<a class="header" href="print.html#how-we-teach-this-43" id="how-we-teach-this-43"><h2>How we teach this</h2></a>
<p>This API would be intended for addon-authors and power users. It is not expected
that most apps would implement custom models, much as it is not expected that most
apps would implement custom <code>RecordData</code>. The teaching story would be limited to
documenting the nature and purpose of <code>modelFactoryFor</code>.</p>
<a class="header" href="print.html#drawbacks-62" id="drawbacks-62"><h2>Drawbacks</h2></a>
<ul>
<li>Users may try to use the hook to instantiate records on their own. Ultimately, the store
should still do the instantiating.</li>
</ul>
<a class="header" href="print.html#alternatives-62" id="alternatives-62"><h2>Alternatives</h2></a>
<p>Users could define models in <code>models/*.js</code> that utilize a custom <code>ModelClass</code>.
However, such an API for custom classes would exclude the ability to dynamically
generate classes.</p>
<a class="header" href="print.html#unresolved-questions-41" id="unresolved-questions-41"><h2>Unresolved questions</h2></a>
<p>None</p>
<ul>
<li>Start Date: 2018-09-10</li>
<li>RFC PR: https://github.com/emberjs/rfcs/pull/373</li>
<li>Ember Issue: (leave this empty)</li>
</ul>
<a class="header" href="print.html#element-modifier-manager" id="element-modifier-manager"><h1>Element Modifier Manager</h1></a>
<a class="header" href="print.html#summary-64" id="summary-64"><h2>Summary</h2></a>
<p>This RFC proposes a low-level primitive for defining element modifiers. It is a parent to the <a href="https://github.com/emberjs/rfcs/pull/353">Modifiers RFC</a>.</p>
<a class="header" href="print.html#motivation-65" id="motivation-65"><h2>Motivation</h2></a>
<p>Ever since Ember 1.0 we have had the concept of element modifiers, however Ember only exposes one modifier; <code>{{action}}</code>. We also do not provide a mechanism for defining your own modifiers and managing their life cycles.</p>
<p>As <a href="https://github.com/emberjs/rfcs/pull/353#issuecomment-417769349">pointed out</a> in the <a href="https://github.com/emberjs/rfcs/pull/353">Element Modifiers RFC</a> we should expose the underlying infrastructure that makes element modifiers possible. Based on our experience, we believe it would be beneficial to open up these new primitives to the wider community. The largest benefit is that it allows the community to experiment with and iterate on APIs outside of the core framework.</p>
<p>This RFC is in the same spirit as the <a href="https://github.com/emberjs/rfcs/blob/master/text/0213-custom-components.md">custom components RFC</a>.</p>
<a class="header" href="print.html#detailed-design-53" id="detailed-design-53"><h2>Detailed design</h2></a>
<p>This RFC introduces the concept of <em>modifier managers</em>. A modifier manager is an object that is responsible for coordinating the lifecycle events that occurs when invoking, installing and updating an element modifier.</p>
<a class="header" href="print.html#registering-modifier-managers" id="registering-modifier-managers"><h3>Registering modifier managers</h3></a>
<p>Modifier managers are registered with the <code>modifier-manager</code> type in the
application's registry. Similar to services, modifier managers are singleton
objects (i.e. <code>{ singleton: true, instantiate: true }</code>), meaning that Ember
will create and maintain (at most) one instance of each unique modifier
manager for every application instance.</p>
<p>To register a modifier manager, an addon will put it inside its <code>app</code> tree:</p>
<pre><code class="language-js">// ember-basic-component/app/modifier-managers/basic.js

import EmberObject from '@ember/object';

export default EmberObject.extend({
  // ...
});
</code></pre>
<p>(Typically, the convention is for addons to define classes like this in its
<code>addon</code> tree and then re-export them from the <code>app</code> tree. For brevity, we will
just inline them in the <code>app</code> tree directly for the examples in this RFC.)</p>
<p>This allows the modifier manager to participate in the DI system  receiving
injections, using services, etc. Alternatively, modifier managers can also
be registered with imperative API. This could be useful for testing or opt-ing
out of the DI system. For example:</p>
<pre><code class="language-js">// ember-basic-modifier/app/initializers/register-basic-modifier-manager.js

const MANAGER = {
  // ...
};

export function initialize(application) {
  // We want to use a POJO here, so we are opt-ing out of instantiation
  application.register('modifier-manager:basic', MANAGER, { instantiate: false });
}

export default {
  name: 'register-basic-modifier-manager',
  initialize
};
</code></pre>
<a class="header" href="print.html#determining-which-modifier-manager-to-use" id="determining-which-modifier-manager-to-use"><h2>Determining which modifier manager to use</h2></a>
<p>When invoking the modifier <code>&lt;p {{foo baz bar=bar}} /&gt;</code>, Ember will first resolve the
modifier class (<code>modifier:foo</code>, usually the <code>default</code> export from
<code>app/modifiers/foo.js</code>). Next, it will determine the appropiate modifier
manager to use based on the resolved modifier class.</p>
<p>Ember will provide a new API to assign the modifier manager for a element modifier
class:</p>
<pre><code class="language-js">// my-app/app/modifier/foo.js

import EmberObject from '@ember/object';
import { createManager } from './basic-manager';
import { setModifierManager } from '@ember/modifier';

export default setModifierManager(createManager, EmberObject.extend({
  // ...
}));
</code></pre>
<pre><code class="language-js">// my-app/app/modifier/basic-manager.js

// ...

export function createManager(owner) {
  return new BasicManager(owner);
}
</code></pre>
<p><code>setModifierManager</code> takes two parameters. The first parameter is a function that takes an <code>Owner</code> and returns an instance of a manager. The second parameter is the base class that applications would extend from.</p>
<p>In reality, an app developer would never have to write this in their apps,
since the modifier manager would already be assigned on a super-class provided
by the framework or an addon. The <code>setModifierManager</code> function is essentially
a low-level API designed for addon authors and not intended to be used by app
developers. Attempting to reassign the modifier manager when one is already
assinged on a super-class will be an error. If no modifier manager is set, it
will also result in a runtime error when invoking the modifier.</p>
<a class="header" href="print.html#modifier-lifecycle" id="modifier-lifecycle"><h2>Modifier Lifecycle</h2></a>
<p>Back to the <code>&lt;p {{foo baz bar=bar}}&gt;&lt;/p&gt;</code> example.</p>
<p>Once Ember has determined the modifier manager to use, it will be used to manage the modifiers's lifecycle.</p>
<a class="header" href="print.html#createmodifier" id="createmodifier"><h3><code>createModifier</code></h3></a>
<p>The first step is to create an instance of the modifier. Ember will invoke the modifier manager's <code>createModifier</code> method:</p>
<pre><code class="language-js">// ember-basic-component/app/modifier-managers/basic.js

import EmberObject from '@ember/object';

export default EmberObject.extend({
  createModifier(factory, args) {
    return factory.create(args);
  },
});
</code></pre>
<p>The <code>createModifier</code> method on the modifier manager is responsible for taking the modifier's factory and the arguments passed to the modifier (the ... in {{foo ...}}) and return an instantiated modifier.</p>
<p>The first argument passed to <code>createModifier</code> is the result returned from the <code>factoryFor</code> API. It contains a class property, which gives you the the raw class (the default export from app/modifiers/foo.js) and a create function that can be used to instantiate the class with any registered injections, merging them with any additional properties that are passed.</p>
<p>The second argument is a snapshot of the arguments passed to the modifier in the template invocation, given in the following format:</p>
<pre><code class="language-js">{
  positional: [ ... ],
  named: { ... }
}
</code></pre>
<p>For example, given the following invocation:</p>
<pre><code class="language-hbs">&lt;p {{foo baz bar=bar}}&gt;&lt;/p&gt;
</code></pre>
<p>You will get the following as the second argument:</p>
<pre><code class="language-js">{
  positional: [true],
  named: {
    &quot;bar&quot;: &quot;Another RFC by Chad&quot;
  }
}
</code></pre>
<p>The arguments object should not be mutated (e.g. args.positional.pop() is no good). In development mode, it might be sealed/frozen to help prevent these kind of mistakes.</p>
<p>This hook has the following timing semantics:</p>
<p><strong>Always</strong></p>
<ul>
<li>called as discovered during DOM construction</li>
<li>called in defintion order in template</li>
</ul>
<a class="header" href="print.html#installmodifier" id="installmodifier"><h3><code>installModifier</code></h3></a>
<p>Once the modifier instance has been created, the next step is to install the modifier on to the underlying element.</p>
<pre><code class="language-js">// ember-basic-component/app/modifier-managers/basic.js

import EmberObject from '@ember/object';

export default EmberObject.extend({
  createModifier(factory, args) {
    return factory.create(args.named);
  },

  installModifier(instance, element, args) {
    instance.element = element;
    if (instance.wasInstalled !== undefined) {
      instance.wasInstalled(args.positional, args.named);
    }
  },

  // ...
});
</code></pre>
<p><code>installModifer</code> is responsible for giving access to the underlying element and arguments to the modifier instance.</p>
<p>The first argument passed to <code>installModifer</code> is the result of <code>createModifier</code>. The second argument is the <code>element</code> the modifier was defined on. The third argument is the same snapshot of the arguments passed to the modifier in the template invocation that <code>createModifier</code> recieved.</p>
<p>This hook has the following timing semantics:</p>
<p><strong>Always</strong></p>
<ul>
<li>called after all children modifier managers <code>installModifer</code> hook are called</li>
<li>called after DOM insertion</li>
</ul>
<p><strong>May or May Not</strong></p>
<ul>
<li>be called in the same tick as DOM insertion</li>
<li>have the sibling nodes fully initialized in DOM</li>
</ul>
<a class="header" href="print.html#updatemodifier" id="updatemodifier"><h3><code>updateModifier</code></h3></a>
<p>Modifiers are only updated when one of its arguments is changed. In this case Ember will call the manager's <code>updateModifier</code> method to give the manager the oppurtunity to reflect those changes on the modifier instance, before re-rendering.</p>
<pre><code class="language-js">// ember-basic-component/app/modifier-managers/basic.js

import EmberObject from '@ember/object';

export default EmberObject.extend({
  createModifier(factory, args) {
    return factory.create(args.named);
  },

  installModifier(instance, element, args) {
    instance.element = element;
    if (instance.wasInstalled !== undefined) {
      instance.wasInstalled(args.positional, args.named);
    }
  },

  updateModifier(instance, args) {
    if (instance.didUpdateArguments !== undefined) {
      instance.didUpdateArguments(args.positional, args.named);
    }
  }

  // ...
});
</code></pre>
<p><code>updateModifier</code> recieves the modifier instance and also the the updated snapshot of arguments.</p>
<p>This hook has the following timing semantics:</p>
<p><strong>Always</strong></p>
<ul>
<li>called after the arguments to the modifier have changed</li>
</ul>
<p><strong>Never</strong></p>
<ul>
<li>called if the arguments to the modifier are constants</li>
</ul>
<a class="header" href="print.html#destroymodifier" id="destroymodifier"><h3><code>destroyModifier</code></h3></a>
<p><code>destroyModifier</code> will be called when the modifier is no longer needed. This is intended for performing object-model level cleanup.</p>
<pre><code class="language-js">// ember-basic-component/app/modifier-managers/basic.js

import EmberObject from '@ember/object';

export default EmberObject.extend({
  createModifier(factory, args) {
    return factory.create(args.named);
  },

  installModifier(instance, element, args) {
    instance.element = element;
    if (instance.wasInstalled !== undefined) {
      instance.wasInstalled(args.positional, args.named);
    }
  },

  destroyModifier(instance, args) {
    if (instance.willDestroyDOM !== undefined) {
      instance.willDestroyDOM();
    }
  }
});
</code></pre>
<p>This hook has the following timing semantics:</p>
<p><strong>Always</strong></p>
<ul>
<li>called after all children modifier manager's <code>destroyModifier</code> hook is called</li>
</ul>
<p><strong>May or May Not</strong></p>
<ul>
<li>be called in the same tick as DOM removal</li>
</ul>
<a class="header" href="print.html#capabilities-1" id="capabilities-1"><h2>Capabilities</h2></a>
<p>In addition to the methods specified above, modifier managers are required to
have a <code>capabilities</code> property.  This property must be set to the result of
calling the <code>capabilities</code> function provided by Ember.</p>
<a class="header" href="print.html#versioning-1" id="versioning-1"><h3>Versioning</h3></a>
<p>The first, mandatory, argument to the <code>capabilities</code> function is the modifier
manager API, which is denoted in the <code>${major}.${minor}</code> format, matching the
minimum Ember version this manager is targeting. For example:</p>
<pre><code class="language-js">// ember-basic-component/app/component-managers/basic.js

import { capabilities } from '@ember/modifier';
import EmberObject from '@ember/object';

export default EmberObject.extend({
  capabilities: capabilities('3.6'),

  createModifier(factory, args) {
    return factory.create(args.named);
  },

  installModifier(instance, element, args) {
    instance.element = element;
    if (instance.wasInstalled !== undefined) {
      instance.wasInstalled(args.positional, args.named);
    }
  },

  destroyModifier(instance, args) {
    if (instance.willDestroyDOM !== undefined) {
      instance.willDestroyDOM();
    }
  }
});
</code></pre>
<p>This allows Ember to introduce new capabilities and make improvements to this
API without breaking existing code.</p>
<p>Here is a hypothical scenario for such a change:</p>
<ol>
<li>
<p>Ember 3.6 implemented and shipped the modifier manager API as described in
this RFC.</p>
</li>
<li>
<p>The <code>ember-basic-modifier</code> addon released version 1.0 with the modifier
manager shown above (notably, it declared <code>capabilities('3.6')</code>).</p>
</li>
<li>
<p>In Ember 3.8, we determined that constructing the arguments object passed to
the hooks is a major performance bottleneck, and changes the API to pass a
&quot;proxy&quot; object with getter methods instead (e.g. <code>args.getPositional(0)</code> and
<code>args.getNamed('foo')</code>).</p>
<p>However, since Ember sees that the <code>basic</code> modifier manager is written to
target the <code>3.6</code> API version, it will retain the old behavior and passes the
old (more expensive) &quot;reified&quot; arguments object instead, to avoid breakage.</p>
</li>
<li>
<p>The <code>ember-basic-modifier</code> addon author would like to take advantage of
this performance optimization, so it updates its modifier manager code to
work with the arguments proxy and changes its capabilities declaration to
<code>capabilities('3.8')</code> in version 2.0.</p>
</li>
</ol>
<p>This system allows us to rapidly improve the API and take advantage of
underlying rendering engine features as soon as they become available.</p>
<p>Note that addon authors are not <em>required</em> to update to the newer API.
Concretely, modifier manager APIs have the following support policy:</p>
<ul>
<li>
<p>API versions will continue to be supported in the same major release of
Ember. As shown in the example above, <code>ember-basic-modifier</code> 1.0 (which
targets modifier manager API version 3.6), will continue to work on
Ember 3.8. However, the reverse is not true  modifier manager API version
3.8 will (somewhat obviously) not work in Ember 3.6.</p>
</li>
<li>
<p>In addition, to ensure a smooth transition path for addon authors and app
developers across major releases, each Ember version will support (at least)
the previous LTS version as of the release was made. For example, if 3.16 is
the last LTS release of the 3.x series, the modifier manager API version
3.16 will be supported by Ember 4.0 through 4.4, at minimum.</p>
</li>
</ul>
<p>Addon authors can also choose to target multiple versions of the modifier
manager API using <a href="https://github.com/pzuraq/ember-compatibility-helpers/">ember-compatibility-helpers</a>:</p>
<pre><code class="language-js">// ember-basic-modifier/app/modifier-managers/basic.js

import { gte } from 'ember-compatibility-helpers';

let ComponentManager;

if (gte('3.5')) {
  ComponentManager = EmberObject.extend({
    capabilities: capabilities('3.8'),

    // ...
  });
} else {
  ComponentManager = EmberObject.extend({
    capabilities: capabilities('3.6'),

    // ...
  });
}

export default ComponentManager;
</code></pre>
<p>Since the conditionals are resolved at build time, the irrevelant code will be
stripped from production builds, avoiding any deprecation warnings.</p>
<a class="header" href="print.html#optional-features-1" id="optional-features-1"><h3>Optional Features</h3></a>
<p>The second, optional, argument to the <code>capabilities</code> function is an object
enumerating the optional features requested by the modifier manager.</p>
<p>In the hypothical example above, while the &quot;reified&quot; arguments objects may be
a little slower, they are certainly easier to work with, and the performance
may not matter to but the most performance critical modifiers. A modifier
manager written for Ember 3.8 (again, only hypothically) and above would be
able to explicitly opt back into the old behavior like so:</p>
<pre><code class="language-js">// ember-basic-component/app/component-managers/basic.js

import { capabilities } from '@ember/component';
import EmberObject from '@ember/object';

export default EmberObject.extend({
  capabilities: capabilities('3.8', {
    reifyArguments: true
  }),

  // ...
});
</code></pre>
<p>In general, we will aim to have the defaults set to as bare-bone as possible,
and allow the component managers to opt into the features they need in a PAYGO
(pay-as-you-go) manner, which aligns with the Glimmer VM philosophy. As the
rendering engine evolves, more and more feature will become optional.</p>
<p>At this time this RFC does not specify any optional capabilties for the initial release.</p>
<a class="header" href="print.html#how-we-teach-this-44" id="how-we-teach-this-44"><h2>How we teach this</h2></a>
<p>What is proposed in this RFC is a low-level primitive. We do not expect most users to interact with this layer directly. Instead, most users will simply benefit from this feature by subclassing these special modifiers provided by addons.</p>
<a class="header" href="print.html#drawbacks-63" id="drawbacks-63"><h2>Drawbacks</h2></a>
<p>In the long term, there is a risk of fragmentating the Ember ecosystem with many competing modifier APIs. However, given the Ember community's strong desire for conventions, this seems unlikely. We expect this to play out similar to the data-persistence story  there will be a primary way to do things (Ember Data), but there are also plenty of other alternatives catering to niche use cases that are underserved by Ember Data.</p>
<a class="header" href="print.html#alternatives-63" id="alternatives-63"><h2>Alternatives</h2></a>
<p>Instead of focusing on exposing enough low-level primitives we can just ship the high level API as described in <a href="https://github.com/emberjs/rfcs/pull/353">RFC#353</a>.</p>
<a class="header" href="print.html#unresolved-questions-42" id="unresolved-questions-42"><h2>Unresolved questions</h2></a>
<p>TBD?</p>

                </div>

                <!-- Mobile navigation buttons -->
                

                

            </div>

            

            

        </div>


        <!-- Local fallback for Font Awesome -->
        <script>
            if ($(".fa").css("font-family") !== "FontAwesome") {
                $('<link rel="stylesheet" type="text/css" href="_FontAwesome/css/font-awesome.css">').prependTo('head');
            }
        </script>

        <!-- Livereload script (if served using the cli tool) -->
        

        

        

        
        <script>
            $(document).ready(function() {
                window.print();
            })
        </script>
        

        <script src="highlight.js"></script>
        <script src="book.js"></script>
    </body>
</html>
